---
slug: "API-분석"
---
서브도메인 탐색의 다음 단계에 필요한 정찰 기술은 API 엔드포인트 분석이다.
이 어플리케이션에서 사용하는 도메인에는 어떤 것이 있는가?
만약 이 애플리케이션에 세 개의 도메인이 있다면(`x.domain`, `y.domain`, `z.domain`) 각각의 도메인에 고유한 API 엔드포인트가 있을 것이라고 짐작할 수 있다.

일반적으로 엔드포인트를 찾을 대도 서브도메인을 찾는 것과 마찬가지로 브루트 포스 공격과 딕셔너리 공격을 할 수 있지만, 수작업과 논리적 분석을 통해 더 많은 것을 알아 낼 수 있다.

웹 애플리케이션의 구조를 학습함에 있어 API 찾기는 서브도메인 탐색에 이어 두 번째 단계로 수행하는 단계이다.
이 단계를 통해 노출된 API 찾기는 서브도메인 탐색에 이어 두번째 단계로 수행하는 단계이다.
이 단계를 통해 노출된 API의 목적을 이해하는 데 도움이 되는 정보를 얻을 수 있다.
네트워크에 API가 노출된 이유를 이해하는 것은 애플리케이션에서 어떻게 사용되며 사업적인 목적이 무엇인지 이해하는 단초가 된다.

# 엔드포인트 탐색
오늘날 엔터프라이즈 애플리케이션 대부분은 API 구조를 정의 할 때 특정 스킴을 따른다는 것은 앞에서 논의 했다.
API는 일반적으로 REST 포맷이나 SOAP 포맷을 따른다.
REST가 더 많이 사용되며, 현대 웹 애플리케이션 API에 이상적인 구조로 평가된다.

브라우저에 포함된 개발자 도구를 사용해 애플리케이션의 네트워크 요청을 분석 할 수 있다.

```shell
GET api.mega-bank.com/users/1234
GET api.mega-bank.com/users/1234/payments
POST api.mega-bank.com/users/1234/payments
```
위와 같은 HTTP 요청이 많이 발생한다면, REST API 가 사용되는 것으로 가정해도 좋다.
각 엔드포인트 기능보다는 특정 리소스를 지정한다.

또한 사용자가 1234와 리소스 payments가 중첩된 것으로 보아 이 API가 계층적인 것으로 가정할 수 있다.
이는 REST 방식으로 설계되었음을 시사하는 또 다른 단서이다.

각 요청에서 전송되는 쿠키와 헤더를 살펴보더라도 REST 아키텍터의 특징이 들어난다.

```shell
POST /users/1234/payments HTTP/1.1
Host: api.mega-bank.com
Authoriztion: Bearer abc21323
Content-Type : application/x-www-form-urlencoded
User-AgentL Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/1.0 (KHTML, like Gecko)
```

요청이 이뤄질 때마다 토큰을 보낸다는 점도 REST API설계의 특징이다.
REST API는 상태 비저장으로 간주되며 이는 서버가 요청자를 추적하지 않음을 뜻한다.

REST API가 맞다는 것을 확인했으면, 엔드포인트를 논리적으로 추정할 차례다.
REST 아키텍처가 지원하는 HTTP 동사를 아래에 나열했다.

| `REST HTTP` 동사 | 용도     |
| -------------- | ------ |
| `GET`          | 생성     |
| `POST`         | 읽기     |
| `PUT`          | 갱신(교체) |
| `PATCH`        | 갱신(수정) |
| `DELETE`       | 삭제     |
아키텍처 명세에서 지원하는 HTTP 동사에 관한 지식을 가지고 특정 리소스를 대상으로 하는 요청을 브라우저에서 살펴 볼 수 있다.
그런 다음 그러한 리소스에 대해 다른 HTTP 동사를 사용해 요청을 시도하고, API가 흥미로운 것을 반환하는지 지켜볼 수 있다.

HTTP 명세에는 특정 API 동사에 대한 정보만 제공하는 특수만 메서드가 정의 되어 있다.
이 메서드는 OPTIONS 라는 것으로 API 를 정찰할 때 이것을 가장 먼저 시도한다.
터미널에서 curl 명령을 사용해 쉽게 요청 할 수 있다.

```shell
curl -i -X OPTIONS https://api.mega-bank.com/users/1234
```

일반적으로 OPTIONS는 공개 용으로 설계된 API에서만 사용할 수 있기 때문에, 처음에 쉽게 시도해볼 수 있지만, 테스트 하려는 앱 대부분에 적용할 수 있는 견고한 탐색 솔루션은 아니다.
수용되는 HTTP 동사를 더 잘 결정할 수 있는 방법을 알아보자
브라우저에서 처음 본 API 호출은 다음과 같다.

```shell
GET api.mega-bank.com/users/1234
```

이것은 다음과 같이 확장 할 수 있다.

```shell
GET api.mega-bank.com/users/1234
POST api.mega-bank.com/users/1234
PUT api.mega-bank.com/users/1234
PATCH api.mega-bank.com/users/1234
DELETE api.mega-bank.com/users/1234
```

위 HTTP 동사 목록을 염두에 두고 우리의 이론을 검증하는 스크립트를 작성해보자

:::warning 
- HTTP 엔드포인트 HTTP 동사에 대한 브루트 포싱은 애플리케이션 데이터를 삭제하거나 변경하는 부작용을 일으킨다.
- 애플리케이션 API에 대한 브루트 포스를 시도하기 전에 애플리케이션 소유자에게 명시적으로 허락 받아야한다.

:::

스크립트의 목적은 단순하다.
주어진 엔드포인트(우리는 이 엔드포인트가 최소 한 가지 HTTP 동사를 수용함을 알고 있다.)를 사용하여 추가적인 HTTP 동사를 시도하는 것이다.
각 엔드포인트에 대해 추가적인 HTTP 동사를 시도한 결과를 기록해서 출력한다.

```js
/*
어떤 URL(API 엔드포인트와 연관)이 주어졌을 때, 주어진
엔드포인트에 어느 HTTP 동사가 대응되는지 결정하기 위해
다양한 HTTP 동사를 가지고 요청한다.
*/

const discoverHTTPVerbs = function(url){
	const verbs = ['POST', 'GET', 'PUT', 'PATCH', 'DELETE']
	const promises = [];

	verbs.forEach((verb)=>{
		const promise = new Promise((resolve, reject)=>{
			const http = new XMLHttpRequest();

			http.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');

			/*
				요청이 성공하면 프로미스가 성공하여,
				결과에 상태 코드가 포함된다.
			*/
			http.onreadystatechange = function(){
				if(http.readyState === 4){
					return resolve({ verb: verb , status: http.status })
				}
			}
			
			/*
				요청이 성공하지 않거나 제한 시간 내에 완료되지 않으면,
				그 요청을 실패로 표시한다.
				평균 응답 시간을 참고하여 제한시간을 조정한다.
			*/
			setTimeout(()=>{
				return resolve({ verb: verb, status: -1 })
			}, 1000)

			// HTTP 요청을 시작
			http.send({});
			
			// Promise 배열에 promise 객체를 추가
			promise.push(promise)
			/*
			HTTP 요청을 시도한 각각의 동사에 대한
			프로미스의 결과를 콘솔에 출력한다.
			*/
			Promise.all(promises).then(function(values){
				console.log(values);
			})
		})
	})
}
```

위 스크립트 함수는 기술적으로 단순하다. HTTP 엔드포인트는 브라우저에 보낼 메시지와 상태 코드를 반환합니다.어느 상태 코드가 나오는지 크게 관심이 없고 단지 상태 코드가 나오기만 하면 됩니다.

API에 각각 HTTP 동사에 대해 요청을 했다.
서버 대부분은 응답하지 않아 유효한 엔드포인트의 맵을 만들 수 없으므로, 요청에 대한 응답을 1 초 내에 받지 못하면 -1을 반환하는 케이스를 추가한다.

일반적으로 1초면 API가 충분히 응답하고도 남는 시간이다.
테스트 상황에 맞게 이 시간을 조정하자

모든 프로미스가 처리되면 출력된 로그에 HTTP 동사와 연관된 엔드포인트가 있는지 찾아보자

## 인증 메커니즘
API 엔드 포인트에 적합한 페이로드 형상을 추측하기는 API 엔드포인트의 존재를 확인하는 것에 비해 훨씬 어렵다.
가장 쉬운 방법은 브라우저를 통해 전송되는 알려진 요청의 구조를 분석하는 것이다.
이를 바탕으로 API 엔드포인트에 요구되는 형상을 추정해서 수작업으로 테스트 한다.

API 엔드 포인트의 구조를 탐색하는 것을 자동화 할 수는 있지만, 기존 요청을 분석하지 않고, 마구잡이로 시도했다가는 금세 탐지 되어 로그가 남게 된다.

거의 모든 애플리케이션에 공통적으로 존재하는 로그인, 가입, 패스워드 재설정 같은 엔드포인트부터 시도하는 것이 최선이다.
인증은 보통 표준화된 스킴에 따라 설꼐하므로 다른 애플리케이션에서도 비슷한 형태의 페이로드를 사용할 수 있는 경우가 많다.

공개된 웹 사용자 인터페이스가 있는 애플리케이션이라면 로그인 페이지가 있기 마련이다.
그렇지만 세션을 인증하는 방식은 제 각기 다를 수 있습니다.
현대적 애플리케이션에서는 요청 때마다 인증 토큰을 전송하는 경우가 많으므로, 인증 스킴의 종류를 파악하는 것이 중요하다.

사용되는 인증의 종류와 요청에 토큰을 어떻게 첨부 하는지를 역 공학으로 알아낸다면 인증된 사용자 토큰의 의존하는 다른 API 엔드 포인트를 분석하기가 수월해진다.

| 인증 스킴         | 세부 구현                             | 장점                                 | 단점                                       |
| ------------- | --------------------------------- | ---------------------------------- | ---------------------------------------- |
| HTTP 기본 인증    | 요청할 때마다 사용자 명과 패스워드를 보냄           | 모든 브라우저가 자체적으로 지원                  | 세션이 만료되지 않으며 가로채기 쉬움                     |
| HTTP 다이제스트 인증 | 요청 할 때마다 해시된 사용자명:realm: 패스우드를 보냄 | 가로채기 어렵고 만료된 토큰을 서버가 거부할 수 있음      | 암호화 강도가 사용하는 해싱 알고리즘에 의존적임               |
| OAuth         | 베어러토큰 기반 인증으로 다른 웹사이트의 인증을 이용함    | 토큰화된 퍼미션을 공유함으로써 서로 다른 앱을 통합할 수 있음 | 피싱 위험이 있으며, 중앙 사이트가 침해될 경우 연결된 모든 앱이 침해됨 |
`https://www.mega-bank.com` 에 로그인해 네트워크 요청을 분석한다면, 로그인 성공 후 다음과 같은 것을 볼 수 있습니다.

```
GET /homepage
HOST mega-bank.com
Authorization : Basic am9~
ContentType : application/json
```

기본 이늦ㅇ 헤더를 보내는 것을 보면 HTTP 기본 인증인 것 처럼 보인다.
게다가 문자열 am9~ 는 `username:password` 문자열을 베이스 64로 인코딩 한 것이다.
이것은 HTTP 를 통해 사용자 명과 패스워드 조합을 보내는 가장 일반적인 포맷이다.

브라우저 콘솔에서 내장된 btoa(문자열)과 atob(베이스64)를 사용해 문자열을 베이스64로, 또는 그 반대로 변환할 수 있다.












