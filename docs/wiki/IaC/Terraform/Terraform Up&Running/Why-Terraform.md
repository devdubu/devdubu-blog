---
slug: "Why-Terraform"
---
- [DevOps의 핵심 가치](#DevOps의 핵심 가치)
- [코드형 인프라](#코드형 인프라)
- [IaC의 네가지 범주](#코드형 인프라#IaC의 네가지 범주)
	- [애드 혹 스크립트](#IaC의 네가지 범주#애드 혹 스크립트)
		- [예시](#애드 혹 스크립트#예시)
	- [구성 관리 도구](#IaC의 네가지 범주#구성 관리 도구)
		- [예시](#구성 관리 도구#예시)
		- [코딩 규칙](#구성 관리 도구#코딩 규칙)
		- [멱등성](#구성 관리 도구#멱등성)
		- [분산형 구조](#구성 관리 도구#분산형 구조)
	- [서버 템플릿 도구](#IaC의 네가지 범주#서버 템플릿 도구)
		- [가상 머신](#서버 템플릿 도구#가상 머신)
			- [장점](#가상 머신#장점)
			- [단점](#가상 머신#단점)
		- [컨테이너](#서버 템플릿 도구#컨테이너)
			- [장점](#컨테이너#장점)
			- [단점](#컨테이너#단점)
- [코드형 인프라의 장점](#코드형 인프라의 장점)
- [셀프 서비스](#코드형 인프라의 장점#셀프 서비스)
- [속도와 안정성](#코드형 인프라의 장점#속도와 안정성)
- [문서화](#코드형 인프라의 장점#문서화)
- [버전 관리](#코드형 인프라의 장점#버전 관리)
- [확인 및 검사](#코드형 인프라의 장점#확인 및 검사)
- [재사용성](#코드형 인프라의 장점#재사용성)
	- [운영 관리의 편안함과 행복](#재사용성#운영 관리의 편안함과 행복)
- [테라폼의 동작 방식](#테라폼의 동작 방식)
- [테라폼이 다른 코드형 인프라 도구와 다른 점은 무엇인가?](#테라폼이 다른 코드형 인프라 도구와 다른 점은 무엇인가?)
- [구성 관리 vs 배포 도구](#테라폼이 다른 코드형 인프라 도구와 다른 점은 무엇인가?#구성 관리 vs 배포 도구)
- [가변적 인프라 vs 변하지 않는 인프라](#테라폼이 다른 코드형 인프라 도구와 다른 점은 무엇인가?#가변적 인프라 vs 변하지 않는 인프라)
- [절차적 언어 vs 선언적 언어](#테라폼이 다른 코드형 인프라 도구와 다른 점은 무엇인가?#절차적 언어 vs 선언적 언어)
- [마스터 유무](#테라폼이 다른 코드형 인프라 도구와 다른 점은 무엇인가?#마스터 유무)
- [에이전트 유무](#테라폼이 다른 코드형 인프라 도구와 다른 점은 무엇인가?#에이전트 유무)
	- [부트 스트랩핑](#에이전트 유무#부트 스트랩핑)
	- [유지 관리](#에이전트 유무#유지 관리)
	- [보안](#에이전트 유무#보안)
- [커뮤니티 규모](#테라폼이 다른 코드형 인프라 도구와 다른 점은 무엇인가?#커뮤니티 규모)

---

# DevOps
- DevOps는 프로세스와 방법 그리고 기술의 집합이며, 어느 조직의 이름이나 직책, 특정 기술을 대표하지 않는다.
- 많은 사람이 DevOps의 의미를 꽤 다르게 정의하고 있지만, 이 책에서는 다음과 같이 정의 한다.

:::INFO DevOps의 목적은 소프트웨어를 전달하기 위한 절차와 방법을 훨씬 효율적으로 만드는 것이다.
:::

- 소스 코드를 매번 수동으로 통합하고, 오류를 눈으로 검출해야 하는 악몽에서 벗어나 코드를 지속해서 통합하고 이상 유무를 자동으로 검증하며, 항상 배포 가능한 상태로 만들 수 있다.
- 하루에 수십 번 혹은 코드를 커밋 할 때마다 배포할 수 있게 되었다.
- 서비스 장애와 중지 시간을 고려하여 자동으로 복구 할 수 있도록 구성 되어 있으며, 자동으로 복구하지 못할 때는 시스템을 통한 모니터링과 경고로 문제 상황을 충분히 감지 할 수 있다.

:::example 노르스트롬(Nordstrom)사의 DevOps 모범 사례
- 한달의 기능 업데이트를 <mark>두배</mark> 더 할 수 있게 되었다.
- 결함을 <mark>절반</mark>으로 줄였으며, 서비스 기획부터 개발과 상용 적용까지의 시간을 <mark>60%</mark> 줄일 수 있었다.
- 상용 서비스 환경에서 발생하는 문제를 <mark>60 ~ 90% 줄</mark>였다.

:::

## DevOps의 핵심 가치
- DevOps의 움직임에는 문화, 자동화, 측정, 공유 라는 4가지 핵심 가치가 존재합니다.
- 해당 책은 모든 부분을 다루지 않지만, <mark>자동화</mark> 부분을 집중해서 다룰 예정입니다.

# 코드형 인프라
:::quetion 코드형 인프라란?
- 코드 형태로 인프라를 작성, 정의, 배포, 업데이트 하는 것을 의미한다.
- 물리 장비를 설정하는 것 뿐만 아니라, 모든 운영을 코드 형태로 한다는 것이 중요하다.
- 실제 DevOps는 서버, 데이터베이스, 네트워크, 로그 파일, 애플리케이션 설정, 자동화된 검증 절차, 배포 방법 등 모든 것을 코드 형태로 관리한다.
:::

## IaC의 네가지 범주
- 애드 혹 스크립트
- 구성 관리 도구
- 서버 템플릿 도구
- 서버 프로비전 도구

### 애드 혹 스크립트
- 가장 간단하게 코드 형태로 자동화를 구현할 수 있는 것은 즉각적인 호출과 응답을 할 수 있는 스크립트를 만드는 것이다.
- 수동으로 작업하는 것을 절차별로 정의한 다음에 스크립트 언어(bash, ruby, python)로 구현하고 대상 장비에서 수행한다.

#### 예시
- 다음과 같이 의존성을 확인하며 설치하면 Git 저장소로부터 코드를 내려받으며, 아파치 웹 서버를 시작하는 `step-webserver.sh` 라는 bash 스크립트를 볼 수 있다.
```bash
# Update the apt-get cache
sudo apt-get update

# Install PHP
sudo apt-get install -y php

# Install Apache
sudo apt-get install -y apache2

# Copy the code from the repository
sudo git cloen https://github.com/brikis98/php-app.git /var/www/html/app

# Start Apache
sudo service apache2 start
```
- 애드 혹 스크립트는 대중적인 프로그래밍 언어를 사용하여 원하는 것이라도 개발할 수 있지만, 모든 것을 직접 개발해야 한다.
- 코드형 인프라를 위해 개발된 도구들은 일반적으로 복잡한 작업을 수행하는 데 간결한 API를 제공하지만, IaC 일반적인 프로그래밍 언어를 사용한다면, 모든 작업에 대해 직접 코드를 작성해야 한다.
- 또한 IaC는 일반적인 코드와 같이 자유로운 형태로 작성하는 것이 아닌 특정 코드 구조와 문법 형태에 따라서 작성하도록 만들어졌다.
- 웹 서버 한두 대를 배포하는 것에 대해서는 일반 코드 형태로 큰 문제는 아니지만, 수많은 서버와 데이터베이스, 부하 분산 장치, 네트워크 설정을 관리하기 위해서는 혼란스러울 수밖에 없다.
- 결론적으로 애드 혹 스크립트는 규모가 작거나 단발성 작업에 적합하다.
- 모든 장비를 코드 형태로 관리할 계획이라면, 대규모 인프라 관리 목적에 의해 개발된 IaC도구를 통해 관리 해아한다.

### 구성 관리 도구
- Chef, Puppet, Ansible, Saltstack은 구성 관리 도구에 속한다.
- 서버에 소프트웨어를 설치하거나, 관리하는 목적으로 사용한다.

#### 예시
- 이전 아파치 웹 서버를 설치하는 배시 스크립트와 동일한 작업을 하는 Ansible Role은 다음과 같다.
```yaml
- name: Update the apt-get cache
  apt:
    update_cache: yes

- name: Install PHP
  apt:
    name: php

- name: Install Apache
  apt:
    name: apache2

- name: Copy the code from the repository
  apt:
    git : repo=https://github.com/brikis98/php-app.git dest=/var/www/html/app
- name : Start Apache
  service: name=apache2 state=started enabled=yes
```
- 구성 관리 도구의 코드는 Bash 스크립트와 비슷하나 더 많은 장점을 제공한다.
#### 코딩 규칙
- Ansible은 문서화, 파일 배열 구성, 명확히 정의된 변수, 암호화 관리를 포함하여 일관성 있고, 예측 가능한 구조로 개발하도록 구성되어 있다.
- 모든 개발자와 운영자가 각각 애드 혹 스크립트의 관리 방법이 달랐다면, 코드 작성 규칙을 통해 더욱더 쉽고 읽고 관리 할 수 있다.

#### 멱등성
- 애드 혹 스크립트를 개발하는 작업 자체는 어렵지 않다.
- 하지만, 단발성 스크립트가 아니라 지속해서 수행해야 한다면, 폴더가 이미 생성되어 있는지, 설정 값에 특정 변수가 이미 선언되어 있는지 애플리케이션이 이미 실행 중인 모든 상황을 고려해서 개발하고 수행하여야 한다.
:::info 멱등성은 같은 코드라면 수행 횟수에 상관 없이 결과값이 항상 같아야 한다는 의미이다.

:::

- 배시 스크립트에서 멱등성을 구현하다고 하면 앞에서 설명한 많은 고려사항을 조건문으로 처리해야 한다.
- 앞의 앤서블 롤에 따른 동작 방식을 예로 들면, 아파치가 설치되어 있지 않을 때만 아파치의 설치를 진행하고,웹 서버가 동작하고 있지 않을 때는 아파치를 실행시키는 방식이다.
- 결론적으로 몇번을 수행하더라고 항상 같은 형상과 멱등성이 유지된다.

#### 분산형 구조
![Pasted-image-20230411111026.png](/img/이미지 창고/Pasted-image-20230411111026.png)
- 애드 혹 스크립트는 소규모, 단발성에 적합하며, 앤서블을 포함한 다른 구성 관리 도구들은 대규모 분산 환경에 관리 할 수 있도록 설계 되어 있다.
- 예를 들어 간단하게 아래의 IP를 갖는 5대의 서버를 앤서블을 통해 같은 설정의 웹서버로 구성할 수 있습니다.
```yaml
[webserver]
11.11.11.11
11.11.11.12
11.11.11.13
11.11.11.14
```
- 그리고 다음과 같이 Ansible playbook을 정의하면 된다.
```yaml
- hosts: webservers
  roles:
  - webserver
```

```bash
# Terminal
ansible-playbook playbook.yaml
```
- 이렇게 앤서블을 수행하게 되면 5대의 서버에 병렬로 수행되며, 무중단 서비스를 위해 롤링(rolling) 배포로 순차적으로 적용하고자 할 때 serial 이라는 변수를 플레이북에 정의하면 된다.
- 예를 들어, serial 값을 2로 설정한다면, 앤서블은 한 번에 서버 2대에 작업을 수행한다는 의미다.
- 애드 혹 스크립트에서 이러한 작업ㅇ르 수행하다고 하면 수십, 수백 줄의 추가 코드가 들어가야한다.
- 

### 서버 템플릿 도구
- 구성 관리 도구라고 말할 수 있는 것은 Docker, Packer Vagrant 등의 서버 템플릿 도구이다.
- 많은 서버를 배포하고 같은 코드를 서버마다 같은 설정으로 동일하게 수행하는 것이 아니라,
- 소프트웨어와 수행 시에 필요한 설정과 의존성이 있는 프로그램들을 포함한 특정 시점에 운영 체제와 함께 스탭샷 하여 템플릿 이미지화 하는 것이다.
- 아래처럼 특정 IaC 도구를 통해 서버에 템플릿 이미지를 배포하고 서비스를 구성할 수 있다.
![Pasted-image-20230412183307.png](/img/이미지 창고/Pasted-image-20230412183307.png)

#### 가상 머신
:::info 하드웨어 레벨의 연관 관계를 포함한 시스템의 정보를 이미지화 할 수 있다.
- VMware, VirtualBox 또는 Parallels 같은 Hypervisor를 통해 CPU, 메모리, 물리 디스크와 네트워크를 가상화 할 수 있다.
:::

##### 장점
- Hypervisor가 구성된 환경이라면 개발 준비, 사용 환경의 어느 곳에서라도 동일한 배포, 수행을 할 수 있을 뿐만 아니라
- 가상 머신을 다른 리소스와 독립적으로 분리하여 운영할 수 있다.
##### 단점
- 하드웨어 위의 가상화 계층에서 서로 격리된 공간을 할당해야한다.
	- CPU와 메모리의 오버헤드를 일으킬 수 밖에 없고, 가상 머신이 준비되고 배포할 때 걸리는 시간의 부담이 있다.


#### 컨테이너
:::info 운영 체제의 사용자 영역만 에뮬레이트 한다.
- 만약, docker나 코어OS 가 제공하는 rkt를 사용한다면, 독립된 프로세스, 메모리, 네트워크와 마운트 정보들을 묶음으로 만들 수 있다.

:::

##### 장점
- 어느 환경이든 컨테이너 엔진만 있다면 별도의 사용자 공간을 가질 수 있다.
- 어느 곳이든 같은 형태대로 서비스를 유지할 수 있다.
- 가상 머신과 같이 운영 체제 영역을 함께 가상화 하는 것이 아니므로, 오버헤드가 적고 가볍다.

##### 단점
- 운영 체제 커널과 물리적인 영역을 함께 공유 해야하므로 보안상 더 취약 할 수 밖에 없다.

다음은 실제로 패커로 웹 서버용 아마존 머신 이미지(AMI)를 제작하는 `web-server.json` 설정 파일입니다.
```json
{
	"builders":[{
		"ami_name": "packer-example",
		"instance_type": "t2.micro",
		"region": "us-east-1",
		"type": "amazon-ebs",
		"source_ami": "ami-40d28157",
		"ssh_username": "ubuntu"
	}],
	"provisioners":[{
		"type": "shell",
		"inline": [
			"sudo apt-get update",
			"sudo apt-get install -y php",
			"sudo apt-get install apache2",
			"sudo git clone https://github.com/bricks98/php-app.git /var/www/html/app"
		
		]
	}]
}
```
- 패커를 통해 앞으러 언급한 setup-webserver.sh와 같은 역할을 하는 템플릿 설정이다.
- 한가지 다른 점이 있다면 패커 설정에서는 아파치 서버를 시작하지 않는다.
- 일바적으로 서버 템플릿으로 이미지화 한다는 것은 소프트웨어 설치까지의 단계를 담당함을 의미한다.
- 또한, 소프트웨어의 실행은 이미지를 통해 서버를 시작하는 단계에서 수행하도록 설정함을 의미한다.

# 코드형 인프라의 장점
## 셀프 서비스
- 조직 대부분은 코드를 수동으로 배포하고 소프트웨어 배포와 상용 환경에서 실제 작업을 수행하는 서비스 운영 담당자는 적은 인원이다.
- 이러한 구조가 회사가 성잘 할 때 가장 큰 병목 현상이 된다.
- 만일 코드 형태로 관리하고 배포 절차를 자동화 하면 개발자가 원하는 시점에 배포 할 수 있다.

## 속도와 안정성
- 만일 배포 절차가 자동화 된다면, 운영자가 수동으로 배포하지 않고 컴퓨팅 리소스가 신속하게 배포하므로 속도와 안정성이 눈에 띄게 향상될 것이다.
- 자동화된 프로세스는 더욱 일관성 있게 반복할 수 있으며, 수동 오류를 줄일 수 있다.

## 문서화
- 인프라 상태 정보가 시스템 관리자의 머리속에만 저장된 것이 아닌 누구나 읽을 수 있고, 볼 수 있다면, 코드형 인프라 자체가 문서로 만들어진 형태라 할 수 있다.
- 시스템 관리자가 휴가를 가더라도 모든 사람과 조직이 어떻게 동작하는지 알 수 있다.

## 버전 관리
- 코드형 인프라 파이 ㄹ역시 버전 관리를 할 수 있다.
- 이 말은 인프라의 변경 사항과 커밋 로글 등을 남길 수 있다는 의미다.
- 변경 사항에 이력을 남길 수 있다는 것은 추후 문제가 발생하였을 때, 어떤 부분이 변경 혹은 적용 되었는지 알 수 있고, 이전 정보로 되돌려 문제 현상을 빠르게 복구 할 수 있다는 것이다.

## 확인 및 검사
- 인프라 상태를 코드 형태로 관리하여 변경되는 모든 것을 코드로 남긴다면 인팔의 변경 사항 역시 코드 리뷰 할 수 있으며, 자동화된 형태로 유효성 검사를 할 수 있다.
- 또한 분석 도구를 통해 코드의 적용 가능 유무를 확인 할 수 있다. 이러한 자동화된 확인 방식 및 검사 단계를 통해서 결함 가능성을 크게 낮출 수 있다.

## 재사용성
- 인프를 코드화하여 모듈화 할 수 있다면, 모든 배포 단계와 환경에서 처음부터 필요 없이 공통된 사항들을 재사용할 수 있다. 검증된 것, 문서로 만드러진 것을 활용하여 서비스에 맞게 구성한다.

### 운영 관리의 편안함과 행복
- 운영의 효율화와 편안함이 코드형 인프라 도입에 가장 중요하다. 


# 테라폼의 동작 방식
- 테라폼은 Go언어로 프로그래밍 되어 있는 오픈 소스 도구이다.
- Go 코드는 하나의 바이너리로 컴파일 되어있죠 terraform 이라는 명령어로 수행할 수 있습니다.
- 이 바이너리 파일은 빌드 서버 뿐만 아니라 데스크톱, 노트북 등 어느 호나경에서도 사용 할 수 이 있으며, 다른 추가 리소스는 필요하지 않다.
- 테라폼 바이너리를 통해 코드에 정의된 AWS, Azure, GCP와 같은 공급자가 제공한 API를 통해 호출을 만든다.
- 이 뜻은 테라폼 공급자가 제공하는 API 서버 리소스를 활용함을 의미하며, 추가 인프라에 대해서 고민할 필요가 없다.

- 어떻게 테라폼이 API 호출을 만드는 것인지는 다음의 예처럼 테라폼 설정 값을 통해서 확인 할 수 있다.
- 이 설정 파일이 만들고자 하는 인프라에 대한 정보를 포함한 문서이며, 코드형 인트라를 만들어주는 방법입니다.
```terraform
resource "aws_instance" "example"{
	ami           = "ami-40d28157"
	instance_type = "t2.mirco"
}

resource "dnsimple_record" "example"{
	domain = "example.com"
	name   = "test"
	value  = "${aws_instance.example.public_ip}"
	type   = "A"
}
```
- 테라폼을 통해 AWS에 API 호출을 하여 서버를 배포한 다음. DNSimple API를 통해 해당 서버 IP를 example.com 도메인의 DNS A 레코드로 추가한다.
- 문법이 쉽고 간단한 테라폼 코드를 사용하여, 여러 클라우드 공급자 간에 상호 연결된 리소스를 배포할 수 있다.

- 서버, 데이터베이스, 네트워크 장비와 형상(toploogy)을 포함한 모든 인파를 코드 형태로 괸리 할 수 있으며, 설정 정보에 대한 파일을 버전 관리할 수 있다.
- 또한, 테라폼 명령어를 수행하여, 인프라를 배포할 수 있다.
- 테라폼 바이너리는 클라우드 공급자 API에 맞도록 코드를 변환해서 수행하며, 사용자를 대신하여 최대한 효과적으로 API 호출이 이루어지도록 한다.

- 팀 구성원이 인프라 변경이 필요하다고 하면, 수동으로 리소스를 변경하는 것이 아니라 테라폼 설정을 변경하고 코드 리뷰를 업데이트 한다
- 그 후 `terraform apply` 명령을 통해 테라폼이 변경된 사항에 맞춰서 API를 변환, 수행 할 수 있도록 한다.
![Pasted-image-20230420132832.png](/img/이미지 창고/Pasted-image-20230420132832.png)
:::note 클라우드 공급자 간의 투명한 호환성
- 테라폼이 여러 클루아드 공급자를 지원하면서 공급자 간에 호환할 수 있는 지가 주요 화두로 떠올랐다.
- 테라폼으로 AWS에 구성된 수십 대의 서버, DB, 네트워크 장비들을 몇번의 클릭으로 Azure, GCP에 같이 배포가 가능할까?
- 현실적으로 다른 클라우드 공급자는 같은 환경에 있지 않으며, 같은 서비스의 기능, 설정, 관리 방법, 보안, 확장성, 가용성 등이 제공되지 않는다.
- 클라우드 공급자가 100% 같은 기능을 제공하지 않는 한 완벽한 호환은 가능하지 않는다.
- 테라폼의 접근 방법은 공급자 별로 코드를 작성할 수 있게 하고 공급자 별로 독립적인 기능들을 사용하게 하며, 같은 도구와 언어로 모든 공급자를 제어하는 것이다.

:::

# 테라폼이 다른 코드형 인프라 도구와 다른 점은 무엇인가?
- 코드형 인프라 도구들은 매우 다양하고 훌륭하지만, 요구사항에 맞게 도구를 선택하는 일은 쉽지 않습니다. 
- 많은 IaC 도구들은 기능들이 겹치며, 오픈 소스이고 상용 환경을 지원한다. 각 도구를 사용해 보지 않았다면, 어떤 것을 골라야 하는지 기준이 명확하지 않을 것이다.
- 선택하는 작업이 특히 더 어려운 이유는 모든 도구는 목적이 비슷해 보이고, 어떤 것을 사용하더라도 비슷한 결과를 낼 것 같기 때문이다.
- 사실 기술적으로는 맞지만, 도움이 되지 않는 경우도 있다.

- 예를 들면, 프로그래밍 초보에자에 PHP, C 또는 어셈블리로 웹사이트를 성공적으로 구축할 수 있다고 말하는 것과 비슷하며,
- 좋은 결정을 내리는데에 많은 필수적인 부분을 생략한 것이다.
- 이번에는 테라폼, 셰프, 앤서블, 솔트트랙, 클라우드포메이션, 오픈스택 히트 처럼 잘 알려진 구성 관리, 배포 도구에 대해서 깊이 있게 비교할 것이다.
- 또한, 테라폼이 왜 Gruntworks에 좋은 선택이 되었으며, 어떤 의미로 이 책을 쓰게 되었는지 설명해준다.
:::tip 주요 비교 사항
- 구성 관리 vs 배포 도구
- 가변적인 인프라 vs 변하지 않는 인프라
- 절차적 언어 vs 선언형 언어
- 마스터 유무
- 에이전트 유무
- 커뮤니티 규모
- 성숙한 기술 vs 신규 기술

:::

## 구성 관리 vs 배포 도구
- 구선 관리 도구 역시 기본적인 리소스 프로비전을 제공하므로 경계선을 정확하게 나누기는 어렵다.
- 그리고 프로비전 도구 역시 서버 생성 시에 설정 및 초기화 스크립트를 통해서 구성 관리 정보를 수집, 설정 할 수 있다.
- 이런 다양한 도구들의 목적이 비슷한 만큼 서비스 사용 사례에 가장 적합한 도구를 선택해야한다.

- 특히 도커와 패커와 같은 서버 템플릿 도구를 사용하고 있다면 이미 구성관리가 적용된 형태라고 볼 수 있다.
- Dockerfile 혹은 패커 템플릿 이미지를 가지고 있다면, 그 이미지를 동작시키기 위한 인프라가 필요하다.
- 이와 같은 상황에서는 서버 프로비전 도구가 가장 효과적인 선택이며, 서버 템블릿 도구를 사용하지 않는다면, 설정 관리 도구와 프로비전도구를 함께 사용하는 것이 최적의 선택이다.
- 예를 들어, 테라폼으로 인프라 리소스를 배포하고 셰프로 설정 관리를 수행하여 소프트웨어를 설치한다.

## 가변적 인프라 vs 변하지 않는 인프라
- 셰프, 퍼핏, 앤서블, 솔트스택 등의 구성 관리 도구는 가변적인 인프라 패러다임을 기본 원칙으로 한다.
- 예를 들어, 셰프를 통해 OpenSSL의 새로운 버전을 설치한다고 하였을 때, 셰프는 기존 서버에 업데이트를 수행할수록 서버는 각각 독립적인 변경 이력을 가진다.
- 결과적으로, 각 서버는 다른 서버들과 달라지고 진단 및 복구가 어려운 구성 결함이 발생한다.
- 수동으로 극복 할 수 있지만, 구성 관리 도구 역시 이러한 문제점을 100% 해결 할 수 없다.
- 자동화된 테스트 방안이 있더라도 서버가 미묘하게 구성이 변경된 사항은 파악하기 어려우며, 테스트한 환경과 상용 환경이 정확히 같지 않으므로, 상용 환경 서버에서는 다른 문제가 발 생할 수 있다.

- 만약 도커와 패커의 이미지를 배포하기 위해 테라폼과 같은 서버 배포 도구를 사용한다면, 모든 변경 사항을 새롭게 생성된 서버에서 배포해야 한다.
- 예를 들어, 새로우 OpenSSL 버전을 적용한다면, 패커를 통해 새로운 OpenSSL이 설치된 이미지를 생성한다
- 그리고 새로운 서버로 배포하고 예전 버전의 서버들 리소스는 회수하는 형태다.
- 모든 설정 변경에 대해 새로운 서버로 같이 배포되므로 모든 리소스가 같은 형태의 설정을 하게 되어 구성 결함을 최소화 할 수 있다.
- 그 뿐만 아니라 각 서버에는 모두 같은 소프트웨어가 동작하므로 더욱더 쉽게 운영 할 수 있으며, 복구 역시 설정 복원이 아닌 이전 이미지로 빠르게 복구가 가능하다.
- 이미지는 변하지 않으므로 자동화된 테스트를 통해 검증된 이미지라면 개발 환경과 상용 환경에 같이 배포 할 수 있다.

- 물론 구성 관리 도루로도 변경 사항을 변하지 않는 형태로 구성할 수도 있으나, 이것은 그 도구의 목적에 부합하지 않는다. 불변의 접근 방법 역시 자체적인 단점이 존재한다.
- 예를 들어, 서버 템플릿을 통해 새로 이미지를 만들고 이전 서버의 모든 변경사항을 다시 다 적용하는데 시간이 오래 걸릴 수 밖에 없다.

## 절차적 언어 vs 선언적 언어
- 셰프와 앤서블을 원하는 최종 상태를 만들기 위해서는 매 단계별로 코드를 작성하는 것과 같은 절차적인 스티일을 권장한다.
- 테라폼, 클라우드포메이션, 솔트 스택, 퍼핏, 오픈스택 히트는 코드를 선언형으로 작성하도록 권장하며, 최종으로 원하는 형태만 선언하게 되고, IaC도구가 해당 형태를 만들기 위한 상태를 관리하는 역할을 한다.
- 다음은 절차적으로 접근을 하는 <mark>앤서블</mark>을 통해 AMI ID가 ami-40d28157인 우분투 이비지로 10대 서버를 배포하는 예제입니다.
```yaml
- ec2:
	count: 10
	image: ami-40d28157
	instance_type: t2.micro
```
- 그리고 동일한 기능을 하는 선언형 방식의 <mark>테라폼</mark> 설정입니다.
```terraform
resource "aws_instance" "example"{
	count         = 10
	ami           = "ami-40d28157"
	instance_type = "t2.micro"
}
```
- 앤서블 혹은 테라폼을 통해 초기 작업을 수행할 때는 겉으로는 두 설정이 비슷해 보여 같은 결괏값을 얻을 수 있다.
- 하지만, 변경사항이 생길 때는 두 방식의 차이점을 파악 할 수 있다.

- 예를 들어, 서비스 사용량이 늘어나 서버를 15대로 늘려야 한다면, 앤서블의 이전 코드는 더는 유효하지 않다.
- 만약 그 코드의 서버를 15대로 늘린다고 하면, 15대의 새로운 서버가 생성되며 총 25대의 서버가 생성된다.
- 그래서 최종 수량이 아닌 추가되는 수량 만큰 코드에 업데이트 해야한다.
```yaml
- ec2:
	count: 5
	image: ami-40d28157
	instance_type: t2.micro
```

- 선언형 코드에는 원하는 최종 상태의 정보만 정의하면 되고, 테라폼이 현재 상태의 정보와 비교하여 최종 상태를 적용한다.
- 테라폼은 이전의 정보 상태를 알고 있으므로 최종적인 서버 대수만 고려하면 된다.
- 즉, 이전에 사용했던 테라폼 설정 값을 10에서 15로 늘리면 된다.

```terraform
resource "aws_instance" "example"{
	count           = 15
	ami             = "ami-40d28157"
	instance_type   = "t2.micro"
}
```
- 만약에 새로운 버전의 애플리케이션이 포함된 AMI ID가 ami-408c7f28로 바뀌게 되면 어떤 일이 발생할지 예상되는가?
- 절차 지향적 접근 방식을 사용하면 이전에 사용했던 앤서블 템플릿은 더는 유효하지 않으므로, 이미 배포된 10대의 서버를 추적하고 다시 새로운 버전의 템플릿을 작성해야 한다.
- 하지만 테라폼의 선언형 접근 방식에서는 이전과 같은 설정 값을 활용하여 ami 변수에 ami-408c7f28만 변경하면 된다.
```terraform
resource "aws_instance" "exmaple"{
	count         = 15
	ami           = "ami-408c7f28"
	instance_type = "t2.micro"
}
```
- 예제에서 확인 할 수 있듯이 매우 간단하게 사용이 된다. 앤서블은 태그를 사용하여 새 EC2 인스턴스를 배포하기 전에 기존의 인스턴스를 확인 할 수 있다.
- 하지만 모든 리소스에 대해 수동으로 이전 이력들의 기준을 토대로 관리하는 것은 매우 복잡한 일이다.

- ---

:::note 절차적인 코드들은 인프라의 모든 상태를 저장하기 어렵다.
:::

- 앞의 세 가지 앤서블 템플릿을 보고 읽는 것으로는 배포 내용을 확인하기 어렵다.
- 따라서, 템플릿이 적용된 순서 정보 역시 알고 있어야 한다. 
- 만약 적용 순서가 다르다면 다른 인프라가 될 가능성이 높다.
- 이것은 코드 기반 자체에서 확인하기 어려운 일이며, 다른 말로 하면 앤서블 혹은 셰프의 코드와 지금까지 변경된 모든 이력을 함께 알아야한다.
- 또한, 절차적인 코드는 재사용이 불가능하며, 코드의 재사용은 본질적으로 현재 인프라 상태를 고려해야 하므로 제한이 된다.
- 상태가 계속 변경되므로 일주일 전에 사용한 코드들은 이전의 인프라 역시 더는 존재하지 않으므로, 다시 사용하기는 어려워진다.
- 결과적으로 절차 기반 코드는 시간이 지남에 따라 무겁고 복잡해지는 경향이 있다.

:::note 테라폼의 선언형 접근방법을 통하여 코드는 항상 최신의 인프라 상태를 나타낸다.
:::

- 요야갛면 히스토리 및 타이밍을 걱정할 필요 없이 현재 배포된 내용과 구성 내역을 알 수 있다.
- 이 것은 수동으로 현재 상태를 설명할 필요가 없으므로 코드를 재사용하기 쉬워진다.
- 만들고자 하는 상태를 설명하는 것에 집중하고, 테라폼은 자동으로 한 상태에서 다른 상태로 전화하는 방법을 보여준다.
- 결과적으로 테라폼의 코드를 간단하고 이해하기 쉽게 구성할 수 있다

----
- 물론, 선언적 언어에도 단점은 존재한다.
- 전체 프로그램 언어를 이해하지 못하면 표현이 매우 제한된다.
- 예를 들어, 무중단 배포와 같은 일부 유형의 인프라 변경은 단순히 선언적 용어로 표현하기 어렵다.
- 또한, 절차형 언어와 비슷하게 논리적인 구성을 수행할 수 없다.
- 그리고 일반적으로 생성해야 하며, 재사용 가능한 코드는 까다로울 수 있다. 또한, 조건문이나 반복문과 같은 논리적인 구성을 구생할 수 없어 나열하는 형태로 코드가 작성되며, 재사용이 까다롭다.
- 하지만, 테라폼은 몇 가지 강력한 기본 구성을 제공한다.
- 예를 들어, 변수 입력, 출력, 모듈화, 생성하기 전에 삭제, 숫자 반복, 다양한 구문들, 채움 참조 함수들을 제공한다.
- 이것을 통해 더욱더 깔끕하게 설정할 수 있으며, 선언형 언어에서도 모듈식 코드를 구현 할 수 있다.

## 마스터 유무
- 기본적으로 셰프, 퍼핏, 솔트스택 모두 마스터 서버가 필요하며, 인프라의 정보와 배포할 업데이트를 지정하고 있다.
- 인프라를 변경할 때 명령어, 클라이언트를 통해 마스터의 정보를 갱신하고 마스터 서버는 다른 서버에 업데이트를 전송하거나 각 서버가 마스터로부터 최신의 업데이트를 내려받아서 수행한다
- 마스터 서버의 존재는 몇가지 장점을 제공한다
	- 첫째는 인프라의 상태를 중앙 한 곳에서 관리하고 확인 할 수 있다.
	- 또한, 많은 구성 관리도구는 웹 인터페이스를 제공하여 작업 진행 내역을 손쉽게 확인 할 수 있다.
	- 예를 들어, 누군가가 수동으로 서버의 설정 정보를 변경한다면, 마스터에서 승인되지 않은 변경사항에 대해 다시 복구 시킬 수 있다.
	- 하지만 마스터의 존재로 인한 단점들이 존재한다.
- **추가적인 리소스**
	- 마스터 시스템을 위해 추가 리소스를 구성해야하며, 가용성, 확장성을 위해 필요에 따라 클러스터까지 준비해야한다.
- **운영** 
	- 마스터 서버 자체도 중요한 시스템이므로 관리, 운영, 가용성, 확장성을 위해 필요에 따라 클러스터까지 구성해야한다.
- **보안**
	- 마스터 서버와 모든 클라이언트 간에 통신 할 수 있도록 네트워크 연결을 열어놓아야 하며, 연결을 위한 특정 포트나 권한을 고려해야한다.
	- 모든 서버와 연동되는 단일 통신 채널에 대한 보안도 강화해야한다.
- 셰프, 퍼핏, 솔트스택은 각 서버에서 에이전트 소프트웨어만 마스터 없이 수행하는 형태도 지원한다.
- 통상적으로 특정 주기로 스케줄러 혹은 리눅스 크론잡을 걸어서 마스터 서버가 아닌 버전 관리 서버에서 최신의 정보를 받아와 수행 할 수도 있다.
- 이렇게 설정 단계를 최소화 할 수 있지만, 다음 절에서 설명할 서버를 배포하고 에이전트 소프트웨어를 설치하는 방법과 관련해 여러가지 해결되지 않는 질문이 남아있다.

- 앤서블, 클라우드포메이션, 히트, 테라폼은 전부 마스터 없이 수행하는 것을 기본으로 한다.
- 또는, 적확성을 위해 마스터 서버를 사용한다. 
- 하지만, 이것은 이미 사용되고 있는 리소스의 일부이고, 관리를 위해 추가할 필요는 없다.
- 예를 들어, 테라폼은 클라우드 공급자 API를 통해 통신하므로, API 서버가 마스터 서버가 되고 추가적인 인증 메커니즘이 필요하더라도 별도의 마스터 서버는 필요하지 않고 받은 API 키를 사용하면 된다.
- 앤서블은 SSH를 통해 직접 서버와 통신한다.
- 이것이 역시 별도의 인증을 위한 인프라는 추가 되지 않는다.

## 에이전트 유무
- 셰프, 퍼핏, 솔트트팩 모두 다 설정을 하고자 하는 각 서버에 에이전트 소프트웨어가 필요하다
- 각 에이전트는 일반적으로 각 서버 백그라운드로 수행 되며, 최신의 설정 관리 업데이트를 담당한다. 하지만 몇가지 단점이 있다.

### 부트 스트랩핑
- 서버를 프로비전하고 어떻게 소프트웨어를 설치하는가?
- 일부 구성 관리 도구는 일부 외부 프로세스가 처리할 것으로 가정하여 진행한다.
- 다른 구성 관리 도구 는 특별한 부트스트랩핑 프로세스를 제공하며, 일회용 명령을 실행하여 클라우드 공급자 API를 사용하여 서버를 프로비전하고 SSH를 통해 해당 서버에 에이전트 소프트웨어를 설치한다.

### 유지 관리
- 에이전트 소프트웨어는 주의 깊게 정기적으로 업데이트해야 하며, 마스터 서버와의 동기화를 신중하게 유지해야 한다.
- 에이전트 소프트웨어가 재 시작되거나 문제가 발생했을 때 모니터링 할 수 있어야한다.

### 보안
- 에이전트 소프트웨어는 마스터 서버로부터 설정을 내려받아야 하며, 모든 서버가 외부와 통신 할 수 있도록 열어두어야 한다.
- 만약 마스터 서버가 에이전트로 설정 값을 전달한다는 방식이라면 모든 서버에서 마스터 서버로부터의 접근을 허용하도록 포트를 열어 주어야 한다
- 두 방식 다 에이전트와 서버가 간 통신을 위해 인증을 어떻게 받아야할지 고려해야 한다.
- 이 모든 것이 외부 공격자의 공격 대상이 될 수 있다.

## 커뮤니티 규모
- 최신 기술을 선택한다면, 커뮤니티의 규모도 중요하다.
- 많은 경우 프로젝트의 생태계가 기술 자체의 고유한 품질보다 더 큰 경험을 할 수 있도록 해 준다.
- 커뮤니티는 얼마나 많은 사람이 프로젝트에 기여하며, 얼마나 많은 플러그인을 제공하고, 연동하고, 확장 기술을 지원 할 것인지를 결정한다.
- 이를 통해 다양한 도움을 받을 수 있고, 요청할 수 있으며, 회사 프로젝트에 기여할 인력도 찾을 수 있다.


---

#IaC #Terraform 

---