---
slug: "Container-오케스트레이션"
---
대량의 트래픽을 처리하고 고 가용성을 얻기 위해 여러대의 Docker Host로 구성된 운영 환경에서 애플리케이션을 실행하는 방법을 알아볼 차례입니다.
운영 환경에서도 여전히 애플리케이션은 컨테이너에서 실행되지만, 여러 대의 docker host와 컨테이너를 관리해주는 관리 layer가 한 층 추가 됩니다.
이 관리 layer를 오케스트레이션 이라고 하며, 주요 오케스트레이션 도구로는 docker swarm / kubernetes가 있습니다.
이 두가지 도구 도구는 기능 면에서 겹치는 부분이 많지만, 이 중 쿠버네티스는 별도의 책으로 다뤄야 할 정도로 더 복잡한 도구 입니다.


# Container 오케스트레이션 도구란?
docker compose는 단일 docker 호스트에서 컨테이너를 실행하기 위한 도구 였다.
하지만, 운영환경은 단일 호스트만 구성되지 않는다.
단일 호스트 환경에서는 호스트 한 대만 고장을 일으켜도 전체 애플리케이션이 중단된다.
서비스 운영을 위한 시스템은 고가용성을 요구하는데 이 때문에 오케스트레이션이 필요해진다.

오케스트레이션 도구란 기본적으로 클러스터를 구성하는 여러 대의 호스트 컴퓨터를 의미한다.
오케스트레이션 도구는 컨테이너를 관리하고, 서비스를 제공하기 위한 작업을 여러 컴퓨터로 분배하며, 네트워크 트래픽 부하를 분산시키고 상태가 불량한 컨테이너를 새 컨테이너로 교체하는 일을 담당한다.

여러 대의 호스트 docker를 설치해 클러스터를 만들고 나면, 이들 컴퓨터를 오케스트레이션 플랫폼에 등록한다.
그 다음부터는 명령행 도구나 웹 UI를 통해 원격에서 클러스터를 관리 할 수 있습니다.
![Pasted-image-20240115095525.png](/img/이미지 창고/Pasted-image-20240115095525.png)
오케스트레이션 도구에는 컨테이너의 잠재력을 한층 더 살릴 수 있는 기능이 있다.
클러스터에는 클러스터에 배포된 애플리케이션에 대한 모든 정보가 담긴 분산 데이터 베이스와 어떤 컨테이너를 어떤 호스트에 실행할지 배정하는 스케줄러, 클러스터를 구성하는 호스트 간에 주기적으로 연락 신호를 주고 받는 시스템이 있는데, 이들 시스템은 클러스터의 신뢰성을 확보하는 기본적인 수단이 된다.

클러스터에 애플리케이션을 배포하려면 클러스터에 yaml 파일을 전달하면 된다.
그러면 클러스터에 애플리케이션 구성 정보를 저장하고 그에 맞춰 동원 가능한 서버에서 컨테이너를 생성해 애플리케이션을 실행한다.
애플리케이션이 실행되면 클러스터는 애플리케이션의 실행 상태가 유지되도록 관리한다.
어떤 서버가 고장나면 컨테이너 일부가 손실되겠지만, 클러스터가 다른 서버에서 대체 컨테이너를 실행한다.
복잡한 컨테이너 관리는 모두 오케스트레이션 도구가 대신 해준다.
우리의 YAML에 원하는 애플리케이션의 상태를 작성하기만 하면 되며, 어떤 서버에서 몇 개의 컨테이너를 실행해야 할지는 신경 쓰지 않아도 된다.
게다가 오케스트레이션 도구는 네트워크 관련 기능, 애플리케이션 설정 기능, 데이터 저장 기능도 제공한다.
![Pasted-image-20240115101022.png](/img/이미지 창고/Pasted-image-20240115101022.png)
위를 보면 서버가 나타나 있지 않는다.
오케스트레이션 도구가 각 서버, 네트워크, 스토리지 장치의 세부 사항을 가려주기 때문이다.
우리는 클러스터가 마치 하나의 대상인 것처럼 명령행 도구와 API를 통해 명령을 보내고 쿼리를 요청해 사용한다.
클러스터는 1000대의 호스트 일수도 있고,, 단일 호스트 일 수도 있다.

하지만, 호스트 대수와 상관 없이 똑같은 명령을 사용하고 YAML 파일을 전달해 애플리케이션을 배포한다.
애플리케이션 사용자 엯히 클러스터에 포함된 모든 서버를 사용할 수 있다.
오케스트레이션 계층이 컨테이너까지 이어지는 트래픽 라우팅을 담당한다.

# Docker Swarm으로 클러스터 만들기
:::warning `swarm init` 오류
- 보통은 아무 인자 없이 `swarm init`을 사용해도 되지만,
- host 컴퓨터가 하나 이상의 네트워크에 접속 되어있다면, 스웜 통신에 사용할 IP 주소를 선택하라는 메시지와 함께 오류를 일으킬 것이다.

:::

docker swarm 초기화 되고 현 컴퓨터가 cluster manager가 됐다.
cluster에 속한 컴퓨터는 manager와 worker라는 두 가지 역할 중 하나를 맡는다.
출력된 내용 중에는 다른 컴퓨터를 클러스터에 워커로 참여시키기 위해 입력할 명령어도 있다.

![Pasted-image-20240115103238.png](/img/이미지 창고/Pasted-image-20240115103238.png)

manager는 cluster를 관리하는 작업을 직접 수행한다.
cluster db도 manager 노드에 저장되며, 사용자가 yaml 파일을 전달하기 위해 사용하는 api도 manager node에서 동작하고 컨테이너 모니터링과 스케줄링 모두 manager node가 수행한다.
이와 달리 worker는 매니저의 스케줄링에 따라 컨테이너를 실행하고 그 상태를 주기적으로 manager에 보고하는 역할을 하는데, manager도 worker의 역할을 수행할 수는 있다.

swarm을 만들고 나면 원하는 만큼 컴퓨터를 스웜에 추가할 수 있다.
스웜에 추가된 컴퓨터를 노드라고 부른다.
스웜에 노드를 추가하려면, 먼저 해당 컴퓨터가 스웜과 같은 네트워크 상에 있어야 하고, 스웜에 들어가기 위한 패스워드 역할을 하는 참가 토큰을 manager로 부터 발급 받아야 한다.

manager 노드에 접근 가능하다면, 매니저용 혹은 워크용 참가 토큰을 출력하거나 스웜에 현재 참여 중인 노드의 목록을 볼 수 있다.

```shell
# 워커 노드로 스웜에 참여하기 위한 명령을 화면에 출력
docker swarm join-token worker

# 매니저 노드로 스웜에 참여하기 위한 명령을 화면에 출력
docker swarm join-token manager

# 스웜에 참여중인 노드의 목록을 출력
docker node ls
```
![Pasted-image-20240115104805.png](/img/이미지 창고/Pasted-image-20240115104805.png)

- 위 사진은 노드가 현재 한개 뿐이다.
- 같은 네트워크 상에 있는 어떤 컴퓨터라도 manager node의 ip 주소와 join 명령을 사용하면 스웜에 새로운 노드가 추가가 된다.
![Pasted-image-20240115105635.png](/img/이미지 창고/Pasted-image-20240115105635.png)
docker swarm이 kubernetes보다 나은 점은 중 하나는 클러스터를 구성하고 관리하는 작업이 단순하다는 것입니다.
수십대 정도 규모의 스웜은 각 호스트마다 docker를 설치하고 manager node를 맡을 컴퓨터에서 `docker swarm init` 명령을 한번 실행한 다음,
나머지 노드에서 `docker swarm join` 명령을 실행하는 정도면 만들 수 있다.
운영 환경에서도 더 복잡한 작업은 필요 없다.

## Docker Swarm service로 애플리케이션 실행하기
docker swarm 환경에서는 컨테이너를 직접 실행할 필요가 없다.
서비스를 배포하면 swarm이 대신 컨테이너를 실행해준다.
서비스는 container를 추상화 한 개념이다.
하나의 서비스가 여러 개의 컨테이너로 배포 될 수 있다는 점에서, 스웜이 말하는 서비스는 컴포즈에서 말하는 서비스와 의미가 같다.

서비스는 컨테이너와 같은 정보로 정의 된다.
사용되는 이미지, 환경 변수와 값, 공개 되는 포트와 같은 정보다
여기에 서비스의 이름이 docker 네트워크 상에서 그대로 도메인으로 사용된다는 점도 컨테이너와 같다.
차이점이라면, 서비스는 여러 개의 레플리카


---

#Container 

---