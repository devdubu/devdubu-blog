---
slug: "애플리케이션-소스-코드에서-도커-이미지까지"
---
# Dockerfile 이 있는데 빌드 서버가 필요한 이유
- 한 개발자가 파일 하나 빼먹고 코드를 푸시했다면, 빌드 서버에서 빌드가 실패할 것이다.
- 팀원들도 빌드가 깨졌음을 알 수 있다.
	- 이런 방법으로 프로젝트를 건전하게 유지 할 수 있지만, 이를 위해서는 빌드 서버를 유지하는 비용이 추가로 발생한다.
![Pasted-image-20230607111008.png](/img/이미지 창고/Pasted-image-20230607111008.png)
- 이 과정에는 유지 보수를 위한 큰 오버헤드가 발생한다.
- 신규로 팀에 참여한 개발자는 이 도구를 설치하는데만 출근 첫날을 모두 보내기 일쑤다.
- 또 작업용 컴페터에서 이들 도구 중 하나를 업데이트 하면서 빌드 서버와 버전이 달라지는 것만으로도 빌드가 실패할 수 있다.
- 매니지드 빌드 서비스를 사용하더라도 이러한 무제를 피하기 어려우며, 이로 인해 사용 가능한 도구의 선택 폭이 좁다.

- 이러한 경우에 빌드 툴체인을 한 번에 패키징 해서 공유 할 수 있다면, 편리할 것이다.
- 물론 도커를 사용하면 가능하다.
- 개발에 필요한 모든 도구를 배포하는 Dockerfile 스크립트를 작성한 다음 이를 이미지로 만든다.
- 그리고 애플리케이션 패키징을 위한 Dockerfile 스크립트에서 이 이미지를 사용해 소스 코드를 컴파일함으로써 애플리케이션을 패키징 하는 것이다.

- 새로운 기능이 쓰이므로 먼저 간단한 예제부터 시작하면,
```dockerfile
FROM diamol/base as build-stage
RUN echo 'Building ... ' > /build.txt

FROM diamol/ as test-stage
COPY --from=build-stage /build.txt / build.txt
RUN echo 'Testing...' >> /build.txt

FROM diamol/base
COPY --from=test-stage /build.txt /build.txt
CMD cat /build.txt
```
- 이 스크립트는 빌드가 여러 단계로 나뉘는 멀티 스테이지 빌드를 적용한 것이다.
- 각 빌드 단계는 FROM 인스트럭션으로 시작된다.
- 필요한 경우 빌드 단계에 AS 파라미터를 이용해 이름을 붙일 수도 있다.
- 위의 예제는 세 단계로 나뉜 멀티 스테이지 빌드의 예이다.
- 마지막 한 단계는 이름이 없다.
	- 빌드가 여러 단계로 나위어 있다고는 하지만, 최종 산출물은 마지막 단계의 내용물을 담은 도커 이미지이다.
- 각 빌드 단계는 독립적으로 실행되지만, 앞선 단계에서 만들어진 디렉터리나 파일을 복사할 수 있다.
- 위의 예제 `COPY`인스트럭션을 보면 `--from` 인자를 사용해 해당 파일이 호스트 컴퓨터의 파일 시스템이 아니라 앞선 빌드 단계의 파일 시스템에 있는 파일임을 알려준다.
- 이 예제에서는 build-stage 단계에서 파일 하나를 생성하는데, 이 파일을 test-stage로 복사하고, 다시 test-stage에서 생성한 파일을 마지막 단계로 복사한다.

- `RUN` 인스트럭션은, 여기에서는 파일을 생성하기 위해서 나왔다.
- `RUN` 인스트럭션은 빌드 중에 컨테이너 안에서 명령을 실행한 다음, 그 결과를 이미지 레이어에 저장하는 기능을 한다.
- `RUN` 인스트럭션에서 실행할 수 있는 명령에는 특별한 제한이 없지만, `FROM` 인스트럭션에서 지정한 이미지에서 실행할 수 있는 것이어야 한다.
- 여기서는 `diamol/base`를 기반 이미지로 지정했으며, 이 이미지가 echo 명령을 포함하고 있기 때문에, 이 `RUN` 인스트럭션이 정상적으로 동작한다.
![Pasted-image-20230607161623.png](/img/이미지 창고/Pasted-image-20230607161623.png)
- 각 빌드 단계는 서로 격리돼 있다는 것을 이해해야 한다.
- 빌드 단계 별로 기반 이미지도 다를 수 있으므로, 사용할 수 있는 도구도 달라진다.
- 마지막 빌드 단계의 산출물은 이전 빌드 단계에서 명시적으로 복사해 온 것만 포함할 수 있다.
- 어느 한 단계에서라도 명령이 실패하면 전체 빌드가 실패한다.

- 빌드 명령을 입력하면 Dockerfile 스크립트에 작성된 순서를 따라 빌드가 진행되는 것을 볼 수 있다.
- 간단한 예제이지만, 이 패턴은 훨씬 복잡한 애플리케이션을 하나의 Dockerfile 스크립트로 빌드하는 데도 사용 할 수 있다.
- 아래의 그림은 자바 애플리케이션에 이 워크 플로를 적용한 예이다.
![Pasted-image-20230607164248.png](/img/이미지 창고/Pasted-image-20230607164248.png)
- `build-stage`단계에서는 빌드 도구가 설치된 기반 이미지를 사용한다.
- 로컬 컴퓨터에서 소스코드를 복사해 넣고, `build` 명령을 실행한다.
- 그리고 단위 테스트 프레임워크가 설치된 기반 이미지를 사용하며, 앞서 빌드한 바이너리를 복사해간 다음 단위 테스트를 수행하는 `test-stage` 단계를 추가할 수 있다.
- 마지막 단계는 애플리케이션을 실행할 런타임이 들어 있는 기반 이미지로 시작한다.
- 그리고 build-stage에서 빌드하고 test-stage에서 테스트까지 성공적으로 마친 바이너리를 이 이미지에 복사해 넣는다.
![Pasted-image-20230607164557.png](/img/이미지 창고/Pasted-image-20230607164557.png)
- 이런 방법으로 애플리케이션의 진정한 이식성을 확보할 수 있다.
- 딱 한가지, 도커만 갖춰진다면, 컨테이너를 통해 어떤 환경에서든 애플리케이션을 빌드하거나 실행 할 수 있다.
- 빌드 서버에도 도커만 설치돼 있으면 된다.
- 새로 팀에 합류한 개발자도 즉시 개발 환경을 갖출 수 있으며, 빌드 도구를 도커 이미지를 통해 중앙 집중적으로 관리할 수 있다.
- 팀 공통의 설정에서 벗어날 가능성 자체가 원천적으로 차단 된다.
- 거의 모든 주요 애플리케이션 프레임워크는 이미 도커 허브를 통해 빌드 도구가 내장된 공식 이미지를 제공한다.
- 런타임만 제공되는 이미지를 별도로 제공하는 경우도 있다.
- 이들 이미지를 직접 활용하거나 이들을 포함하는 이미지를 새로 만들어 사용하면 된다.
- 이렇게 하면 프레임워크 개발 팀 유지보수하는 최신 업데이트를 바로바로 적용할 수 있다는 장점이 있다.
- 



# 애플리케이션 빌드 실전 예제 : Java
- 실제 애플리케이션 예제로 살펴 보겠습니다.
- Java Spring Boot를 사용해 구현한 것으로, 앞으로 도커를 이용해 이 애플리케이션을 빌드하고 실행하는 과정을 체험할 것이다.
- 이 애플리케이션을 빌드하고 실행하기 위해 자바 도구를 따로 설치할 필요는 없다.
- 필요한 도구는 모두 도커 이미지를 통해 가져온다.

- 애플리케이션의 소스 코드는 이 책에서 제공하는 소스 코드 중 ch04/exercise/iamge-of-the-day 에서 볼 수 있다.
- 이 애플리케이션은 표준적인 자바 빌드 도구인 maven과 OpenJDK 를 사용한다.
- Maven은 빌드 절차와 의존 모듈의 입수 방법을 정의하는 도구이고, OpenJDK는 자유로이 재배포가 가능한 자바 런타임이자, 개발자 키트다.
- Maven은 빌드 절차가 정의된 XML 문서를 사용하며, mvn 명령을 실행해 사용한다.

```dockerfile
FROM diamol/maven AS builder

WORKDIR /usr/src/iotd
COPY pom.xml
RUN mvn -B dependancey:go-offline

COPY . .
RUN mvn package

# app
FROM diamol/openjdk

WORKDIR /app
COPY --from=builder /usr/src/iotd-service-0.1.0.jar .

EXPOSE 80
ENTRYPOINT ["java", "-jar", "/app/iotd-service-0.1.0.jar"]
```
- 첫번째 단계인 builder 단계에서 하는 일은 다음과 같다.
- 기반 이미지는 diamol/maven 이다.
	- 이 이미지는 메이븐과 OpenJDK를 포함한다.
- builder 단계는 먼저 이미지에 작업 디렉터리를 만든 다음 이 디렉터리에 pom.xml 파일을 복사하면서 시작된다.
	- 이 파일에는 메이븐에서 수행할 빌드 절차가 정의돼 있다.
- 첫번째 `RUN` 인스트럭션에서 메이븐이 실행돼 필요한 의존 모듈을 내려받는다. 이 과정에는 상당한 시간이 걸리기 때문에, 별도의 단계로 분리해 레이어 캐시를 활용할 수 있도록 한다.
	- 새로운 의존 모듈이 추가될 경우, XML 파일이 변경됐을 것 이다. 이 단계가 다시 실행된다.
	- 추가된 의존 모듈이 없다면 이미지 캐시를 재사용한다.
- 그 다음에는 `COPY . .` 인스트럭션을 통해 나머지 소스 코드가 복사된다.
	- 이 인스트럭션은 <mark>도커 빌드가 실행 중인 디렉터리에 포함된 모든 파일과 서브 디렉터리를 현재 이미지 내 작업 디렉터리로 복사하라</mark>는 의미이다.
- builder 단계의 마지막은 `mvn package` 명령을 실행하는 것이다.
	- 이 명령은 애플리케이션을 빌드하고 패키징하라는 의미다.
	- 입력은 자바 소스 코드이며, 출력은 JAR 포맷으로 패키징된 자바 애플리케이션이다.
- builder 단계가 끝나고 나면, 컴파일된 애플리케이션이 해당 단계의 파일 시스템에 만들어진다.
	- 메이븐을 이용한 빌드 과정에(네트워크 문제로 의존 모듈을 받아오지 못했거나 소스 코드에 컴파일 에러가 있는 등의) 문제가 있엇다면, 
	- `RUN` 인스트럭션이 실패하면서 전체 빌드도 실패한다.
- build 단계를 정상적으로 마쳤다면, 다음 과정을 수행하는 마지막 단계를 실행해 애플리케이션 이미지를 생성한다.
	- 기반 이미지는 `diamol/openjdk`이다.
		- 이 이미지는 Java 11 런타임을 포함하지만, Maven은 포함하지 않는다.
	- 이번에도 이미지에 작업 디렉터리를 만든 다음, 여기에 앞서 builder 단계에서 만든 JAR 파일을 복사한다.
		- 이 JAR 파일은 모든 의존 모듈 컴파일된 애플리케이션을 포함하는 단일 파일이다.
		- 그러므로 builder 단계의 파일 시스템에서 이 파일만 가져오면 된다.
		- 애플리케이션은 80번 포트를 주시하는 웹 서버 애플리케이션이다 그러므로, 이 포트를 `EXPOSE` 인스트럭션을 통해 외부로 공개 해야 한다.
	- `ENTRYPOINT` 인스트럭션은 CMD 인스트력션과 같은 기능을 하는 인스트럭션이다.
		- 해당 이미지로 컨테이너가 실행되면, 도커가 이 인스터럭션에 정의된 명령을 실행한다.
		- 이 이미지의 경우 java 명령으로 빌드된 JAR 파일을 실행한다.

:::quote 실습
- 자바 애플리케니션의 소스 코드를 훑어보고 이미지를 빌드하라

:::

```bash
cd ch04/exercise/image-of-the-day
docker image build -t image-of-the-day .
```
- 이 이미지를 빌드하면 메이븐의 출력하는 상당한 양의 로그를 볼 수 있다.
- 그 내용은 의존 모듈을 내려받고 자바 빌드를 실행하는 내용이다.
- 아래의 사진은 현 빌드를 실행한 경과의ㅏ 일부를 발췌한 것이다.
![Pasted-image-20230607172512.png](/img/이미지 창고/Pasted-image-20230607172512.png)
- NSAS의 오늘의 천문 사진 서비스에서 오늘 자 사진을 받아오는 간단한 REST API다.
- 받아온 사진은 캐시해 두었다가 다음에 또 같은 요청이 들어오면 전에 받아온 사진을 다시 보여 준다.

- 이 API는 이번 장에서 실행해 볼 전체 애플리케이션의 한 부분이다.
- 앞 으로 여러 개의 컨테이너를 실행해 이들이 서로 통신하게 할 것이다.
- 컨테이너는 컨테이너가 실행 될 때 부여되는 가상 네트워크 내 가상 IP를 통해 서로 통신한다.
- 이 가상 네트워크 역시 CLI를 통해 관리 할 수 있다.

:::quote 실습
- 컨테이너 간 통신에 사용되는 도커 네트워크를 생성해라

:::

```bash
docker network create net
```
- 이 명령을 실행했을 때 오류 메시지가 출려된다면, nat이라는 이름의 도커 네트워크를 이미 생성했기 때문이다.
- 이 오류 메시지는 무시해도 좋다.
- 그리고 컨테이너를 실행할 때 `--network` 옵션을 사용하면, 새로 만들 컨테이너를 연결할 네트워크를 직접 지정할 수 있다.
- 같은 네트워크 안에 속한 컨테이너 간에는 서로 자유롭게 통신이 가능하다.

:::quote 실습
- 앞서 빌드한 이미지로부터 컨테이너를 실행하되, 80번 포트를 호스트 컴퓨터를 통해 공개하고 nat 네트워크에 컨테이너를 접속하라
:::

```bash
docker container run --name iotd -d -p 800:80 --network nat image-of-the-day
```

- 이제 웹 브라우저에서 http://localhost:800/image 에 접근해보면 NASA에서 제공하는 오늘의 사진에 대한 정보를 json 포맷으로 볼 수 있다.
![Pasted-image-20230608090303.png](/img/이미지 창고/Pasted-image-20230608090303.png)
- 도커만 설치 돼 있다면, 이 애플리케이션을 어디서든 실행할 수 있다는 점이다.
- 소스 코드와 Dockerfile 스크립트만 있으면 된다.
- 최종적으로 생성되는 애플리케이션 이미지에 빌드 도구는 포함되지 않는다는 점이다.
	- image-of-the-day 이미지를 사용해 대화 식 컨테이너를 실행해 보면, 이 이미지에서는 mvn 명령을 사용할 수 없다는 것을 알 수 있다.
	- 애플리케이션 이미지에는 도커 파일에 정의된 빌드 단계 중 마지막 단계의 콘텐츠만이 포함된다.
	- 이전 단계의 콘텐츠 중 포함시키고 싶은 것이 있다면, 최종 단계에서 명시적으로 해당 콘텐츠를 복사 해와야 한다.


# 애플리케이션 빌드 실전 예제 : NodeJS
- 멀티 스테이지 빌드가 적용된 Dockerfile 스크립트를 한 번 더 살펴보겠다.
- 이번에는 NodeJS 애플리케이션을 빌드하는 스크립트 이다.
- 최근에는 조직의 기술 스택이 점점 다양해지는 만큼, 도커를 이용한 서로 다른 빌드 방식을 살펴보는 것이 도움이 된다.
- NodeJS는 자바와는 다른 스크립트 언어이며, 많이 채택되는 기술이다.
- 이 빌드 패턴 역시 파이썬, PHP, 루비 등 여타 스크립트 언어에 그대로 적용 가능하다.

- Java 애플리케이션은 컴파일을 거쳐야하기 때문에, 빌드 단계에서 소스 코드를 복사한 다음 패키징 과정을 통해 JAR파일을 생성했었다.
- JAR 파일은 컴파일 된 애플리케이션을 담은 파일로 이 파일이 다시 최종 애플리케이션 이미지에 복사되며, 소스 코드는 여기에 포함 되지 않는다.
	- 닷넷 코어 역시 마찬가지다.
- 컴파일된 바이너리(DLL) 포맷이다. 그러나 NodeJS는 이와 조금 다르다.
- NodeJS 애플리케이션은 JS로 구현된다.
	- JS는 인터프리티형 언어로 별도 컴파일 절차가 필요 없다.
	- 컨테이너 화 된 NodeJS 애플리케이션을 실행하려면 NodeJS 런타임과 소스코드가 애플리케이션 이미지에 포함 되어야 한다.
- 그렇다고 멀티 스테이지 빌드가 필요하지 않은 것은 아니다.
- 멀티 스테이지 빌드를 통해 의존 모듈 로딩을 최적화 할 수 있다.
	- NodeJS는 npm 이라는 패키지 관리자를 사용해 의존 모듈을 관리한다.

```dockerfile
FROM diamol/node AS builder

WORKDIR /src
COPY src/package.json

# app
FROM diamol/node

EXPOSE 80
CMD ["node", "server.js"]

WORKDIR /app
COPY --from=builder /src/node_modules/ /app/node_modules/
COPY src/ ,
```
- 이 스크립트의 목표 역시 앞서와 마찬가지로, 애플리케이션을 패키징하고, 다른 도구 없이 도커만 설치된 환경에서 애플리케이션을 실행하는 것이다.
- 두 이미지 모두 diamol/node를 기반으로 이미지로 사용한다.
	- 이 이미지는 NodeJS 런타임과 npm 이 설치된 이미지다.
- builder 단계에서 애플리케이션의 의존 모듈이 정의된 package.json 파일을 복사한 다음, `npm install` 명령을 실행해 의존 모듈을 내려받는다.
- 별도의 컴파일이 필요치 않으므로 빌드 과정은 이것이 전부다

- 이 NodeJS 애플리케이션 역시 REST API다. 최종 단계에서 공개할 HTTP 포트와 애플리케이션 시작 명령을 지정한다.
- 최종 단계는 작업 디렉터리를 만들고 호스트 컴퓨터로부터 애플리케이션 아티팩트를 모두 복사해 넣는 것으로 끝난다.
- src 디렉토리는 애플리케이션의 진입점 역할을 하는 server.js 파일을 비롯해 여러 JS 파일을 담고 있다.

- 이번 애플리케이션은 앞서 본 예제와 기술 스택, 패키징 패턴이 모두 다르다.
- 기반 이미지, 빌드 도구, 실행 명령 또한 자바 애플리케이션과는 모두 차이가 있다.
- 하지만, 이러한 차이점에도 불구하고 Dockerfile 스크립트를 통해 똑같은 방식으로 애플리케이션을 빌드하고 실행할 수 있다.
:::quote 실습
- NodeJS 애플리케이션의 소스코드를 훑어보고 이미지를 빌드하라

:::

```bash
cd ch04/exercise/access-log
docker image build -t access-log .
```

- 이번에도 역시 npm이 출력하는 많은 양의 로그를 볼 수 있다.
![Pasted-image-20230608093410.png](/img/이미지 창고/Pasted-image-20230608093410.png)
- 위의 그림은 현재 빌드 하였을 때 출력된 내용을 발췌 한 것이다.
- 내려받은 의존 모듈은 Docker Image Layer 캐시에 저장되므로 의존 모듈 추가 없이 코드만 수정했다면, 그 다음 번 빌드는 지금 보다 매우 빠르게 진행 된다.
- 지금 빌드한 NodeJS 애플리케이션 역시 특별한 점은 없다
- 하지만, 패키징이 잘 끝났는지 확인이 필요하다.
	- 이 애플리케이션은 다른 서비스로부터 호출을 받아 로그를 남기는 REST API다.
	- HTTP POST 엔드포인트를 통해 남길 로그를 접수하며, GET 엔드 포인트를 통해 현재까지 기록된 로그 건수를 알려준다.
	- 

# 애플리케이션 빌드 실전 예제 : Go
- 추후 다

# 멀티 스테이지 Dockerfile 스크립트 이해하기
- 멀티 스테이지 Dockerfile 스크립트의 동작 원리와 컨테이너 안에서 애플리케이션을 빌드하는 것이 왜 유용하한지 설명하겟다.

### 첫번째 장점 : 표준화
- 어떤 운영체제를 사용하던, 로컬 컴퓨터에 어떤 도구를 설치했든지에 관계 없이 모든 빌드 과정은 도커 컨테이너 내부에서 이뤄진다.
- 이들 컨테이너는 모든 도구를 정확한 버전으로 갖추고 있다.
- 이것을 실무에 적용한다면, 신규 개발자의 적응 기간, 빌드 서버의 관리 부담, 개발자 간 도구 버전 차이로 인한 빌드 실패 등을 줄 일 수 있다.

### 두번째 장점 : 성능 향상
- 멀티 스테이지 빌드의 각 단계는 자신만의 캐시를 따로 갖는다.
- 도커는 빌드 중에 각 인스트럭션에 해당하는 레이어 캐시를 찾는다.
- 해당되는 캐시를 찾지 못하면 남은 인스터력션이 모두 실행되지만, 그 범위가 해당 단계 안으로 국한된다.
- 이어지는 다음 단계는 다음 캐시를 재 사용하면서 시작할 수 있다.
- 처음에는 Dockerfile 스크립트를 세심하게 최적화해서 작성한다면, 이후로 캐시 재사용을 통해 90% 이상의 빌드 단계에서 시간을 절약할 수 있다.

### 이미지를 가능한 작게 유지 가능
- Dockerfile 스크립트를 통해 빌드 과정을 세밀하게 조장하며, 최종 산출물인 이미지를 가능한 작게 유지 할 수 있다.
- 어떤 도구든지 그 도구가 사용되는 단계만으로 도구의 포함 여부를 국한 시킬 수 있다. 최종 산출물인 이미지에 불필효한 도구는 빼버릴 수 있는 것이다.
- 이 좋은 예가 curl이다.
	- curl은 인터넷을 통해 필요한 파일을 내려받을 수 있는 중요한 도구이지만, 파일 다운로드를 빌드 초기 단계에 모아놓는다면, 최종 이미지에는 curl을 포함시키지 않아도 된다.
	- 이런 방법으로 이미지 크기를 줄여서 애플리케이션의 시작 시간을 단축 할 수 있다.
	- 애플리케이션의 의존 모듈 자체를 줄여 취약점을 이용한 외부 공격의 가능성도 최대한 차단 할 수 있다.
	- 


---

#Container #Docker 

---