---
slug: "2.모듈-시스템"
---
# 모듈의 필요성
좋은 모듈 시스템은 소프트웨어 엔지니어링의 몇가지 기본적인 필요성을 마주할 때, 도움을 줍니다.

- code base를 나누어 여러 파일로 분할하는 방법을 제시합니다.
	- 이것은 코드를 좀 더 구조적으로 관리 할 수 있게 해주고 각각으로부터 독립적인 기능의 조각들을 개발 및 테스트하는 데에 도움을 주며, 이해하기 쉽게 해줍니다.
- 다른 프로젝트에 코드를 재사용할 수있게 해줍니다.
	- 실제로 모듈은 다른 프로젝트에도 유용하고 일반적인 특성을 구현할 수 있습니다.
	- 모듈로서 기능을 구조화하는 것이 그 기능들이 필요한 다른 프로젝트로 좀더 쉽게 이동시킬 수 있다.
- 은닉성을 제공합니다.
	- 일반적으로 복잡한 구현을 숨긴 채 명료한 책임을 가진 간단한 인터페이스만 노출 시키는 것이 좋은 방식입니다.
	- 대부분의 모듈 시스템은 함수와 클래스 또는 객체와 같이 모듈 사용자가 이용하도록 공개 인터페이스를 노출 시키는 반면, 공개하지 않으려는 코드를 선택적으로 공개되지 않도록 해줍니다.
- 종속성을 관리합니다.
	- 좋은 모듈 시스템은 서드파티를 포함하여, 모듈 개발자로 하여금 기존에 있는 모듈에 의존하여 쉽게 빌드 할 수 있게 해줍니다.
	- 또한 모듈 시스템은 모듈 사용자가 주어진 모듈의 실행에 있어 필요한(일시적 종속성들) 일련의 종속서들을 쉽게 임포트 할 수 있게 해줍니다.

모듈과 모듈 시스템을 구별하는 것은 매우 중요합니다.
모듈 시스템이 문법이며, 우리의 프로젝트 안에서 모듈을 정의하고 사용할 수 있게 해주는 도구인 반면, 모듈은 소프트웨어의 실제 유닛으로 정의할 수 있다.

# JavaScript와 NodeJS 에서의 모듈 시스템
모든 프로그래밍 언어가 내장 모듈 시스템을 가지고 있는 것은 아니며, JavaScript는 오랫동안 이 요소가 결핍되어 왔습니다.
브라우저 관점에서 코드 베이스는 여러 파일로 분할 될 수 있으며, 다른 `<script>` 태그를 사용하여 임포트 될 수 있습니다.

몇 년 간은 이러한 접근이 간단하게 상호 작용하는 웹 사이트를 위한 빌드에는 충분했고, JavaScript 개발자들은 모든 것은 갖추고 있는 모듈 시스템 없이도 관리 상에 별 문제가 없었습니다.

JavaScript 브라우저 애플리케이션이 점점 복잡해지고, jQuery, Backbone, Angular와 같은 프레임 워크가 생태계를 점유해가면서 JavaScript 커뮤니티에는 JavaScript 프로젝트에 효율적으로 사용될 모듈 시스템을 정의 하기 위한 여러가지 시도가 나타나기 시작했습니다.

가장 성공적인 것이 AMD(Asynchronus Module Definition) 입니다.
AMD는 RequireJS에 의해서 대중화 되었고, 후에는 UMD(Universal Module Definition)가 나오게 됩니다.

NodeJS 가 처음 만들어졌을 때, NodeJs 운영 체제의 파일 시스템에 직접적으로 접근하는 JavaScript 를 위한 서버 런타임으로 구상 되었습니다.
그래서 모듈 관리에 있어서 다른 방법을 도입할 수 있는 특별한 기회가 있었습니다.

이때 도입된 방법이란, HTML `<script>`과 URL 을 통한 리소스 접근에 의존하지 않고, 오직 로컬 파일 시스템의 JavaScript 파일들에만 의존하는 것이었습니다.

이 모듈 시스템을 도입하기 위해 NodeJS는 브라우저가 아닌 환경에서 JavaScript 모듈 시스템을 제공할 수 있도록 고안된 CommonJS 의 명세를 구현하게 되었습니다.

CommonJS는 그것의 시작과 함께 NodeJS 에서 주된 모듈 시스템이 되었고, Browserify와 WebPack과 같은 모듈 번들러 덕분에 브라우저 환경에서도 유명세를 가지게 되었습니다.

2015년에 ECMAScript6 (ECMAScript 2015 or ES2015) 의 발표와 함께 표준 모듈 시스템(ESM) 을 위한 공식적인 제안이 나오게 됩니다.
ESM은 JavaScript 많은 혁신을 불러옵니다.
특히, 모듈 관리에 대한 브라우저와 서버의 차이점을 연결하기 위해 노력합니다.

ECMScript 6는 문법과 의미론적 관점에서 ESM을 위한 공식적인 명세만 정의하고 구체적인 구현을 제공하지 않았습니다.
다른 여러 브라우저 회사들과 NodeJS 커뮤니티가 확실한 명세를 구현하는데 몇년이 소요되었습니다.
NodeJS는 버전 13.2 부터 ESM에 대한 안정적인 지원을 합니다.

지금 시점에는 대부분의 프로젝트들이 CommonJS의 관점에서 이야기해 . 볼것이며, 두 번째 부분에서 ESM을 사용해 설명을 진행할 것입니다.
두번째 부분에서는 ESM 사용해 설명을 진행할 것입니다.

## 모듈 시스템과 패턴
앞서 언급했 듯이 모듈은 주요 애플리케이션의 구조화를 위한 부품인 동시에 명시적으로 노출 시키지 않은 모든 함수들과 변수들을 비공개로 유지하여 정보에 대한 은닉성을 강화 시켜주는 주된 장치입니다.
CommonJS를 구체적으로 알아보기 전에 우리가 간단한 모듈 시스템으로 만들어보기 위해 사용할 패턴이자 정보를 감추는 데에 도움을 주는 노출 식 모듈 패턴을 이야기 해보겠습니다.

### 노출식 모듈 패턴
JavaScript의 주요 문제점 중 하나는 네임스페이스가 없다는 것입니다.
모든 Script는 전역 범위에서 실행됩니다.

따라서 내부 애플리케이션 코드나 종속성 라이브러리가 그들의 기능을 노출시키는 동시에 스코프를 오염시킬 수도 있습니다.
이는 매우 위험합니다.

:::warning 전역 범위에 의존하는 것은 매우 위험한 작업입니다.

:::

애플리케이션이 확장됨에 따라 더욱 개별적인 기능 구현에 의존해야하는 상황이 발생합니다.
이러한 문제를 해결하기 위한 보편적인 기법 Reveraling Module pattern 이 라고 하며 다음과 같은 형식을 보입니다.

```js
const myModule = (()=>{
	const privateFoo = ( ) => { }
	const privateBar = [ ]

	const exported = {
		publicFoo: () => { },
		publicBar:  () =>{ },
	}

	return exported
})() // 여기서 괄호가 파싱되면, 함수는 호출 됩니다.

console.log(myModule)
console.log(myModule.privateFoo, myModule,privateBar)
```

이 패턴은 자기 호출 함수를 사용합니다.

이러한 종류의 함수를 **즉시실행함수표현**(IIFE)라고 부르며 private 범위를 만들고 공개될 부분만 내보내게 됩니다.

JavaScript 에서는 함수 내부에 선언한 변수는 외부 범위에서 접근할 수 없다.
함수는 선택적으로 외부 범위에 정보를 전파 시키기 위해서 `return` 구문을 사용할 수 있다.

```js
{
	publicFoo: [Function: publicFoo],
	publicBar: [Function: publicBar]
}
undefined undefined
```

위에서 보여주듯이 myModule로 부터 직접 접근이 가능한 것은 export된 객체 뿐이라는 것을 알 수 있습니다.
우리가 곧 보게 되는 것은 이 패턴을 기반으로 하는 아이디어가 CommonJS 모듈 시스템에서 사용된다는 것입니다.

# CommonJS 모듈
CommonJS는 NodeJS의 첫 번째 내장 모듈 시스템입니다.
NodeJS CommonJS 는 CommonJS 명세를 고려하여 추가적인 자체 확장 기능과 함께 구현되었습니다.
CommonJS 명세의 두 가지 주요 개념을 요약하면 다음과 같습니다
- `require`는 로컬 파일 시스템으로부터 모듈을 임포트하게 해줍니다.
- `exports`와 `module.exports`는 특별한 변수로서 현재 모듈에서 공개될 기능들을 내보내기 위해서 사용됩니다.
현재까지는 이 정보만으로 충분하며, 다가오는 단락들에서 세부적인 내용과 CommonJS 명세에서의 몇 가지 미묘한 차이점을 배우게 될 것 입니다.

## 직접 만드는 모듈 로더
NodeJS에서 CommonJS가 어떻게 작동하는지 이해하기 위해서 비슷한 시스템을 만들어 보겠습니다.
다음의 코드는 NodeJS의 `require()` 함수의 원래 기능 중 일부를 모방한 함수를 만든 것입니다.

먼저 모듈의 내용을 로드하고 이를 private 범위로 감싸 평가하는 함수를 작성해보겠습니다.
```js
function loadModule(filename, module, require){
	const wrappedSrc = `
		(function (module, exports, require){
			${fs.readFileSync(filename, 'utf8')
		})(module, module.exports, require)`
		eval(wrappedSrc)
}
```
모듈의 소스코드는 노출식 모듈 패턴과 마찬가지로 기본적으로 함수로 감싸집니다.
여기서 차이점은 일련의 변수들(module, exports 그리고 require)을 모듈에 전달한다는 것입니다.
눈여겨봐야 할 점은 래핑 함수의 exports 인자가 module.exports 의 내용으로 초기화되었다는 것입니다.

또 다른 주요 사항은 모듈의 내용을 읽어들이기 위해서 `readFileSync`를 사용했다는 것입니다.
파일 시스템의 동기식 버전을 사용하는 것은 일반적으로 권장되지 않지만, 여기서는 이것의 사용이 적절합니다.
CommonJS에서 모듈을 로드 하는 것이 의도적인 동기 방식이기 때문입니다.
이러한 방식에서는 여러 모듈을 임포트할 때 올바른 순서를 지키는 것이 중요합니다.

:::warning 주의
- 이것은 단지 예제일 뿐이며, 실제 애플리케이션에서 모듈의 소스코드를 평가하는 경우는 거의 없습니다.
- `eval()` 함수나 vm 모듈의 함수들은 잘못된 방식이나 잘못된 인자를 가지고 쉽게 사용될 수 있어, 코드 인젝션 공격에 노출될 수 있습니다.
- 이러한 것들은 극도로 주의를 기울여 사용하거나 아예 사용하지 않는 것이 좋습니다.

:::

지금부터 `require()` 함수를 구현해 보겠습니다.
```js
function require(moduleName){
	console.log(`Require invoked for module: ${moduleName}`)
	const id = require.resolve(moduleName)
	if(require.cache[id]){
		return require.cache[id].exports
	}

	// 모듈 메타데이터
	const module = {
		exports: {},
		id
	}

	// 캐시 업데이트
	require.cache[id] = module

	// 모듈 로드
	loadModule(id, module, require)

	// export 되는 변수 반환
	return module.exports
}
require.cache = {}
require.resolve = (moduleName) =>{
	/* 모듈 이름으로 id로 불리게 되는 모듈의 전체 경로를 찾아냄(resolve) */
}
```
위의 함수는 NodeJS에서 모듈을 로드하기 위해 사용되는 NodeJS `require()` 함수의 동작을 모방하고 있습니다.
물론 이는 교육적인 목적을 위한 것이며, 실제 `require()` 함수의 내부 동작을 정확하고 완전하게 반영하고 있는 것은 아닙니다.
그러나 모듈이 어떻게 정의되고, 로드되는지를 포함해서 NodeJS 모듈 시스템의 내부를 이해하기에는 부족함이 없을 것입니다.

우리가 작성한 모듈 시스템은 다음과 같이 설명됩니다.
1. 모듈 이름을 입력으로 받아 수행하는 첫번째 일은 우리가 `id`라고 부르는 모듈의 전체 경로를 알아내는(`resolve`)것입니다.
	- 이작업은 이를 해결하기 위해 관련 알고리즘을 구현하고 있는 `require.resolve()`에 위임 됩니다.
2. 모듈이 이미 로드된 경우 캐시된 모듈을 사용합니다. 이 경우 **즉시 반환**됩니다.
3. 모듈이 아직 로드되지 않은 경우 가지는 `module` 객체를 만듭니다.
	- 이 객체는 불러올 모듈의 코드에서의 `public API`를 export 하는데 사용됩니다.
4. 최초 로드 후에 module객체가 캐시 됩니다.
5. 모듈 소스코드는 해당 파일에서 읽어오며, 코드는 앞에서 살펴본 방식으로 평가됩니다.
	- 방금 생성한 `module` 객체와 `require()` 함수ㄱ의 참조 모듈에 전달합니다.
	- 모듈은 `module.exports` 객체를 조작하거나 대체하거나 public API를 내보냅니다.
6. 마지막으로, 모듈의 `public API`를 나타내는 `module.exports`의 내용이 호출자에게 반환됩니다.

## 모듈 정의
  우리가 만든 `require()` 함수가 어떻게 작동하는지 살펴봄으로써, 모듈을 어떻게 정의하는지 이해할 수 있게 되었습니다.
  다음 코드는 . 그 예를 보여줍니다.
```js
// 또 다른 종속성 로드
const dependency = require('./antherModule')

// private 함수
function log(){
	console.log(`Well done ${dependency.username}`)
}

// 공개적으로 사용되기 위해 export 되는 API
module.exports.run = () =>{
	log()
}
```

기억해야할 기본 개념은 `module.exports` 변수에 할당되지 않는 이상, 모듈 안의 모든 것이 비공개라는 것입니다.
`require()`을 사용하여, 모듈을 로드 할 때 변수의 내용은 캐시되고 리턴 됩니다.

## module.exports 대 exports
NodeJS에 익숙하지 않은 많은 개발자들이 공통적으로 혼란스러워 하는 것은 public API를 공개하기 위해 사용하는 `module.exports`와 `exports`의 차이점 입니다.
앞서 작성한 `require` 함수를 통해 . 이 차이점을 명확하기 이해할 수 있습니다.

변수 `exports`는 module.exports의 초기 값의 참조일 뿐입니다.
우리는 이 값이 본질적으로 모듈이 로드되기 전에 만들어지는 간단한 객체 리터럴이라는 것을 확인했습니다.
```js
exports.hello = () =>{
	console.log('Hello')
}
```

`exports` 변수의 재할당은 `module.exports`의 내용을 변경하지 않기 때문에, 아무런 효과가 없습니다.
그것은 `exports` 변수 자체만을 재 할당 합니다.

따라서 이런 코드는 잘못된 것입니다.
```js
exports = () =>{
	console.log('Hello')
}
```

함수, 인스턴스 또는 문자열과 같은 객체 리터럴 이외의 것을 내보내려면 다음과 같이 `module.exports`를 다시 할당 해야 합니다.

```js
module.exports = () =>{
	console.log('Hello')
}
```

## `require` 함수는 동기적이다.
우리가 고려해야 할 또 다른 중요한 사항은 우리가 만든 `require()` 함수가 동기적이라는 것입니다.
실제로 간단한 직접 스타일을 사용하여, 모듈 내용을 반환하므로 콜백이 필요하지 않습니다.
이것이 NodeJS의 `require()` 함수도 마찬가지 입니다.

그 결과 `module.exports` 에 대한 할당도 역시 동기적이어야 합니다.
예를 들어 다음 코드는 올바르지 않습니다.
```js
setTimeout(()=>{
	module.exports = function() { ... }
}, 100)
```

동기적 특성을 지닌 `require()`는 모듈을 정의할 때 동기적으로 코드를 사용하도록 제한함으로써 우리가 모듈을 정의하는 방식에 영향을 미칩니다.
이것은 NodeJS의 핵심 라이브러리가 비동기 방식에 대한 대안으로 동기식 API를 제공하는 가장 중요한 이유들 중 하나 입니다.

모듈을 비동기적으로 초기화해야 하는 과정이 필요한 경우에는 모듈이 미래 시점에 비동기적으로 초기화되기 때문에, 미처 초기화 되지 않은 모듈을 정의하고 내보낼 수 있습니다.
이런 접근 방식의 문제점은 `require`를 사용하여, 모듈을 로드 한다고 해서 사용할 준비가 된다는 보장이 없다는 것입니다.

초창기에도 이랬었는지 궁금해 하는 사람도 있을 것입니다.
원래 NodeJS 는 비동기 버전의 `require()`를 사용했었습니다.
하지만 과도한 복잡성으로 인해 곧 제거되었습니다.

즉, 실제로는 초기화 시에만 사용 되는 비동기 입출력이 장점보다 더 큰 복잡성을 가져온 것입니다.

## 해결 알고리즘
종속성 지옥(dependency hell)이라는 용어는 프로그램의 종속성이 서로 공통된 라이브러리에 의존하지만 호환 되지 않는 서로 다른 버전을 필요로 하는 상황을 나타냅니다.
NodeJS 는 로드되는 위치에 따라 다른 버전의 모듈을 로드할 수 있도록 하여 이 문제를 우아하게 해결합니다.
이 특성의 장점은 NodeJS 패키지 매니저가 애플리케이션의 종속성을 구성하는 방식과 `require()` 함수에서 사용하는 해결(`resolving`) 알고리즘에도 적용됩니다.

이제 이 알고리즘에 대한 간략한 개요를 살펴보겠습니다.
앞서 보았듯이 `resovle()` 함수는 모듈 이름을 입력으로 사용하여, 모듈 전체의 경로를 반환합니다.
이 경로는 코드를 로드 하고 모듈을 고유하게 식별하는데 사용됩니다.

해결 (resolving) 알고리즘은 크게 다음 세 가지로 나눌 수 있습니다.
- **파일 모듈**
	- `moduleName` 이 `/`로 시작하면 모듈에 대한 절대 경로라고 간주되어 그대로 반환됩니다.
	- `./` 로 시작하면, `moduleName` 은 상대 경로로 간주되며, 이는 요청한 모듈로부터 시작하여, 계산 됩니다.
- **코어 모듈**
	- `moduleName` 이 `/` 또는 `./`로 시작하지 않으면 알고리즘은 먼저 코어 NodeJS 모듈 내에서 검색을 시도 합니다.
- **패키지 모듈**
	- `moduleName`과 일치하는 코어 모듈이 없는 경우, 요청 모듈의 경로에서 시작하여, 
	- 디렉터리 구조를 탐색하여 올라가면서 `node_modules` 디렉터리를 찾고 그 안에서 일치하는 모듈을 계속 찾습니다.
	- 알고리즘은 파일 시스템의 루트에 도달할 때까지 디렉터리 트리를 올라가면서 다음 `node_module` 디렉터리를 탐색하며, 계속 일치하는 모듈을 찾습니다.
파일 및 패키지 모듈의 경우 개별 파일과 디렉터리가 모두 moduleName과 일치할 수 있습니다.
알고리즘은 다음과 일치하는지 확인합니다.
- `\&lt;moduleName>.js
- `<moduleName>/index.js`
- `<moduleName>/package.json`의 `main` 속성에 지정된 디렉터리/파일

:::tip resolving 알고리즘에 대한 공식 문서 전체는 다음 링크에서 찾을 수 있습니다.
- https://node.org/api/modules.html#modules_all_together

:::

`node_modules` 디렉터리는 실제로 패키지 매니저가 . 각패키지의 종속성을 설치하는 곳입니다.
즉, 방금 설명한 알고리즘을 기반으로 각 패키지는 자체적으로 개별적인 종속성을 가질 수 있습니다.
예를 들면, 다음과 같은 디렉터리 구조를 생각해 볼 수 있습니다.

```shell
myApp
|-- foo.js
|-- node_modules
	|-- depA
	|	|-- index.js
	|-- depB
	|	|-- bar.js
	|	|-- node_modules
	|	|	|-- depA
	|	|	|-- index.js
	|-- depC
	|	|-- foobar.js
	|	|-- node_modules
	|	|	|-- depA
	|	|	|	|-- index.js
```

위의 예제에서 `myApp.depB` 그리고 `depC` 모두 `depA`에 종속성을 가지고 있습니다.
그러나 이들은 모두 자신의 개별적인 버전에 대한 종속성을 가지고 있습니다.

해석 알고리즘 규칙에 따라 `require('depA')`를 사용하면, 모듈을 필요로 하는 모둘에 따라 다른 파일이 로드 됩니다.
예를 들면 다음과 같습니다.
- `/myApp/foo.js`에서 `require('depA')` 를 호출할 경우 `/myApp/node_modules/depA/index.js`가 로드 됩니다.
- `/myApp/node_modules/depB/bar.js`에서 `require('depA')`를 호출할 경우 `/myApp/node_modules/depB/node_modules/depA/index.js`가 로드 됩니다.
- `/myApp/node_modules/depC/foobar.js`에서 `require('depA')`를 호출할 경우 `/myApp/node_modules/depC/node_modules/depA/index.js`가 로드 됩니다.

해결 알고리즘은 NodeJS 종속성 관리의 견고성을 뒷받침하는 핵심적인 부분이며, 충돌 혹은 버전 호환성 문제 없이 애플리케이션에서 수백 또는 수천 개의 패키지를 가질 수 있게 합니다.

:::tip 해결 알고리즘은 `require()`를 호출할 때 명확하게 적용됩니다. 그러나 필요한 경우 `require.resolve()`를 호출하여 모듈에서 직접 사용될 수도 있습니다.

:::

## 모듈 캐시
`require()`의 후속 호출은 단순히 캐시된 버전을 반환하기 때문에 각 모듈은 처음 로드될 때만 로드 되고 평가 됩니다.
이것은 우리가 직접 만든 함수의 코드를 보면 분명해집니다.
캐싱은 성능을 위해 매우 중요하지만, 다음과 같은 기능적인 영향도 있습니다.
- 모듈 종속성 내에서 순환을 가질 수 있습니다.
- 일정한 패키지 내에서 동일한 모듈이 필요할 때 얼마간 동일한 인스턴스가 항상 반환된다는 것을 보장합니다.
모듈 캐시는 `require.cache` 변수에서 관련 키를 삭제하여 캐시된 모듈을 무효화 하는 것입니다.
이것은 실습을 위한 테스트에서 매우 유용하지만 일반적인 상황에 적용하는 것은 매우 위험합니다.

## 순환 종속성
많은 사람들이 순환 종속성을 내재된 설계 문제로 생각하지만, 실제 프로젝트에서 발생할 수 있기 때문에 최소한 `CommonJS`에서 어떻게 작동하는지 아는 것이 좋을 것입니다.
우리가 직접 만든 `require()`함수를 다시 살펴보면 이것이 어떻게 동작하는지, 무엇을 조심해야 하는지 바로 알 수 있을 것입니다.
그래도 `CommonJS`가 순환 종속성을 다룰 때 어떻게 동작하는지 예시를 통해서 살펴 보겠습니다.

![Diagram-1.svg](/img/이미지 창고/Diagram-1.svg)
모듈은 `main.js`에 `a.js`와 `b.js` 를 require로 불러옵니다.
차례대로 `a.js`는 `b.js`를 require로 불러옵니다.

하지만, `b.js`또한 `a.js`에 다시 의존하고 있습니다.
모듈 `a.js`가 `require`로 `b.js`를 부르고 `b.js`가 `require`로 `a.js`를 부르는 것에서 우리는 명백히 순환 종속성을 가지고 있는 것을 알 수 있습니다.

- 모듈 `a.js`
```js
exports.loaded = false
module.exports = {
	b,
	loaded: true // 이전 export문을 오버라이드
}
```
- 모듈 `b.js`
```js
exports.loaded = false
const a  = require('./a')

module.exports = {
	a,
	loaded: true
}
```
이 두 모듈이 `main.js`에서 `require` 되는 것을 보겠습니다.
```js
const a = require('./a')
const b = require('./b')

console.log('a -> ', JSON.stringify(a, null, 2))
console.log('b ->', JSON.stringify(b, null, 2))
```
`main.js`를 실행하였을 때의 결과를 보겠습니다.

```shell
a -> {
	b: {
		a:{
			loaded: false
		},
		loaded: true
	},
	loaded: true,
}
b ->{
	a:{
		loaded: false
	},
	loaded: true
}
```

이 결과를 통해 `CommonJS`에서 종속성의 로드 순서에 따라서 모듈 `a.js`와 모듈 `b.js`에 의해서 `export` 된 것을 우리 애플리케이션의 각 부분이 서로 다르게 가질 수 잇다는 순환 종속성의 문제를 살펴 보았습니다.
두 모듈 각자 `main.js`에서 `require`로 불려지면 완전하게 초기화되지만, `b.js`에서 `a.js`는 불완전한 상태가 됩니다.
`b.js` `require`로 호출되는 순간에 다다르게 되는 것입니다.

세부적으로 보이지 않는 부부넹서 어떤 일이 일어나는지 이해하기 위해 단계 별로 서로 다른 모듈이 어떻게 해석 되고, 어떻게 자신들의 로컬 범위가 변하는지 분석 해보겠습니다.

# 모듈 정의 패턴
모듈 시스템은 종속성을 로드하는 메커니즘이 되는 것 외에 API를 정의하기 위한 도구이기도 합니다.
API 디자인과 관련된 문제들의 경우 고려해야 할 주요 요소는 private 함수와 public 함수 간의 균형입니다.
이것의 목푠는 확장성과 코드 재사용 같은 소프트웨어 품질과의 균형을 유지하면서, 정보 은닉 및 API 유용성을 극대화 하는 것입니다

이 섹션에서는 NodeJS 에서 모듈을 정의 할 때 export 지정, 함수, 클래스 그리고 인스턴스 내보내기, 몽키 패치와 같이 가장 많이 사용되는 몇 가지 패턴을 분석합니다.

## export 지정하기 (Named exports)
public API를 공개하는 가장 기본적인 방법은 `exports`에 할당하는 것입니다.
이렇게 하면 `exports`에서 참조하는 객체(또는 `module.exports`)의 속성에 공개할 모든 값을 할당합니다.
그 결과 외부에 공개된 객체는 일련의 관련 기능에 대한 컨테이너 또는 nameSpace가 됩니다.

다음 코드는 이 패턴을 구현하는 모듈을 보여줍니다.
```js
// logger.js 파일
exports.info = (message)=>{
	console.log(`info: ${message}`)
}

exports.verbose = (message)=>{
	console.log(`verbose: ${message}`)
}
```
그렇게 내보내진 함수들은 다음에 보는 바와 같이 로드된 모듈의 속성처럼 사용이 가능합니다.
```js
// file main.js
const logger = require('./logger')
logger.info('This is an informational message')
logger.verbose('This is a verbose message')
```
NodeJS 코어 모듈 대부분은 이 패턴을 사용합니다.
CommonJS의 명세에는 public 멤버를 공개하는데, exports 변수만을 사용하도록 하고 있습니다.
따라서 exports 로 지정하는 것이 CommonJS 의 명세와 호환되는 유일한 방식입니다.
`module.exports`는 NodeJS 가 제공하는 모듈 정의 패턴의 광범위한 범위를 지원하기 위한 것으로, 우리가 다음에 보게 될 것은 이것의 확장입니다.

## 함수 내보내기
가장 일반적인 모듈 정의 패턴 중 하나가 `module.exports`변수 전체를 함수로 재 할당하는 것입니다.
주요 장점은 모듈에 대한 명확한 진입점을 제공하는 단일 기능을 제공하여, 그것에 대한 이해와 사용을 단순화 하는 것입니다.
또한 최소한의 노출(small surface area)이라는 원리에 잘 맞아 떨어집니다.
모듈을 정의하는 이 방법은 [James Halliday](https://github.com/substack)가 많이 사용하는 이후로, 커뮤니티에서 substack 패턴으로 알려져있습니다.
다음 예제로 이 패턴을 살펴봅시다.
```js
// logger.js 파일
module.exports = (message) =>{
	console.log(`info: ${message}`)
}
```
생각해 볼 수 잇는 이 패턴의 응용은 export된 함수를 다른 public API의 namespace로 사용해볼 것입니다.
이렇게 하면, 모듈에 단일 진입점(`export` 된 함수)의 명확성을 제공하므로, 매우 강력한 조합이 된다.
또한 이 접근 방식을 응용하여 그 이상의 고급 유스케이스를 만들 수 있는 다른 부가적인 기능들을 노출 할 수 있습니다.
다음 코드는 export된 함수를 namespace로 사용하여, 앞에 정의한 모듈을 어떻게 확장할 수 있는지 보여줍니다.

```js
module.exports.verbose = (mssage) =>{
	console.log(`verbose: ${message}`)
}
```
또 아래 코드는 방금 정의한 모듈을 사용하는 방법을 보여줍니다.
```js
// main.js 파일
const logger = require('./logger')
logger('This. is an informational message')
logger.verbose('This is a verbose message')
```

단순히 함수를 내보내는 것이 제약 처럼 보일 수 있지만, 실제로는 단일 기능에 중점을 두도록 하는 완벽한 방법이며, 내부 형태에 대한 가시성을 줄이면서 이외 보조적인 사항들이 export 된 함수의 속성으로 노출하여, 단일 진입 점을 제공합니다.
NodeJS의 모듈성은 **한 가지 책임지는 원칙**(SRP: Single Responsibility Principle)을 지킬 것을 강력히 권장합니다.
모든 모듈은 단일 기능에 대한 책임을 져야 하며, 책임은 모듈에 의해 완전히 캡슐화 되어야 합니다.

## 클래스 내보내기
클래스 내보내는 모듈은 함수를 내보내는 모듈이 특화된 것입니다.
차이점은 이 새로운 패턴을 통해 사용자에게 생성자를 사용하여 새 인스턴스를 만들 수 있게 하면서 프로토타입을 확장하고, 새로운 클래스를 만들 수 있는 기능을 제공할 수 있다는 것입니다.
다음은 이 패턴의 예시입니다.
```js
class logger{
	construtor(name){
		this.name = name
	}
	log(message){
		console.log(`[${this.name}] ${message}`)
	}
	info(message){
		this.log(`info: ${message}`)
	}
	verbose(message){
		this.log(`verbose: ${message}`)
	}
}
module.exports = Logger
```
그리고 다음과 같이 위 모듈을 사용할 수 있습니다.

```js
// main.js 파일
const Logger = require('./logger')
const dbLogger = new Logger('DB')
dbLogger.info('This is an informational message')
const accessLogger = new Logger('ACCESS)
accessLogger.verbose('This is a verbose message')
```

클래스를 내보내는 것은 여전히 모듈에 대한 단일 진입 점을 제공하지만, 서브 스택 패턴과 비교하면 훨씬 더 많은 모듈의 내부를 노출합니다.
그러나 다른 한편으로는 기능 확장에 있어 훨씬 더 강력할 수 있습니다.

## 인스턴스 내보내기
우리는 `require()`의 캐싱 메커니즘의 도움을 통해 생성자나 팩토리로부터 서로 다른 모듈 간에 공유할 수 있는 상태 저장 인스턴스를 쉽게 정의 할 수 있습니다.

다음 코드는 이 패턴의 예시 입니다.
```js
// logger.js 파일
class Logger{
	constructor(name){
		this.count = 0
		this.name = name
	}
	log(message){
		this.count ++
		console.log('[' + this.name + ']' + message )
	}
}
module.exports = new Logger('DEFAULT')
```
이렇게 새로 정의된 모듈은 다음과 같이 사용할 수 있습니다.
```js
// main.js
const logger = require('./logger')
logger.log('This is an informational message')
```
모듈이 캐시되기 때무에 logger 모듈을 필요로 하는 모든 모듈은 실제로 항상 동일한 객체의 인스턴스를 받아 상태를 공유합니다.
이 패턴은 싱글톤을 만드는 것과 매우 비슷합니다.
그러나 전통적인 싱글톤 패턴에서 처럼 전체 애플리케이션에서 인스턴스의 고유성을 보장하지는 않습니다.

해결(resolving) 알고리즘을 살펴볼 때 모듈이 애플리케이션의 종속성 트리 내에서 여러 번 설치될 수 있다는 것을 보았습니다.
결과적으로 동일한 논리적 모듈의 여러 인스턴스가 모두 동일한 NodeJS 애플리케이션의 컨텍스트에서 실행될 수 있습니다.

이 패턴에서 한 가지 흥미로운 점은 비록 우리가 명시적으로 클래스를 내보내지는 않았지만, 새로운 인스턴스를 만들지 못하게 막지 않는다는 것입니다.
사실 우리는 export된 인스턴스의 constructor 속성에 기반해서 같은 타입의 새로운 인스턴스를 만들 수 있습니다.
```js
const customLogger = new logger.construtor('CUSTOM')
customLogger.log('This is an informational message')
```

위에서 보듯이 `logger.constructor()`를 이용하여 새로운 Logger 객체를 초기화 했습니다.
이 기법은 신중하게 사용하거나 아예 사용하지 않는 것이 좋습니다.
생각해보면 모듈의 제작자가 클래스를 명시적으로 내보내지 않는다는 것은 제작자가 클래스를 private 클래스로 유지하고 싶었다는 것일 수도 있기 때문입니다.

## 다른 모듈 또는 전역 범위(global scope) 수정
모듈이 아무것도 내보내지지 않을 수도 있습니다.
이는 다소 부적절하게 보일 수 있지만, 우리는 모듈이 캐시에 있는 다른 모듈을 포함하여, 전역 범위와 그 안에 있는 모든 개체를 수정할 수 있다는 것을 잊어서는 안됩니다.
이것은 일반적으로 권장되지 않지만, 이 패턴은 일부 상황(테스트를 위한 상황)에서 유용하고 안전하게, 가끔 실전에서도 사용되지 때문에 이를 이해하고 있어야 합니다.

앞에서 모듈이 전역 범위의 다른 모듈이나 객체를 수정할 수 있다고 말했습니다.
이것을 몽키 패치라고 합니다.
일반적으로 런타임 시에 기존 객체를 수정하거나 동작을 변경하는 임시 수정 적용 관행을 그렇게 말합니다.
다음의 예는 다른 모듈에 새로운 기능을 추가하는 방법을 보여줍니다.

```js
// patcher.js 파일

// ./logger 는 다른 모듈
require('./logger').customMessage = function(){
	console.log('This is a new fucntionality')
}
```
이 새로운 patcher 모듈을 사용하는 방법은 다음 코드와 같이 간단합니다.

```js
// main.js 파일

require('./patcher')
const logger = require('./logger')
logger.customMessage()

```

여기서 설명된 기술은 모두 적용하기에 위험한 기술입니다.
핵심은 전역 네임스페이스나 다른 모듈을 수정하는 모듈을 갖는 데에는 부작용이 있다는 점입니다.
다시 말해, 범위를 벗어난 요소의 상태에 영향을 미치므로, 특히 여러 모듈이 동일한 속성에 대한 작업을 하는 경우에 예측할 수 없는 결과를 초래할 수 있습니다.
두 개의 다른 모듈이 동일한 전역 변수를 설정하려고 하거나, 동일한 모듈의 동일한 속성을 수정하려고 한다면 생각해 봅니다.
그 효과는 예측할 수 없습니다.
중요한 것은 전체 애플리케이션에 좋지 않는 영향을 미친다는 것입니다.

다시 말하자면, 일어날 수 있는 모든 부작용을 이애하며, 신중함을 갖고 이 기법을 사용하세요


![Diagram.svg](/img/이미지 창고/Diagram.svg)
1. `main.js` 에서 처음으로 발견된 import 문이 `a.js`로 곧장 항하게 합니다.
2. `a.js`  에서 `b.js` 로 향하는 `import` 문을 발견합니다.
3. `b.js` 에서 `a.js` 로 다시 향하는(순환) `import` 문이 있습니다.
	- 하지만, `a.js` 는 이미 방문했기 때문에 그 경로는 다시 재 탐색 되지 않습니다.
4. 이 시점에서는 `b.js` 가 다른 `import`문을 가지고 있지 않기 때문에, 탐색이 `a.js`로 되돌아 갑니다.
	- 그리고 `a.js`에서 다른 `import` 문을 가지고 있지 않기 때문에 `main.js` 로 돌아갑니다.
	- 여기서 우리는 `b.js`의 `import` 지점을 발견합니다.
	- 그러나 해당 모듈이 이미 탐색 되었기 때문에, 그 경로는 무시됩니다.

이제 순환 종속성 그래프의 깊이 우선 방문이 끝나고, 아래와 같이 선형적인 모듈들의 모습을 갖게 됩니다.
![Diagram-1-1.svg](/img/이미지 창고/Diagram-1-1.svg)
이 특별한 구조는 꽤 간단합니다.
더욱 많은 모듈이 있는 실제와 비슷한 시나리오에서는 구조가 트리 구조에 가깝게 보일 것입니다.

### 인스턴스화
인스턴스화 단계에서는 인터프리터가 이전 단계에서 얻어진 트리 구조를 다라 아래에서 위로 움직입니다.

인터프리터는 모든 모듈에서 익스포트된 속성을 먼저 찾고 나서 메모리에 익스포트된 이름의 맵을 만듭니다.
![Diagram-2.svg](/img/이미지 창고/Diagram-2.svg)


1. 인터프리터는 `b.js`에서 시작하여 모듈이 `loaded`와 a를  `export` 하는 것을 포착합니다.
2. 인터프리터는 `loaded`와 `b`를 `export`하는 `a.js` 로 이동합니다.
3. 마지막으로 `main.js` 로 이동하여 더 이상의 기능에 대한 `export` 가 없습니다.
4. 마지막 단계에서 `export map` 은 `export`된 이름의 추적 만을 유지합니다.
	- 연관된 값은 현재로는 인스턴스 화 되지 않은 것으로 간주됩니다.

인터프리터는 이 단계들을 거치고 나서 아래에서 보는 바와 같이 import 하는 모듈에게 export 된 이름의 링크를 전달합니다.

![Diagram-3.svg](/img/이미지 창고/Diagram-3.svg)

위 그림은 아래와 같이 설명이 가능하다.
1. 모듈 `b.js` 는 `aModule`라는 이름으로 `a.js`에서의 export를 연결합니다.
2. 모듈 `a.js` 는`bModule` 라는 이름으로 `b.js`에서의 export를 연결합니다.
3. 마지막으로 `main.js`는 b라는 이름으로 `b.js`에서의 모든 export를 import 합니다.
	- 비슷하게 a라는 이름으로 `a.js`에서의 모든 export 를 import 합니다.
4. 다시 말하자면 모든 값이 아직 인스턴스화 되지 않았다는 것에 주목해야 합니다.
	- 이 단계에서는 다음 단계의 마지막에 사용 가능한 값에 대한 참조 만을 연결합니다.

### 평가
마지막 단계는 평가 단계 입니다.
모든 파일의 모은 코드가 실행됩니다.

실행 순서는 원래의 종속성 그래프에서 후위 깊이 우선 탐색으로 다시 아래에서 위로 올라갑니다.
이러한 접근 방법으로 마지막에 실행되는 파일은 `main.js` 입니다.
이 방식이 우리가 메인 비즈니스 로직을 수행하기 전에 export된 모든 값이 초기화 되는 것을 보장해줍니다.
![Pasted-image-20250306134638.png](/img/이미지 창고/Pasted-image-20250306134638.png)

무슨 일이 일어나는지, 위 그림을 따라 가보겠습니다.
1. `b.js` 부터 수행되며, 첫 번째 라인은 모듈에서 export 되는 loaded 값이 `false` 로 평가 됩니다.
2. 마찬가지로 export되는 속성 a가 평가됩니다.
	- 이번에는 `export` map의 모듈 `a.js`를 나타내는 모듈 객체에 대한 참조로 평가 됩니다.
3. `loaded` 속성의 값이 true 로 바뀝니다.
	- 이 시점에서 모듈 `b.js` 의 export 상태가 완전히 평가 되었습니다.
4. 이제 `a.js`로 수행이 이동되고, 다시 `loaded`를 false 로 설정하는 것으로 시작합니다.
5. 이 때, `export b`가 `export` 맴에서 모듈 `b.js`에 대한 참조로 평가됩니다.
6. 마지막으로 loaded 속성은 true로 바뀝니다.
	- 이제 우리는 모듈 `a.js`에서도 완전히 평가된 모든 `export` 를 갖게 됩니다.
모든 단계를 거치고 나서 `main.js`의 코드가 실행되며, 이 때 export 된 모든 속성 값들은 완전히 평가된 상태 입니다.
`import` 된 모든 모듈들은 참조로 추적되고 우리는 순환 종속성이 존재하는 상황에서도 모든 모듈이 다른 모듈의 최신 상태를 갖고 있음을 확신 할 수 있다.

### 모듈의 수정
우리는 읽기 전용 라이브 바인딩 ES 모듈을 통해 개체들을 import 하는 것을 보앗고, 그러한 이유 때문에 외부 모듈에서 그것들을 재 할당하는 것이 불가능합니다.

그러나 주의할 점이 있습니다.
우리가 서로 다른 모듈에서 `default export` 나 이름을 갖는 `export` 의 바인딩을 바꿀 수 없는 것은 사실이지만, 이 바인딩이 객체라면, 우리는 여전히 객체의 특정 속성을 재 할당하여 변경하는 것이 가능합니다.

이는 다른 모듈의 동작을 바꿀 수 있다는 점에서 주의해야합니다.
이러한 발상을 증명하기 위해서 코어 모듈 `fs` 의 동작을 바꾸어 파일 시스템의 접근을 막고 모의 데이터를 리턴 하도록 하는 모듈을 작성해보겠습니다.
이러한 종류의 모듈은 파일 시스템에 의존하게 되는 컴포넌트를 위한 테스트 작성에 유용할 수 있습니다.

```js
// mock-read-file.js
import fs from 'fs'

const originalReadFile = fs.readFile
let mockedReponse = null

export function mockEnable(respondWith){
	mockedResponse = responseWidth
	fs.readFile = mockedReadFile
} 

export function mockDisable(){
	fs.readFile = originalReadFile
}
```

앞의 코드를 살펴보겠습니다.
1. 우리가 처음으로 한 것은 `fs` 모듈의 `default export`를 `import` 한 것입니다.
	- 이 코드는 금방 다시 짚어볼 것이며, 지금은 fs 모듈의 `default export`가 파일 시스템과 상호작용 하게끔 해주는 기능들의 집합을 갖고 있는 객체라는 것을 알아두겠습니다.
2. 우리는 모의 구현으로 `readFile()` 함수를 대체하길 원합니다.
	- 이 작법을 하기 전에 원래의 참조 값을 저장합니다.
	- 또한 나중에 사용할 mockedResponse 값을 선언합니다.
3. `mockedReadFile()`함수는 우리가 원래의 구현을 대체하기 위해서 사용하고자 하는 실질적인 모의 구현입니다.
	- 이 함수는 `mockedResponse`의 현재 값과 함께 콜백을 호출합니다.
	- 이 구현은 간략화 된 것입니다.
	- 실제 함수는 `options`인자를 `callback` 인자 전에 받으며 여러 인코딩의 타입을 다룰 수 있습니다.
4. `export` 된 `mockEnable()` 함수는 모의 기능을 활성화하기 위해 사용될 수 있습니다.
	- 원래의 구현을 모의 구현으로 바꿉니다.
	- 모의 구현은 `responseWith` 인자를 통해 전달된 값과 같은 것을 리턴합니다.
5. 마지막으로 `export`된 `mockDisalbe()` 함수는 `fs.readFile()` 함수의 원래의 구현으로 복귀 시키기 위해서 사용될 수 있습니다.

이제 모듈을 사용하는 간단한 예제를 보겠습니다.
```js
// main.js
import fs from 'fs'
import { mockEnable, mockDisable } from './mock-read-file.js'

mockEnable(Buffer.from('Hello World'))

fs.readFile('fake-path', (err, data)=>{
	if(err){
		console.error(err)
		process.exit(1)
	}
	console.log(data.toString()) // 'Hello World'
})

mockDisable()
```

이 예제에서 어떤 일이 일어나는지 한 단계씩 살펴보겠습니다.
1. 우리가 처음 한 것은 fs 모듈의 `default export`를 import 한 것입니다.
2. 모의 기능을 활성화 했습니다.
	- 우리가 해보고 싶은 것은 우리가 읽은 모든 파일이 "Hello World" 문자열을 갖고 있다고 모방하는 것입니다.
3. 마지막으로 가짜 경로를 이용하여 파일을 읽었습니다.
	- 코드는 `readFile()` 함수의 모의 버전을 사용하여 `"Hello World"` 를 출력할 것입니다.
	- 주목할 점은 우리가 이 함수의 호출이 끝난 뒤에 `mockDisable()`을 호출하여 원래의 구현을 복구했다는 것입니다.

이러한 접근 방법은 작동하는데 문제는 없지만, 취약하기도 합니다.
사실 이것이 작동하지 않는 많은 경우가 존재합니다.
우리는 `mock-read-file.js`에서 다음의 두 가지 방법으로 `fs` 모듈을 import 할 수 있습니다.

```js
import * as fs from 'fs'
```
또는
```js
import { readFile } from 'fs'
```

이 경우 `fs` 모듈은 모든 파일 시스템 함수들을 이름이 지정된 `export` 로 내보내므로 두 `import` 문 모두 유효합니다.
- 동일한 함수들의 집합을 속성으로 가진 객체인 `default exports` 제외
두 import 구문은 구문 중에서 하나를 사용했을 때, 동작하지 않는 이유는 모의 유틸이 `default export`로 export 로 익스포트된 객체의 내부에 등록된 `readFile()` 의 복사만을 대체하기 때문이며, 모듈의 최상위 수준에서는 이름이 지정된 `export` 로 사용할 수 없기 때문이다.

이러한 특성 예제는 ESM의 환경에서 몽키 패치가 얼마나 복잡하고 신뢰하기 힘든지 보여줍니다.
이 때문에 Jest 와 같은 테스트 프레임 워크가 더 나은 신뢰를 가지고 ES 모듈을 모의 할 수 있도록 특별한 기능을 제공합니다.

`module` 패키지에 있는 `syncBuiltinESMExport()` 함수를 이용할 수도 있습니다.
이 함수가 호출되면 `default exports` 객체 있는 속성들의 값이 `named exports` 와 동일한 것으로 매핑 됩니다.
이것은 효과적으로 `named export`도 포함하여, 모듈 기능에 적용된 외부 변화를 전파하게 해줍니다.

```js
import fs, { readFileSync } from 'fs'
import { syncBuiltinESMExports } from 'module'

fs.readFileSync = () => Buffer.from('Hello, ESM')
syncBuiltinESMExports()

console.log(fs.readFileSync === readFileSync) // true
```

모의 동작을 활성화 하거나 원래의 기능을 되돌린 뒤에 `syncBuiltinESMExports()` 함수를 호출하면 우리의 작은 모의 파일 시스템 유틸을 좀 더 유연하게 만들 수 있습니다.

:::tip `syncBuiltinESMExports()`는 우리의 예제의 fs 모듈과 같이 오직 내장 NodeJS 모듈에서만 동작함

:::

우리는 ESM 이 어떻게 동작하는지, 그것이 모듈을 어떻게 적재하는지 그리고 순환 종속성을 어떻게 다루는지 이해할 수 있습니다.

`CommonJS`와 `ECMAScript` 모듈 사이의 주요 차이점과 몇 가지 흥미로운 상호 운용 기술을 알아볼 준비가 되었습니다.

### strict 모드에서의 ESM
ES 모듈들은 암시적으로 `strict mode` 에서 실행됩니다.
우리가 명시적으로 `use strict` 구문을 모든 파일의 시작에 추가할 필요가 없다는 의미와 같습니다.
`Strict mode` 를 해제할 수 없습니다.

따라서 우리는 선언되지 않은 변수, `with` 구문 또는 `non-strict mode`에서만 사용 가능한 것들을 사용할 수 없습니다.
하지만, `strict mode` 가 더 안전한 실행 모드이기 때문에 이 것이 확실히 좋은 것이라고 할 수 있습니다.

### ESM에서의 참조 유실
ESM에서는 ES 모듈이 strict mode 에서 실행되기 때문에, `require`, `export`, `module.export`, `__filename` 그리고 `__dirname`을 포함하여 CommonJS 의 몇 가지 중요한 참조가 정의 되지 않습니다.
만약 우리가 ES 모듈에서 이러한 것들을 사용한다면, ReferenceError가 발생합니다.

```js
console.log(exports) // ReferenceError : exports is not defined
console.log(module) // ReferenceError : module is not defined
console.log(__filename) // ReferenceError : __filename is not defined
console.log(__dirname) // ReferenceError : __dirname is not defined
```

우리는 이미 CommonJS의 `exports` 와 `module` 의 의미에 대해서 자세히 다뤘습니다.
`__filename`은 현재 모듈 파일의 절대 경로를 `__dirname`은 파일이 있는 폴더의 절대 경로를 나타냅니다.
이러한 특별한 변수들은 우리가 현재 파일에 대한 상대 경로를 빌드할 때 매우 유용합니다.

ESM에서 특별한 객체인 `import`, `meta` 를 사용하여, 현재 파일에 대한 참조를 얻을 수 있습니다.
특히, `import.meta.url`은 현재 모듈을 참조하여, `file://path/to/current_module.js`와 같은 형식입니다.
이 값으로 절대 경로 형식에 대한 `__filename`과 `__dirname`를 재구성하는데 사용할 수 있습니다.

```js
import { fileURLToPath } from 'url'
import { dirname } from 'path'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

```


또한 `require()` 함수를 다음과 같이 재구성하는 것이 가능합니다.
```js
import { createRequire } from 'module'
const require = createRequire(import.meta.url)
```

어제 우리는 ES 모듈의 문맥상에서 CommonJS 모듈의 기능들을 `import` 하는데 `require()` 를 사용할 수 있습니다.
다른 흥미로운 차이점은 this 키워드의 동작입니다.

ES 모듈의 전역 범위에서 `this`는 `undefined` 인 반면, CommonJS 에서는 `this` 가 `exports` 와 같은 참조를 하고 있습니다.

```js
// this.js - ESM
console.log(this) // undefined
```


```js
// this.js - CommonJS
console.log(this === exports) // true
```

### 상호 운용
이전 장에서 `module.createRequire` 함수를 사용하여, EMS 내부에 CommonJS 모듈을 어떻게 Import 하는지 살펴보았습니다.
ESM 에서 표준 import 문법을 사용하여, CommonJS 모듈을 import 하는 것 또한 가능합니다.

```js
import packageMain from 'commonjs-package' // 작동
import { method } from 'commonjs-package' // 에러
```

안타깝게도 CommonJs 모듈에서 ES 모듈을 import 하는 것은 불가능합니다.

---

#NodeJS #ApplicationArcithecture 

---