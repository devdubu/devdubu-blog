---
slug: "7.-생성자-디자인-패턴"
---
# 머리말
디자인 패턴이란 반복된 문제에 대한 재사용 가능한 해결책입니다.
이 용어는 정의가 매우 광범위하며, 애플리케이션의 여러 도메인에서 사용할 수 있습니다.
이 용어는 90년대 전설의 4인조(Gang of Four, GoF) 로 불린 Erich Gamma, Richard Helm, Ralph Johnson, John Vlisside이 쓴, 널리 알려진 GoF의 디자인 패턴에서 유래했습니다.

이런 일련의 객체지향 디자인 패턴을 JavaScript 에 적용하는 것은 고전적인 객체 지향 언어에서처럼 선형적이고 형식적이지 않습니다.
알다싶이, Javascript는 객체지향적이고 프로토타입 기반이며 동적 타이핑(dynamic typing)을 가지고 있습니다.
또한 함수를 일급 객체로 하여 함수형 프로그래밍의 형식을 허용합니다.
이러한 특성은 JavaScript를 매우 다재다능한 언어로 만들어서 개발자에게 엄청난 힘을 제공하지만, 동시에 프로그래밍 스타일, 규칙, 기술에 이르기까지 궁극적으로 생태계의 패턴을 분열시킵니다.

JavaScript를 사용하면, 동일한 결과를 얻을 수 잇는 방법이 너무 많아서, 많은 개발자가 문제에 접근하는 데 있어서 동일한 결과를 얻을 수 있는 방법이 너무 많아서, 많은 개발자가 문제에 접근하는데 있어서 자신만의 효과적인 방식을 가지고 있습니다.

이 현상을 단적으로 보여주는 것이 JavaScript 생태계의 풍부한 프레임워크들과 독보적인 라이브러리들입니다.
아마도 다른 언어에서는 찾기 힘든 현상입니다.
특히 NodeJS 가 JavaScript에 새롭고 놀라운 가능성을 제공함으로서 많은 새로운 시나리오가 만들어졌습니다.

이러한 맥락에서 JavaScript의 특성은 전통적인 디자인 패턴에도 영향을 미칩니다.
JavaScript에서는 전통적인 디자인 패턴을 구현할 수 있는 방법이 너무 많아서, 강력한 전통적인 객체지향 구현이 더 이상 적용되지 않습니다.

JavaScript는 실제 클래스나 추상 인터페이스를 가지고 있지 않기 때문에, 디자인 패턴의 전통적인 구현 자체가 불가능 한 경우도 있습니다.
그러나 변하지 않는 것이 있으니, 각 패턴의 기본에 있는 근본적인 아이디어, 당면한 문제, 해결 방식의 핵심 개념이 그것입니다.

NodeJS 에 적용되고, 그 철학에 영향을 준 몇 가지 중요한 GoF 디자인 패턴을 살펴보면서 다른 관점에서 그 중요성을 재발견하게 될 것입니다.
전통적인 디자인 패턴들 사이에서 JavaScript 생태계에서 생겨난 덜 전통적인 디자인 패턴들도 볼 수 있습니다.

특히 이 장에서는 생성이라 불리는 디자인 패턴들을 살펴보겠습니다.
이름에서 알 수 있듯이 이러한 패턴들은 객체의 생성과 관련된 문제들을 해결합니다.
예를 들어, 팩토리(Factory) 패턴은 함수 내에서 객체 생성을 캡슐화 할 수 있습니다.

공개 생성자(Revealing Contructor)패턴을 사용하면 생성 중에만 객체의 속성 및 함수들을 노출 할 수 있으며, Builder 패턴은 복잡한 객체 생성을 단순화 할 수 있습니다.

마지막으로 싱글톤(Singleton) 패턴과 종속성 주입(Dependency Injection) 패턴은 애플리케이션 내에서 모듈들을 연결할 때 복잡성을 제거할 수 잇습니다.

#  팩토리
NodeJS 에서 가장 일반적인 디자인 패턴인 팩토리 패턴부터 시작해보겠습니다.
뒤 에서 살펴보겠지만, 팩토리 패턴은 매우 다양하며 한가지 이상의 목적을 가지고 있습니다.

주요 장점은 특정 구현으로부터 객채의 생성을 분리할 수 있다는 것입니다.
예를 들어, 실행 시 생성되는 객체를 결정할 수 있는 것입니다.

또한 Factory 는 클래스보다 훨씬 작은 면을 노출 할 수 잇게 합니다.
클래스는 확장되거나 조작될 수 있지만, 팩토리는 함수일 뿐이기 때문에, 사용자에게 더 적은 유연성을 제공하여 더 강력할 뿐 아니라, 이해하기도 쉽습니다ㅣ.

끝으로 팩토리는 클로저를 활용하여 캡슐화를 강제하는데 사용될 수도 있습니다.

## 객체 생성과 구현의 분리
앞서 우리는 JavaScript에서 단순성, 유용성 및 작은 노출 면으로 인해 순수한 객체 지향 디자인 보다 함수형 방식이 더 선호 된다는 사실을 언급했습니다.

특히 새로운 객체의 인스턴스를 만들 때 그렇습니다.
실제로 `new` 연산자 혹은 `Object.create()` 를 사용하여 클래스로부터 새로운 객체를 만드는 대신 팩토리를 호출하는 것이 여러 측면에서 훨씬 더 편리하고 유연합니다.

무엇보다도, 팩토리를 사용하면 객체 생성과 구현을 분리할 수 있습니다.
기본적으로 팩토리는 새 인스턴스 생성과 감싸서 객체 생성시 더 많은 유연성과 제어를 제공합니다.

팩토리 내에서 `new` 연산자를 사용하여 클래스의 새 인스턴스를 만들거나, 클로저를 활용하여 상태를 기억하는 객체 리터럴을 동적으로 작성하거나, 특정 조건에 따라 다른 유형의 객체를 반환하도록 할 수도 있습니다.

팩토리를 사용하는 사람은 인스턴스 생성이 수행되는 방식에 대해 전혀 알 수 없습니다.
사실 `new` 를 사용하면 객체를 생성하는 특정 방법에 코드를 바인딩하는 반면, 팩토리를 사용하면 큰 노력 없이 훨씬 더 많은 유연성을 가질수 있습니다.

간단한 예로서 Image 객체를 생성하는 간단한 팩토리를 생각해보겠습니다.

```js
function createImage(name){
	return new Image(name)
}

const image = createImage('photo.jpeg')
```

팩토리 `createImage()`는 전혀 불필요하게 보입니다.
왜 `new` 연산자를 사용해 직접 인스턴스를 생성하지 않을까요?
왜 다음처럼 작성하지 않을까요?

```js
const image = new Image(name)
```

이미 언급했듯이 new 를 사용하면 코드를 특정 유형의 객체에 바인딩 합니다.
앞의 경우는 Image 객체 유형이비다.
반면에 팩토리는 훨씬 더 큰 유연성을 제공합니다.

이미지 형식 마다 하나의 클래스를 지원하기 위해 Image 클래스를 더 작은 클래스로 분할한다고 생각해봅시다.

새로운 이미지를 생성하는 방법으로 팩토리 만을 사용하도록 했다면, 기존의 다른 코드들을 손댈 필요 없이, 다음과 같이 코드를 간단히 다시 쓰기만 하면 됩니다.

```js
function createImage (name) {
	if(name.match(/\.jpe?g$/)){
		return new ImagJpeg(name)
	}else if(name.match(/\.gif$/)){
		return new ImageGif(name)
	}else if(name.match(/\.png$/)){
		return new ImagePng(name)
	}else {
		throw new Error('Unsupported format')
	}
}
```

팩토리는 또한 클래스를 숨겨, 멋대로 확장하거나 수정하는 것을 막아줍니다.
JavaScript 에서는 팩토리만 사용하도록 함으로써 클래스를 비공개로 유지할 수 있습니다.

## 캡슐화를 강제할 수 있는 메커니즘
팩토리는 클로저 덕분에 캡슐화 메커니즘으로 사용될 수도 있습니다.

캡슐화는 외부 코드가 컴포넌트의 내부 핵심에 직접 접근하여 조작하는 것을 방지하기 위해 접근을 제어하는 것을 의미합니다.
컴포넌트와의 상호작용은 오직 공용(public) 인터페이스를 통해서 만 가능하여, 컴포넌트의 상세 구현의 변경으로부터 외부 코드를 분리 시킬 수 있습니다.

캡슐화는 상속, 다형성 및 추상화와 함께 객체 지향 디자인의 기본 원칙입니다.
JavaScript 에서 캡슐화를 적용하는 주요 방법 중 하나는 함수의 Scope 와 클로저(Closure)를 사용하는 것입니다.
팩토리는 쉽게 프라이빗 변수들을 강제할 수 있습니다.
다음과 같은 경우를 생각해봅시다.

```js
function createPerson(name){
	const privateProperties = {}

	const person = {
		setName (name) {
			if(!name){
				throw new Error('A person must have a name')
			}
			privateProperties.name = name
		},
		getName(){
			return privateProperties.name
		}
	}
	
	person.setName(name)
	return person
}
```

코드에서 우리는 클로저를 사용해서 두 개의 객체를 생성했습니다.
하나는 팩토리가 반환하는 퍼블릭 인터페이스인 `person` 객체이고, 다른 하나는 외부에서는 접근 할 수 없고, `person` 객체가 제공하는 인터페이스만 통해 접근 할 수 있는 `privateProperties` 입니다.

앞의 코드로 예를 든다면, 우리는 person 객체의 name 속성은 반드시 값을 가진다는 것을 알 수 있습니다.
이는 name이 person 객체의 일반 속성일 경우 절대 강제할 수 없습니다.

:::tip 클로저를 사용하는 것이 캡슐화를 적용할 수 있는 유일한 기술이 아닙니다.
- 실제, 다른 방법들은 다음과 같습니다.
- NodeJS 12 도입된 private 클래스 필드를 사용합니다.(맨 앞에 # 기호로 시작하는 형식)를 사용합니다.
- 이에 대한 [자세한 내용](https://github.com/tc39/proposal-class-fields#private-fields) 를 참조하세요.
- WeakMaps 사용, [자세한 내용](https://fitzgen.com/2014/01/13/hiding-implementation-details-with-e6-weakmaps.html) 참조하세요
- 생성자에서 private 변수를 정의
- 변수 앞에 `_` 을 붙이는 규칙을 사용합니다.
- 그러나 이것은 외부에서 멤버들의 값을 읽거나 수정하는 것을 기술적으로 막지 못합니다.

:::

## 간단한 코드 프로파일러 만들기

이제 팩토리를 사용하여 완전한 예제를 작성해봅시다.
다음과 같은 속성을 가진 간단한 코드 프로파일러를 만들어 보겠습니다.
- `start()` 함수는 프로파일링 세션을 시작시킵니다.
- `end()` 함수는 세션을 끝내고 실행 시간을 콘솔에 출력합니다.

다음과 같은 내용을 가진 `profiler.js` 파일을 생성하는 데서 시작합니다.
```js
class Profiler{
	constructor(label){
		this.label = label
		this.lastTime = null
	}

	start(){
		this.lastTime = process.hrtime()
	}

	end(){
		const diff = process.hrtime(this.lastTime)
		console.log(`Timer "${this.label}" took ${diff[0]} seconds and ${diff[1]} nanoseconds.`)
	}
}
```

방금 정의한 Profiler 클래스는 NodeJS 가 기본적으로 가지고 있는 정밀한 타이머를 사용하여 `start()` 가 호출될 때, 현재 시간을 저장한 다음 `end()` 가 실행 될 때, 경과 시간을 계산하여 콘솔에 출력합니다.

다른 루틴의 실행 시간을 계산하는 이와 같은 프로파일러를 현실의 응용프로그램에서 사용할 경우, 특히 프로덕션 환경에 엄청난 양의 프로파일링 정보가 출력 될 것이라는 것을 예상할 수 있습니다.

이런 경우를 대비해 생각해 볼 수 있는 것은, 프로파일링 정보를 다른 파일에 쓰거나(예 : 전용 로그 파일) 애플리케이션이 프로덕션 모드에서 실행 중일 경우 프로파일러를 모두 비활성화하는 것입니다.

이럴 경우, `new` 연산자를 사용하여 `Profile` 객체를 직접 인스턴스화 하기 위해서는 다른 로직으로 분기하기 위해 프로파일러를 사용하려는 코드의 일부를 수정하거나, `Profiler` 객체 자체에 일부 코드를 추가해야 할 것입니다.

또는 팩토리를 사용하여 Profile 객체의 생성을 추상화 한 후 애플리케이션이 프로덕션(production) 모드에서 실행되는지 개발(development) 모드에서 실행되는지에 따라 완전하게 동작하거나 인터페이스 동일하지만, 메서드가 비어있는 모의 객체를 반환하도록 할 수 있습니다.

이것이 바로 `profiler.js` 에서 할 일 입니다.
`Profiler` 클래스를 익스포트하는 대신 우리가 만든 팩토리를 익스포트 할 것입니다.

```js
const noopProfiler = {
	start() {},
	end() {}
}

export function createProfiler (label){
	if(process.env.NODE_ENV === 'proudction'){
		return noopProfiler
	}
	return new Profiler(label)
}
```

`createProfiler()` 함수는 팩토리이고, 그 역할은 구현된 바대로, `Profiler` 객체의 생성을 추상화하는 것입니다.
애플리케이션이 프로덕션 모드에서 실행 중인 경우, 기본적으로 아무것도 수행하지 않는 `noopProfiler`를 반환하여 프로파일링을 효과적으로 비활성화 합니다.

애플리케이션이 프로덕션 모드에서 실행되고 있지 않으면, 완전한 기능을 가진 새로운 Profiler 인스턴스를 만들어 반환합니다.

JavaScript의 동적 타이핑 덕분에 어떤 상황에서는 `new` 연산자로 인스턴스화된 개겣를 다른 상황에서는 간단한 객체 리터럴을 반환할 수 있었습니다.( [덕 타이핑](nodejsdp.link/duck-typing) ) 이것은 팩토리 함수 내에서 원하는 방식으로 객체를 생성하는 방법을 보여줍니다.

이렇게 하면, 추가적인 초기화 단계를 실행하거나 특정 조건에 다라 다른 유형의 객체를 반환 할 수도 있는데, 이 모든 작업은 이러한 모든 세부 사항들로부터 사용자를 분리함으로써 가능한 것입니다.

여러분은 이제 단순한 패턴의 힘을 이제 이해할 수 있을 것입니다.

이제 프로파일러 팩토리를 잠깐 사용해보겠습니다.
주어진 수의 모든 인자를 계산하는 알고리즘을 만들어 `profiler`를 수행 시간을 알아보겠습니다.

```js
// index.js
import { createProfiler } from './profiler.js'
function getAllFactors(intNumber){
	const profiler = createProfiler(
		`Finding all factors of ${intNumber}`
	)

	profiler.start()
	const factors = []
	for(let factor = 2; factor <= intNumber; factor++ ){
		while((intNumber % factor) === 0){
			factors.push(factor)
			intNumber = intNumber / factor
		}
	}
	profiler.end()

	return factors
}

const myNumber = process.argv[2]
const myFactors = getAllFactors(myNumber)
console.log(`Factors of ${myNumber} are: `, myFactors)
```

`profiler` 라는 변수는 런타임에 `createProfiler()` 팩토렝 의해 `NODE_ENV` 라는 환경 변수를 기반으로 생성되는 `Profiler` 객체를 가지게 됩니다.
예를 들어, 우리가 프로덕션 모드에서 실행하면 프로파일링 정보는 아무것도 얻지 못하게 될 것입니다.

```shell
NODE_ENV=production node index.js
```

반면 개발 모드에서 실행한다면, 프로파일링 정보가 콘솔에 나타납니다.

```shell
node index.js
```

앞서 말했듯이 팩토리는 NodeJS 에서 매우 일반적입니다.
인기 있는 [Knex](nodejsdp.link/knex) 패키지에서 한 가지 예를 찾을 수 있습니다.
Knex 는 여러 종의 데이터 베이스를 지원하는 SQL 쿼리 빌더 입니다.

이 패키지는 단순히 팩토리 함수 하나 만을 제공합니다.
팩토리는 다양한 검사를 수행하고, 데이터 베이스 엔진에 알맞는 dialect 객체를 선택하고, 마지막으로 Knex 객체를 생성하여 반환합니다.

해당 [링크](nodejsdp.link/knex-factgory)에서 예제 코드를 볼 수 있습니다.

# 빌더
빌더는 유창한 인터페이스 (fluent interface)를 제공하여, 복잡한 객체의 생성을 단순화하는 생성 디자인 패턴으로 단계 별로 객체를 만들 수 있습니다.

이렇게 하면 복잡한 객체를 만들 때 가독성과 일반적인 개발자 사용성이 크게 향상 됩니다.
빌더 패턴의 장점을 살릴 수 있는 가장 명확한 상황은 인자의 목록이 길거나, 많은 복잡한 매개 변수를 입력으로 사용하는 생성자가 있는 클래스 입니다.

일반적으로 이러한 종류의 클래스들은 모두 완전하고 일관된 상태의 인스턴스를 만들기 위해, 사전에 너무 많은 매개변수들을 필요로 하기 때문에, 잠재적인 솔루션을 생각할 때 이를 고려해볼 필요가 있습니다.

이제 이 패턴의 일반적인 구조를 살펴보겠습니다.

다음과 같은 생성자가 잇는 Boat 클래스가 있다고 생각해봅시다.
```js
class Boat{
	constructor(hasMotor, motorCount, motorBrand, motorModel, hasSails, sailsCount, sailsMaterial, sailsColor, hullColor, hasCabin){
		// ...
	}
}
```

이러한 생성자를 호출하면 읽기 어려운 코드가 만들어져 오류가 발생하기 쉽습니다.
다음 코드를 사용해 봅시다.

```js
const myBoat = new Boat(true, 2, 'Best Motor Co ', 'OM123', true, 1, 'fabric', 'white', 'blue', false)
```

이러한 생성자의 디자인을 개선하는 첫 번째 단계는 다음과 같이, 모든 인자를 하나의 객체 리터럴에 모으는 것입니다.

```js
class Boat {
	constructor(allParameters){
		// ...
	}
}

const myBoat = new Boat({
	hasMotor: true,
	motorCount: 2,
	motorBrand: 'Best Motor Co. ',
	motorModel : 'OM123',
	hasSails: true,
	sailsMaterial: 'fabric',
	sailsColor : 'white',
	hullColor: 'blue',
	hasCabin: false
})
```

앞선 코드에서 알 수 있듯이, 새로운 생성자는 전달 받은 각각의 매개변수 값이 무엇인지 명확하게 볼 수 잇도록 하여 원래 생성자보다 훨씬 가독성이 좋습니다.
하지만 우리는 이를 더욱 개선할 수 있습니다.

하나의 객체 리터럴을 사용하여 모든 입력을 한번에 전달할 경우 한 가지 단점은 실제 입력이 무엇인지 알기 위해 클래스를 정의한 문서를 보거나 더 나쁜 경우 클래스의 코드를 봐야한다는 것입니다.

여기에 더하여, 개발자가 일관된 클래스를 생성할 수 있도록 안내하여 강제하는 방법이 없습니다.
예를 들어, `hasMotor:true` 를 지정하면 `motorCount`, `motorBrand` 및 `motorModel` 도 함께 지정해야 하지만, 이러한 정보를 전달하는 인터페이스가 없습니다.

빌더 패턴은 이런 작은 결함까지도 교정하고 읽기 쉬우면서 자체 문서화가 가능한 유연한 인터페이스를 제공하여, 일관된 객체 생성을 위한 지침을 제공할 수 있습니다.
Boat 클래스에 대한 빌더 패턴을 구현한 `BoatBuilder` 클래스를 살펴봅시다.

```js
class BoatBuilder {
	withMotors(count, brand, model){
		this.hasMotor = true
		this.motorCount = count
		this.motorBrand = brand
		this.motorModel = model
		return this
	}

	withSails (count, material, color){
		this.hasSails = true
		this.sailsCount = count
		this.sailsMaterial = material
		this.sailsColor = color 
		return this
	}

	hullColor(color){
		this.hullColor = color 
		return this
	}

	withCabin(){
		this.hasCabin = true
		return this
	}

	build(){
		return new Boat({
			hasMotor: this.hasMotor,
			motorCount: this.motorCount,
			motorBrand: this.motorBrand,
			motorModel: this.motorModel,
			hasSails: this.hasSails,
			sailsCount: this.sailsCount,
			sailsMaterial: this.sailsMaterial,
			sailsColor: this.sailsColor,
			hullColor: this.hullColor,
			hasCabin: this.hasCabin,
		})
	}
}
```

빌더 패턴이 Boat 객체를 생성하는 방식에 미치는 장점을 중분히 이해하기 위해 다음과 같이 사용 예를 보겟습니다.

```js
const myBoat = new BoatBuilder()
	.withMotors(2, 'Best Motor Co. ', 'OM123')
	.withSails(1, 'fabric', 'white')
	.withCabin()
	.hullcolor('blue')
	.build()
```

보시다시피, BoatBuilder 클래스의 역할을 일부 Helper 함수를 사용하여, Boat 를 생성하는데, 필요한 모든 매개 변수를 모으는 것입니다.

일반적으로 각 매개 변수 도는 일련의 매개 변수들을 위한 함수는 존재하지만, 이에 대한 명확한 규칙은 없습니다.
입력 매개 변수 수집을 담당하는 각 함수의 이름과 동작을 결정하는 것은 `Builder` 클래스를 만드는 이에게 달려있습니다.

빌더 패턴을 구현하기 위한 몇가지 일반적인 규칙은 다음과 같이 요약해볼 수 있습니다.
- 주요 목적은 복잡한 생성자를 더 읽기 쉽고 관리하기 쉬운 여러 단계로 나눈 것입니다.
- 한번에 관련된 여러 매개 변수를 설정할 수 있는 빌더 함수를 만듭니다.
- setter 함수를 통해 입력받을 값이 무엇일지 명확히 하고, 빌더 인터페이스를 사용하는 사용자가 알 필요가 없는 파라미터를 셋팅하는데 더 많은 로직을 setter 함수 내에 캡슐화합니다.
- 필요하다면, 클래스의 생성자에게 매개 변수를 전달하기 전에, 형 변환, 정규화 혹은 추가적인 유효성 검사와 같은 조작을 추가하여 빌더 클래스를 사용하는 사람이 수행해야 할 작업을 훨씬 더 단순화 할 수 있습니다.

:::tip JavaScript에서 빌더 패턴은 생성자를 사용하여 객체를 생성할 때 뿐만 아니라 함수를 호출할 때도 적용할 수 있습니다.
- 실제 기술적인 고나점에서 두 절차는 동일하빈다.
- 함수 호출에 사용할 경우 가장 큰 다른점은 `build()` 함수 대신 빌더 객체를 받아들인 매개 변수들로 복잡한 홈수를 호출하고 최종 결과를 호출자에게 반환하는 `invoke()` 함수가 존재한다는 것입니다.

:::

## URL 객체 빌더 구현하기
표준 URL 의 모둔 구성 요소를 저장하고 검증한 다음 문자열로 다시 형식을 만들 수 있는 URL 클래스를 만들고자 합니다.
이 클래스는 의도적으로 단순하고 최소한의 수행되므로 프로덕션 모드에서 사용하기 위해서는 [내장 URL 클래스](https://nodejs.org/api/url.html#url_class_url)의 사용을 권장합니다.

`url.js`라는 파일에 URL 구현해 보도록 하겠습니다.

```js
export class Url{
	constructor(protocol, username, password, hostname, prot, pathname, search, hash){
		this.protocol = protocol
		this.username = username
		this.password = password
		this.hostname = hostname
		this.port = port 
		this.pathname = pathname
		this.search = search 
		this.hash = hash

		this.validate()
	
	}

	validate(){
		if(!this.protocol || !this.hostname){
			throw new Error('Must specify at least a protocol and a hostname')
		}
	}

	toString(){
		let url = ''
		url += `${this.protocol}://`

		if(this.username && this.password){
			url += `${this.username}:${this.password}@`
		}
		url += this.hostname
		if(this.port){
			url += this.port
		}
		if(this.pathname){
			url += `?${this.search}`
		}
		if(this.hash){
			url += `#${this.hash}`
		}
		return url
	}
}
```

표준 URL 은 여러 구성 요소로 구성되어 있으므로, 모두 가져오려면 URL 클래스의 생성자가 필연적으로 커야 합니다.
이러한 생성자를 호출하는 것은 어려운 일이 될 수 있습니다.
우리가 전달하는 매개 변수가 이러한 구성요소 중 어떤 값인지 알고 있어야 하기 때문입니다.

이에  대한 아이디어를 얻기 위해 다음 예제를 살펴봅시다.

```js
return new Url('https', null, null, 'example.com', null, null, null, null)
```

방금 배운 빌더 패턴을 적용하기에 안성 맞춤인 상황입니다.
바로 수행해보겠습니다.

목표는 URL 클래스를 인스턴스 화 하는데 필요한 각 매개변수(혹은 관련된 일련의 매개 변수들)에 대한 `setter` 함수가 있는 `UrlBuilder` 클래스를 만드는 것입니다.

마지막으로, 빌더는 빌더에 설정된 모든 매개 변수를 사용하여 생성된 새로운 Url 인스턴스를 만들어내는 `build()` 함수를 가질 것입니다.
이제 `urlBuilder.js` 라는 파일에 빌더를 구현해 보겠습니다.

```js
export class UrlBuilder{
	setProtocol (protocol){
		this.protocol = protocol
		return this
	}

	setAuthentication(username, password){
		this.username = useranem 
		this.password = password
		return this
	}

	setHostname(hostname){
		this.hostname = hostname
		return this
	}

	setPort (port){
		this.port = port
		return this
	}

	setPathname (pathname) {
		this.pathname = pathname
		return this
	}

	setSearch (search) {
		this.search = search
		return this
	}

	setHash(hash){
		this.hash = hash
		return this
	}

	build(){
		return new Url(this.protocol, this.username, this.password, this.hostname, this.port, this.pathname, this.search, this.hash)
	}
}
```

매우 직관적입니다.
사용자 이름과 암호 매개 변수를 `setAuthentication()` 하나의 함수로 결합한 방식에 유의 하십시오
이는 Url 에 인증 정보를 지정하려는 경우, 사용자 이름과 비밀번호를 모두 제공해야 한다는 사실을 명확하게 합니다.

이제 UrlBuilder를 사용해보고 Url 클래스를 직접 사용하여 이 방식의 장점을 경험할 수 있게 되었습니다.
`index.js` 라는 파일에서 사용해보겠습니다.

```js
import { UrlBuilder } form './urlBuilder.js'

const url = new UrlBuilder()
	.setProtocol('https')
	.setAuthentication('user', 'pass')
	.setHostname('example.com')
	.build()

console.log(url.toString())
```

보이는 것처럼, 코드의 가독성이 크게 향상되었습니다.
각 `setter` 함수는 우리가 설정하는 매개 변수에 대한 힌트를 명확히 제공하며, 그 외에도 이러한 매개 변수를 설정하는 방법에 대한 지침을 제공합니다.

:::note 빌더 패턴은 대상 클래스를 직접 구현할 수도 있습니다.
- 예를 들어 별도의 `UrlBuilder` 클래스를 사용하는 대신 빈 생성자(객체 생서잇 유효성 검사 없음)와 다양한 구성요소에 대한 setter 함수를 추가하여 Url 클래스를 재구성 할 수 있습니다.
- 하지만 이와 같은 접근 법은 큰 결함이 존재합니다.
- 대산 클래스와 분리된 빌더를 사용하면 항상 일관된 상태를 보장하는 인스턴스를 만들 수 있다는 장점을 가질 수 있습니다.
- 예를 들어 `UrlBuilder.build()`에서 반환된 모든 Url 객체에 유효하고 일관된 상태를 보장합니다.
- 이러한 객체에서 `toString()`을 호출하면 항상 유효한 URL 이 반환됩니다..
- Url 클래스에 직접 빌더 패턴을 구현한 경우에는 동일한 결과 일 것이라고 확답할 수 없습니다.
- 실제로 이 경우 다양한 URL 구성 요소를 설정하는 동안 `toString()`을 호출하면 반환된 값이 유효하지 않을 수 있습니다.
- 이는 부가적인 검증을 추가하여 완화할 수 있지만, 복잡성이 늘고 비용이 증가합니다.

:::

빌더 패턴은 복잡한 객체를 생성하거나 복잡한 함수를 호출하는 문제에 대해 매우 우아한 해결책을 제공하기 때문에 NodeJS 및 JavaScript 에서 매우 일반적인 패턴입니다.

완벽한 예시중 하나가 http와 https 에서 내장된 `requests()` API로 HTTP(S) 클라이언트 요청을 생성하는 것입니다. [관련 문서](https://nodejs.org/api/http.html#http_http_request_url_options_callback)를 살펴보면 많은 옵션을 허용한다는 것을 바로 알수 있습니다.
이는 빌더 패턴이 잠재적으로 더 좋은 인터페이스를 제공할수 있다는 일반적인 예시 입니다.

실제로 가장 인기있는 HTTP(S) 요청에 대한 래퍼 중 하나인 [superagent](https://www.npmjs.com/package/superagent)는 빌더 패턴을 구현해 새로운 요청의 생성을 단순화 하는 것을 목표로 하여, 따라서 단계적으로 새로운 요청을 생성하는 훌륭한 인터페이스를 제공합니다.

```js
superagent
	.post('https://example.com/api/person')
	.send({ name: 'john Doe', role: 'user'})
	.set( 'accept'. 'json')
	.then((response)=>{
		// 응답을 처리 하는 부분
	})
```

앞의 코드에서 이것이 특이한 빌더라는 것을 알 수 있습니다.
실제로 `build()` 또는 `invoke()` 함수가 없고 (혹은 그와 유사한 목적의 비슷한 함수 조차 없습니다.) `new` 연산자를 사용하지 않았습니다.
대신 요청을 실행시키는 것은 `then()`함수에 대한 호출입니다.

`superagent` 요청은(request) 객체가 프라미스가 아니라 `then()` 함수가 빌더 객체를 통해 만들어진 요청을 실행하게 하는 `thenable` 이라는 점에서 흥미롭습니다.


# 공개 생성자

공개 생성자 패턴은 4인조가 쓴 책에서 찾을 수 없는 패턴 중 하나 입니다.
JavaScirpt 와 NodeJS 의 커뮤니티에서 직접 유래했기 때문입니다.

이것은 객체가 생성되는 순간에만 객체의 내부적인 기능의 일부를 노출 시킬까? 하는 매우 까다로운 문제를 해결합니다.
이것은 객체의 내부가 생성단계에서만 조작되도록 허용하려는 경우, 특히 유용합니다.
이를 통해 다음과 같은 몇가지 흥미로운 시나리오가 가능합니다.
- 생성시에만 수정할 수 있는 객체의 생성
- 생성시에만 사용자 정의 동작을 정의할 수 있는 객체 생성
- 생성 시 한번만 초기화 할 수 있는 객체 생성

이것은 생성자 패턴으로 할 수 있는 몇 가지 상황에 불과합니다.
사용 가능한 사례를 더 잘 이해하기 위해 다음과 같은 코드의 일부를 보고 이 패턴이 무엇인지 살펴보겠습니다.

```js
const object = new SomeClass(function executor(revealMEmbers){
	// 멤버 변수 조작 코드 ...
})
```

앞의 코드에서 볼 수 있듯이 공개 생성자 패턴은 세가지 기본 요소로 구성됩니다.
생성시 호출 되는 함수를 입력으로 받는 생성자 함수에 전달되는 객체 내부의 필요 변수들
패턴이 동작하려면 객체가 생성된 후에, 객체의 사용자가 공개된 함수에 접근 할 수 없어야 합니다.

이는 팩토리 패턴과 관련하여 전장에 언급한 캡슐화 기술 중 한가지를 사용하여 만들 수 잇습니다.

:::tip [Domenic Denicola 의 블로그 게시물 링크](https://blog.domenic.me/the-revealing-constructor-pattern/)에서 패턴을 정의하고 이름을 처음으로 정했습니다.

:::

이제 노출 생성자 패턴이 어떻게 작동하는지 더 잘 이해하기 위해 몇 가지 예를 살펴보겟습니다.

## 변경 불가능한 버퍼 만들기
변경 불가능한 객체와 데이터 구조는 수 많은 상황에서 변경 가능한 (mutable) 객체와 데이터 구조를 대신하여 사용하기에 이상적인 훌륭한 속성들을 가지고 있습니다.

변경 불가능(Immutable) 이란 객체가 생성된 후, 데이터나 상태를 수정할 수 없게 되는 객체의 특성을 의미합니다.
변경 불가능한 객체를 사용하면 다른 라이브러리나 함수로 전달하기 전에 원본이 변하는 것을 막기 위해 복사본을 만들 필요가 없습니다.

우리가 알지 못하거나 제어할 수 없는 코드로 전달되는 경우에도 수정되지 않는 다는 것을 확실히 보장할 수 있습니다.

변경 불가능한 객체를 수정하는 것은 새로운 복사본을 통해서 만 가능하며, 이는 값의 변경 이유를 명확히 하여 코드의 유지 보수를 더 쉽게 합니다.
변경 불가능한 객체의 또 다른 일반적인 사례는 변경을 효율적으로 감지할 수 있다는 것입니다.
모든 변경에 복사본이 필요하고, 복사본을 통해 수정된다고 가정한다면 변경을 감지하는 것은 간단하게 완전 항등 연산자를 사용하면 됩니다.

이제 여기서, 변경 불가능한 [NodeJS Buffer 컴포넌트](https://nodejs.org/api/buffer.html)를 공개 생성자 패턴을 사용하여, 만들어 보도록 하겠습니다.
이 패턴을 사용하면 생성 시에만 변경 불가능한 버퍼를 조작할 수 있습니다.
다음과 같이 `immutableBuffer.js` 라는 새로운 파일에서 변경 불가능한 버퍼를 구현해보겠습니다.

```js
const MODIFIER_NAMES = ['swap', 'write' ,'fill']

export class ImmutableBuffer{
	constructor(size, executor){
		const buffer = Buffer.alloc(size) // 1
		const modifiers = {}  // 2
		for(const prop in buffer){  // 3
			if(typeof buffer[prop] !== 'function'){
				continue
			}
		}
		if(MODIFIER_NAMES.some (m=>prop.statrWith(m))){ //4
			modifiers[prop] = buffer[prop].bind(buffer)
		}else{
			this[prop] = buffer[prop].bind(buffer) // 5
		}

		executor(modifiers) // 6
	}

}
```


이제 새로 만든 ImmutableBuffer Class가 어떻게 작동하는지 살펴보겠습니다.
1. 먼저 생성자의 인자에 지정된 크기의 새로운 NodeJS 버퍼(buffer)를 할당합니다.
2. 그런 다음, Buffer를 변경할 수 있는 함수들을 보관하는 객체 리터럴(modifiers)을 만듭니다.
3. 그 후, buffer 내부의 모든 속성들을 차례차례 살려보면서 함수가 아닌 속성을 건너뜁니다.
4. 다음으로 속성이 함수 이면서, 이름 MODIFIER_NAMES 배열에 있는 이름 중 하나인지 살펴봄으로써 현재의 속성이 버퍼를 수정할 수 있는 함수인지 식별합니다.
	1. 만일 맞는다면, buffer 인스턴스에 바인드 한 후 modifiers 객체에 추가합니다.
5. 끝으로, 생성자에서 입력으로 받은 실행 함수를 호출하면서 인자로 modifier 객체를 전달하면 실행함수가 내부 buffer를 변경할 수 있습니다.

실제로, ImmutableBuffer는 사용자와 내부 buffer 객체 사이에서 프록시 역할을 합니다.
buffer 인스턴스의 일부 함수는 ImmutableBuffer 인터페이스(주로 읽기 전용)를 통해 직접 호출되는 반면, 다음 함수들은 실행 함수(modifiers 내 함수)에 전달합니다.

:::note 여기서 공개 생성자 패턴의 예시를 위해 변경 ImutableBuffer의 구현은 많은 생략을 하였음을 유의하세요
- 예를 들어, 버퍼의 크기를 알아보거나, 초기화 할 수 있는 다른 함수들을 제공하지 않고 있습니다.

:::

이제 새로운 ImmutableBuffer 클래스를 사용하는 방법을 보여주는 코드를 작성해 봅시다.
다음 코드가 포함된 새로운 `index.js` 파일을 만들어 보겠습니다.

```js
import { ImmutableBuffer } from './immutableBuffer.js'

const hello = 'Hello!'
const immutable = new ImmutableBuffer(hello.length,
	({ write })=>{ // 1
		write(hello)
	})
console.log(String.fromCharCode(immutable.readInt8(0)))

// 다음과 같이 에러가 발생합니다.
// TypeError : immutable.write is not a function

// immutable.write('Hello?')
```

이전 코드에서 가장 먼저 주목할 것은 실행 함수가 `write()` 함수(수정을 위한 일부 함수들)를 사용하여 문자열을 `buffer(1)` 쓰는 방식입니다.
비슷한 방식으로 실행함수는 `fill()`, `writeLnt8()`, `swap16()` 또는 modifiers 객체를 통해 공개된 다른 함수들을 사용할 수 있습니다.
이 코드를 보면 코드는 새로운 ImmutableBuffer 인스턴스가 `readInt8()` 2번처럼 buffer를 변경하지 않는 함수들은 공개하지만, buffer의 내용을 변경하는 함수들을 노출하지 않는다.

공개 생성자 패턴은 매우 강력한 보장을 제공하는데, 이러한 이유로 주로 완벽한 캡슐화를 제공해야 하는 경우 사용됩니다.
수십만개의 개발자들이 사용 하는 컴포넌트로, 고정된 인터페이스로 엄격한 캡슐화를 제공 해야하는 컴포넌트 일 경우, 이 패턴은 완벽 하게 적용할 수 있습니다.

또한 이 프로젝트 패턴을 사용하여 안정성을 높이고 다른 사람 혹은 팀과의 코드 공유를 단순화 할 수 있습니다.(제 3자가 객체를 더 안전하게 사용할 수 있기 때문입니다.)

공개 생성자 패턴에서 대표적인 프로그램은 JavaScript Promise 클래스 입니다.
여러분 중 일부는 일부 눈치 채셨을 것입니다.
새로운 프라미스를 만들 때 생성자는 Promise를 만들 때, 생성자는 Promise의 내부 상태를 변경하는데 사용되는 `resolve()`및 `reject()` 함수를 인자로 하는 실행 함수를 입력으로 받습니다.

이것은 다음과 같은 형태를 가집니다.

```js
return new Promise((resolve, reject)=>{
	// ...
})
```

일단 생성되면 Promise 의 상태를 변경할 수 있는 방법이 없습니다.
우리가 할수 있는 일은 5장에서 배운 방법을 통해 이행 fulfillment 값이나 거부 reject 이유를 수신하는 것 뿐입니다.

# 싱글톤

이제 객체 지향 프로그래밍에서 가장 많이 사용되는 패턴인 싱글톤 패턴에 대해 몇 가지 이야기해봅시다.
앞으로 보게 되겠지만, 싱글톤 NodeJS 에서 논의할 가치가 거의 없는 사소한 구현 패턴 중 하나입니다.

그러나 여기에도 좋은 NodeJS 개발자가 알아야할 몇 가지 주의사항과 제약사항이 있습니다.

싱글톤 패턴의 목적은 클래스의 인스턴스가 하나만 존재하도록 접근을 중앙 집중화하는 것입니다.
애플리케니션의 모든 컴포넌트가 단일 인스턴스를 사용하는 데 몇 가지 이유가 있습니다.
- 상태 정보의 공유
- 리소스 사용의 최적화
- 리소스에 대한 접근 동기화

상상할 수 있듯이, 이는 매우 일반적인 시나리오 입니다.
데이터 베이스에 대한 접근을 제공하는 일반적인 Database 클래스로 예를 살펴보겠습니다.

```js
// 'Database.js'
export class Database{
	constructor(dbName, connectionDetails){
		// ...
	}
	// ...
}
```

이러한 클래스의 전형적인 구현은 일반적으로 연결  풀(`connection pool`)을 유지하므로 각 요청에 대해 새로운 Database 인스턴스를 만드는 것은 의미가 없습니다.
더욱이, Database 인스턴스는 대기중인 트랜잭션 목록 같은 일부 상태 정볼르 저장할 수 있습니다.
따라서 Database 클래스는 싱글톤 패턴을 적용하기 위해 두 가지 기준을 충족하고 있습니다.

우리가 원하는 일반적인 기능은 애플리케이션 시작 시 하나의 Database 인스턴스를 설정하고 만들어, 모든 컴포넌트가 하나의 대상 Database 인스턴스를 공유하도록 하는 것 입니다.

NodeJS 를 처음 접하는 많은 사람들이 싱글톤 패턴을 올바르게 구현하는 방법에 대해 혼란스러워 합니다.
그러나 해답은 우리가 생각하는 것보다 쉽습니다.
모듈에서 인스턴스를 export 하는 것만으로도 이미 싱글톤 패턴과 매우 유사한 것을 얻을 수 있습니다.
예를 들어 다음과 같은 코드를 생각해봅시다.

```js
// file 'dbInstance.js'
import { Database } from './Database.js'

export const dbInstance = new Database('my-app-db',{
	url: 'localhost:5432',
	username: 'user',
	password: 'password'
})
```

단순히 데이터베이스 클래스의 새로운 인스턴스를 내보내는 것으로, 이미 현재 패키지 내에(쉽게 전체 애플리케이션일 수도 있습니다.) `dbInstance` 모듈의 인스턴스가 하나만 존재한다고 가정할 수 있다.
2장에서 알 수 있듯이, NodeJS 모듈을 캐시하여 불러올 때마다 코드를 다시 읽어들이지 않도록 합니다.

예를 들어 다음 코드 라인을 사용하여 앞에서 정의한 `dbInstance` 모듈의 공유된 인스턴스를 쉽게 얻을 수 있습니다.
```js
import { dbInstance } from './dbInstance.js'
```

그러나 주의할 점이 있습니다.
모듈 전체 경로를 키로 하여 캐시되므로 현재 패키지 내에서 싱글톤이라는 것이 보장됩니다.
사실 각 패키지는 자신의 `node_modules` 디렉터리 내에 자체적인 일련의 종속성을 가질 수 있습니다.
이로 인해 동일한 패키지의 여러 인스턴스가 생성되어 싱글톤이 더 이상 고유성을 보장하지 못합니다.

물론 드문 시나리오 이지만, 그 결과가 무엇인지 이해 하는 것은 중요 합니다.

예를 들어 앞서 살펴본 `Database.js` 및 `dbInstance.js` 파일이 mydb 라는 패키지에 싸여져 있을 경우를 생각해봅시다.
다음 코드는 `package.json` 내에 존재 합니다.

```json
{
	"name": "mydb",
	"version": "2.0.0",
	"type": "module",
	"main": "dbInstance.js",
}
```

다음으로 두 개의 패키지(`pakage-a`와 `package-b`)를 살펴봅시다.
두 패키지에는 다음 코드가 포함된 `index.js`라는 파일이 있습니다.

```js
import { dbInstance } from 'mydb'

export function getDbInstance(){
	return dbInstance
}
```

`package-a`와 `package-b`는 모두 mydb 패키지에 종속성이 있습니다.
그러나 `package-a`는 mydb 패키지 1.0.0에 종속성이 있는 반면, `package-b` 는 동일한 패키지의 버전 2.0.0에 종속성이 있습니다.(이 예에서는 package.json 파일에 서로 다른 버전이 지정되어 있지만, 구현은 동일)

지금까지 설명한 구조를 보면 결국 다음과 같은 패키지 종속성 트리가 만들어집니다.

```shell
app/
 -- node_moddules
	|-- package-a
	|	| -- node_modules
	|	|	| -- mydb
	| -- package-b
	|	| -- node_modules
	|	|	| -- mydb
```

결과적으로  package-a와 package-b는 mydb 모듈의 서로 다른 두 가지 버전을 사용하기 때문입니다.
(예를 들어 1.0.0, 2.0.0 ), 이 경우 `npm` 또는 `yarn` 과 같은 일반적인 퍀티지 관리하는 최상위 `node_modules`  디렉터리에서 종속성을 가져오지 않는 대신, 버전의 호환성을 맞추기 위해 각 패키지에 사본을 설치합니다.

방금 본 디렉터리 구조를 사용하면 package-a와 package-b 모두 mydb 패키지에 종속성이 있습니다.
루트 패키지(app)는 다시 package-a 와 package-b 에 종속성을 가집니다.

이 시나리오는 Database 인스턴스가 고유하다는 가정을 무너뜨릴 것입니다.
실제 app 패키지의 루트폴더에 있는 `index.js` 파일을 살펴봅시다.

```js
import { getDbInstance as getDbFromA } from 'pacakge-a'
import { getDbInstance as getDbFromB } from 'package-b'

const isSame = getDBFromA() === getDbFromB()
console.log(`Is the db instance in package-a the same as package-b? ${isSame ? 'YES' : 'NO'}`)
```

이 파일을 실행하면 여러분은 package-a의 db 인스턴스와 package-b의 그것과 동일한가? 하는 질문의 답이 아니오 라는 것을 알 수 있을 것입니다.
실제로 mydb 모듈은 필요로 하는 패키지에 따라 다른 디렉터리로 해석되기 때문에, package-a 와 package-b는 서로 다른 dbInstance 객체의 인스턴스를 로드합니다.
이것은 분명 싱글톤 패턴의 가정을 무너뜨립니다.

:::tip 만일 `package-a`와 `package-b` 가 서로 호환되는 두 버전의 mydb 패키지를 필요로 하는 경우
- 패키지 관리자는 Mydb 패키지를 최상위 node_modules 디렉터리에 설치하고 (종속성 호이스팅)이라고 알려진 관행입니다.
- 동일한 인스턴스를 `package-a`와 `package-b`그리고 루트 패키지가 효과적으로 공유하돌고 합니다.


:::

여기서 우리는 다음과 같이 명시적으로 글로벌 변수를 사용하지 않는 한, 문헌에 기술된 대로의 싱글톤 패턴은 NodeJS 에 존재하지 않는 다는 것을 쉽게 이해할 수 있습니다.

```js
global.dbInstance = new Database('my-app-db', { /*...*/})
```

이렇게 하면 인스턴스가 패키지 내에서가 아닌 전체 애플리케이션에서 공유되는 유일한 인스턴스임을 보장할 수 있습니다.
그러나 대부분의 경우 순수한 싱글톤이 필요하지 않다는 것을 이해할 필요가 있습니다.
NodeJS는 일반적으로 애플리케이션의 메인 패키지나 최악의 경우라 하더라도 모듈화된 하위 컴포넌트부터 싱글톤으로 생성하여 임포트 합니다.

:::tip 이 섹션에서 이야기한 문제를 피하기 위해서는 다들 애플리케이션이 사용할 패키지를 만들경우, 무 상태를(stateless)를 유지하십시오

:::

이 책 전체에서 비록 용어의 엄격한 정의 에서 싱글톤이 아니더라도, 모듈에 의해 익스포트된 클래스 인스턴스 또는 무상태 객체를 설명하기 위해 싱글톤이라는 용어를 사용합니다.

다음으로, 모듈간의 종속성을 처리하는 주요한 두가지 방식을 살펴보겠습니다.
하나는 싱글톤 패턴에 기반하고 다른 하나는 종속성 주입(DI) 패턴을 사용 하는 것입니다.

## 모듈 와이어링
모든 애플리케이션은 여러 컴포넌트를 연결한 결과이며, 애플리케이션이 커짐에 따라 이러한 컴포넌트들을 연결하는 방식은 프로젝트의 유지보수 및 성송을 위한 중요한 요인이 됩니다.

컴포넌트A가 주어진 기능을 수행하기 위해 컴포넌트 B를 필요로 할 때, A는 B에 종속적입니다.
라고 하거나, 반대로 B는 A의 종속성이라고 합니다.

이 개념을 이해하기 위해 예를 들어 보겠습니다.

데이터를 저장하는데 데이터베이스를 사용하는 블로깅 시스템을 위한 API를 만든다고 가정해 보겠습니다.
데이터베이스 연결(`db.js`) 을 구현하는 일반 모듈과 데이터 베이스에 블로그의 게시물을 저장하고 검색하는 주요 기능을 가진 블로그 모듈(`blog.js`)이 있을 수 있습니다.

다음 그림은 데이터베이스 모듈과 블로그 모듈의 관계를 보여줍니다

![Diagram.svg](/img/이미지 창고/Diagram.svg)

이 장에서는 싱글톤 패턴과 종속성 주입 패턴을 사용 하는 서로 다른 두 가지 접근 방법을 사용 하여 이 종속성을 모델링 하는 방법을 살펴 보겠습니다.

### 싱글톤 종속성
두 모듈을 서로 연결하는 가장 간단한 방법은 NodeJS 의 모듈 시스템을 활용하는 것입니다.
이런 식으로 상태 저장 종속성들을 묶는 방식은 앞서 이야기 했던 것 처럼 사실상 싱글톤입니다.

실제로 어떻게 작동하는지 보기 위해 데이터 베이스 연결을 위한 싱글톤 인스턴스를 사용하여 앞서 설명한 간단한 블로깅 애플리케이션을 구현해봅시다.
이 방식으로 가능한 구현의 한 예를 살펴봅시다.

```js
import { dirname, join } from 'path'
import { fileURLToPath } from 'url'
import splite3 from 'splite3'

const __dirname = dirname(fileURLToPath(import.meta.url))
export const db = new splite3.Database(join(__dirname, 'data.sqlite'))
```

앞서 코드에서는 게시물을 저장하기 위해 SQLite를 데이터 베이스로 사용합니다.
SQLite와 연동하기 위해 npm 의 splite3 모듈을 사용하고 있습니다.

SQLite는 모든 데이터를 하나의 로컬 파일에 보관하는 데이터 베이스 시스템입니다.
데이터베이스 모듈에서는 모듈과 동일한 폴더에 저장된 `data.sqlite`라는 파일을 사용하기로 했습니다.

앞의 코드는 데이터 파일을 가리키는 데이터베이스의 새로운 인스턴스를 만들고 데이터베이스 연결 객체를 db라는 이름의 싱글톤으로 내보냅니다.

이제 `blog.js` 모듈의 구현을 살펴보겠습니다.

```js
import { promiseify } from ‘util’
import { db } from ’./db.js’

const dbRun = promisify(db.run.bind(db))
const dbAll = promisify(db.run.bind(db))

export class Blog{
	initialize(){
		const initQuery = `CREATE TABLE IF NOT EXISTS posts(
			id TEXT PRIMARY KEY,
			title TEXT NOT NULL,
			content TEXT,
			created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
		);`

		return dbRun(initQuery)
	}


	createPost(id, title, content, createdAt){
		return dbRun(‘INSERT INTO posts VALUES (?,?,?,?)’, id, title, content, createdAt)
	}


	getAllPosts(){
		return dbAll(`SELECT * FROM posts ORDER BY created_at DESC`)
	}
}
```

`blog.js` 모듈은 다음 세 가지의 함수를 가지는 Blog라는 클래스를 내보냅니다.

- `initalize()` : posts 테이블이 없는 경우 테이블을 생성합니다.
	- 이 테이블은 블로그의 게시물 데이터를 저장하는데 사용됩니다.
- `createdPost()` : 게시물을 생성하는데, 필요한 모든 파라미터들을 취합니다.
	- INSERT 문을 실행해서 새로운 게시물을 데이터베이스에 추가합니다.
- `getAllPosts()`: 데이터 베이스에서 사용 가능한 모든 게시물을 검색하고 이를 배열로 반환합니다.
 
방금 만든 블로그 모듈이 기능을 시험해 볼 모듈을 만들어 봅시다.

```js
import { Blog } from ‘./blog.js’

async function main(){
	const blog = new Blog()
	await blog.initialize()
	
	const posts = await blog.getAllPosts()
	if(posts.length === 0){
		console.log(‘No post avaliable. Run `node import-posts.js` to load some sample posts’)
	}

	for (const post of posts){
		console.log(post.title)
		console.log(‘-‘.repeat(post.title.length))
		console.log(`Published on ${new Date(post.created_at}).toISOString()}`)
		console.log(post.content)
	}
}

main().catch(console.error)
```

이 모듈은 매우 간단합니다.
`blog.getAllPosts()` 를 사용하여 모든 게시물을 가진 배열을 조회한 후 배열을 루프 돌면서 각 게시물을 간단한 형식으로 출력합니다.

여러분은 데이터베이스 몇몇 샘플 게시물을 저장하기 제공된 `import-post.js` 모듈을 사용할 수 있습니다.
`import-posts.js` 모둘은 이 책의 샘플 코드들의 레포지토리에서 다른 파일들과 함께 찾아볼 수 있습니다.

앞의 코드에서 알수 있듯이, 싱글톤 패턴을 활용하여 db 인스턴스를 전달함으서 매우 간단한 커맨드라인 용 블로그 관리 시스템을 구현할 수 있습니다.
이것이 많은 경우에서 애플리케이션의 상태 저장 종속성을 관리하는 방식입니다.

그러나 이것이 충분하지 않을 수도 있습니다.
앞서 예제에서 했던 것처럼 싱글톤을 사용하는 것은 확실히 상태 기반 종속성을 전달하는 가장 간단하며서 즉각적이며, 가독성 높은 해결책입니다.

하지만, 테스트 중에 데이터베이스의 모조를 가지고 동작하려면 어떻게 해야할까요?
이런 경우, 싱글톤은 적절하게 구조회된 해결책을 구현하는데 장애물이 될 수 있습니다.


우리는 `db.js` 모듈에 if 문을 도입함으로써 어떤 환경 조건 또는 설정에 따라 다른 구현을 선택하도록 할 수 있습니다.
혹은 NodeJS 모듈 시스템을 조작하여 데이터베이스 파일 임포트를 가로채서 다른 것으로 바꿀 수 도 있습니다.
하지만 여러분이 상상해 볼 수 있듯이 이러한 해결책은 그리 좋은 방법이 아닙니다.

## 종속성 주입(DI)
NodeJS 모듈 시스템과 싱글톤 패턴은 애플리케이션의 컴포넌트 드르이 구조화하고 연결하는 훌륭한 도구의 역할을 할 수 있습니다.

그러나 이것이 항상 성공을 보장하는 것은 아닙니다.
한편으로는 사용하기 쉽고 매우 실용적이지만, 다른 한편으로는 컴포넌트 간의 결합을 강하게 만들 수 있습니다.

이 전 예시의 `blog.js` 모듈이 `db.js` 모듈과 밀접하게 결합되어 있음을 알 수 있습니디.
실제, `blog.js` 모듈은 설계 `db.js` 모듈 없이는 동작할 수 없으며, 필요한 경우 다른 데이터베이스 모듈을 사용할 수도 없습니다.

DI 패턴을 활용하면 두 모듈 간의 긴밀한 결합을 간단하게 수정할 수 있다.

**종속성 주입 (Dependency Injection)** 은 컴포넌트들의 종속성들이 종종 **인젝터(injector)** 라고 하는 외부 요소에 의해 공급되는 매우 간단한 패턴입니다.

인젝터는 다른 컴포넌트를 초기화 하고 종속성들을 함께 연결합니다.
이것은 간단한 초기화를 위한 스크립트일 수도 모든 종속성을 맵핑하여 시스템의 모든 모듈들을 연결을 중앙 집중화 하는 보다 복잡한 전역 컨테이너일 수도 있습니다.

이 접근 방식의 주요 장접은 향상된 디커플링인데, 특히 상태 저장 인스턴스 (예: 데이터베이스 연결)에 대한 종속성을 가진 모듈들에 유효합니다.

DI를 사용하면 각 종속성이 모듈에 하드코딩되는 대신 외부에서 주입됩니다.
즉, 종속 모듈은 호환 가능한 종속성을 사용하도록 설정할 수 있으므로, 최소하느이 노력으로도 다른 컨텍스트에서 재 사용할 수 있습니다.

아래 그림은 이 개념을 보여줍니다.
일반적인 서비스가 미리 결정된 인터페이스를 통해 종속성을 연결하는 것을 볼 수 있습니다.
이 인터페이스의 구체적인 구현체에 대한 인스턴스를 조회하고 생성한 후 서비스에 전달(주입) 하는 것은 인젝터가 담당합니다.

즉 인젝터는 서비스에 대한 종속성을 충족하는 인스턴스를 제공하는 것을 목표로 합니다.

![Pasted-image-20250506221338.png](/img/이미지 창고/Pasted-image-20250506221338.png)

이 패턴을 실제로 살펴보기 위해, 앞서 만들어본 간단한 블로깅 시스템이 DI 를 사용하여 모듈을 연결하도록 리팩토링 해보겠습니다.
`blog.js` 모듈의 리팩토링에서 시작해 봅시다.

```js
import { promisify } from ‘util’

export class Blog{
	constructor(db){
		this.db = db
		this.dbRun = promisify(db.run.bind(db))
		this.dbAll = promisify(db.all.bind(db))
	}

	initialize(){
		const initQuery = `CREATE TABLE IF NOT EXISTS posts(
			id TEXT PRIMARY KEY,
			title TEXT NOT NULL,
			content TEXT,
			created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMPK
		);`
	}
	return this.dbRun(initQuery)

	createPost(id, title, content, createAt){
		return this.dbRun(‘INSERT INTO posts VALUES(?,?,?,?)’, id, title, content, createdAt)
	}

	getAllPosts(){
		return this.dbAll{
			`SELECT * FROM posts ORDER BY created_at DESC`
		}
	}
}
```

새로운 버전을 이전의 것과 비교하면 거의 동일합니다.
사소한 두 가지 차이점을 볼 수 있습니다.

- 더 이상 데이터베이스 모듈을 임포트 하지 않습니다.
- `Blog` 클래스 생성자는 db를 인자로 취합니다.

새로운 생성자의 인자 DB는 Blog 클래스의 사용자 컴포넌트로부터 실행(runtime)시 제공될 것으로 기대되는 종속성 입니다.
여기서 사용자 컴포넌트는 인젝터가 될 것입니다.
JavaScript는 추상 인터페이스를 표현하는 방법이 없으므로, 제공될 종속성느 `db.run()`,그리고 `db.all()` 함수를 구현해야 합니다.

이 책의 앞부분에 언급했듯이 이를 덕 타이핑이라고 합니다.

이제 `db.js` 모듈을 다시 작성해보겠습니다.
여기서 목표는 싱글톤 패턴을 제거하고 재사용 및 설정이 가능한 구현체를 만드는 것입니다.

```js
import sqlite3 from ‘sqlite3’

export function createDb (dbFile){
	return new sqlite3.Database(dbFile)
}
```

이 새로운 db 모듈의 구현체는 createDb() 라는 팩토리 함수를 제공하여 실행 시 데이터 베이스의 새 인스턴스를 만들 수 있습니다.
또한 필요 시, 다른 파일에 데이터를 쓸 수있는 독립적인 인스턴스를 만들기 위해, 생성시, 데이터 베이스 파일 경로를 전달 할 수 있습니다.

여기가지 거의 모든 구성 블록들이 준비되어 있습니다.
이제 인젝터를 고려해야합니다.
`index.js` 모듈을 다시 구현하여 인젝터의 예를 보도록 합시다.


















