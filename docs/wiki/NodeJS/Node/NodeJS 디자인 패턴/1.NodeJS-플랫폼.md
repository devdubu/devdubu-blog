---
slug: "1.NodeJS-플랫폼"
---
# NodeJS 철학
## 경량 코어
NodeJS는 프로그램 코드를 구성하는 기본 수단으로서 모듈 개념을 사용합니다.
그 중 한가지는 최소한의 기능 세트를 가지고 코어의 바깥 부분에 유저랜드(userland) 혹은 유저스페이스(userspace)라 불리는 사용자 전용 모듈 생태계를 두는 것 입니다.

엄격하게 관리되어 안정적이지만, 느리게 진화하는 해결책을 갖는 대신 커뮤니티가 사용자 관점에서 폭 넓은 해결책을 실험해보리 수 있는 자유를 주었습니다.
코어를 최소한의 기능 세트로 관리하는것은 관리의 관점에서 편리할 뿐 아니라 전체 생태계 진화에 있어 긍정적인 문화적 영향을 미칠 수 있습니다.

NodeJS에서 가장 널리 통용되는 원칙 중 하나는 코드의 양 뿐만 아니라 범위의 측면에서도 작은 모듈을 디자인 하는 것입니다.
이 원칙은 Unix 철학에 근거하는데, 특히 다음 두가지 수칙이 있습니다.
- 작은 것이 아름답다
- 각 프로그램은 한 가지 역할만 잘 하도록 만들어라
NodeJS 는 이 개념을 완전히 새로운 차원으로 끌어올렸습니다.

NodeJS 는 패키지 관리의 도움을 받아 각 패키지가 자신이 필요로하는 버전의 종속성 패키지들을 갖도록 함으로서 종속성 지옥에서 벗어나게 해줍니다.
이러한 측면은 패키지가 충돌의 위험 없이 잘 집중화 되고 많은 수의 작은 종속성을 가질 수 있도록 해줍니다.
다른 플랫폼에서는 비실용적이고, 적용 불가능한 반면, NodeJS에서는 이러한 관행이 표준입니다.

이러한 것이 재사용성 측면을 향상시켜 줍니다.

:::note 작은 모듈 재사용성이라는 장점 외에도 다음의 장점이 있습니다.
- 이해하기 쉽고 사용하기 쉽다.
- 테스트 및 유지보수가 쉽다.
- 사이즈가 작아 브라우저에서 사용하기 편하다.

:::

더 작고 집중화된 모듈을 갖는 것은 모두에게 공유와 재사용을 가능하게 해줍니다.
이것은 완전히 다른 수준에 적용된 Don’t Repeat Yourself(DRY) 원칙입니다.

## 작은 외부 인터페이스
NodeJS의 모듈들이 갖는 장점은 작은 사이즈와 작은 범위 그리고 최소한의 기능 노출 입니다.
이러한 것들이 명확하게 사용될 수 있고, 사용에 덜 노출되도록 하는 API 생산 효과를 갖습니다.

대부분의 경우 컴포넌트 사용자는 기능의 확장을 필요로ㅗ 하거나 부가적인 고급 기능들의 활용 없이 제한되고 집중화된 기능에만 관심이 있습니다.
NodeJS 에서 모듈을 정의하는 가장 일반적인 패턴은 명백한 단일 진입점을 제공하기 위해서 단 하나의 함수나 클래스를 노출 시키는 것 입니다.

NodeJS의 많은 모듈들의 특징 중또 다른 하나는 그들이 확장보다는 사용되기 위해서 만들어 졌다는 것입니다.
확장의 가능성을 금지하기 위해 모듈 내부 접근을 제한한다는 것이 덜 유연하다고 생각되지만, 사실은 usecase를 줄이고, 구현을 단순화 하며, 유지관리를 용이하게 하고, 가용성을 높인다는 장점이 존재합니다.

실제로 이는 내부를 외부에 노출시키지 않기 위해 클래스보다 함수를 노출시키는 것을 선호한다는 것을 의미합니다.

## 간결함과 실용주의
:::tip **Keep It Simple, Stupid(KISS)**
- 단순함이야말로 궁극의 정교함이다.

:::

리차드가브리엘이 그의 에세이에 다음과 같이 말했습니다.

:::quote 디자인은 구현과 인터페이스 모두에서 단순해야 한다.
- 구현이 인터페이스보다 더 단순해야한다는 것은 더욱 중요하다.
- 단순함이 디자인에서 가장 중요한 고려사항이다.

:::

# NodeJS 는 어떻게 작동하는가

NodeJS가 내부적으로 어떻게 동작하는지 이해하게 될 것입니다.
NodeJS가 가진 비동기 특성의 핵심인 리액터 패턴에 대해서 소개 받을 것입니다.

단일 스레드 아키텍쳐와 논블로키이 I/O 같은 주요 개념을 살펴볼것입니다.

## I/O 는 느리다.
I/O는 컴퓨터의 기본적인 동작들 중에서 가장 느리다.
RAM에 접근하는데에는 ns 인 반면에, 디스크와 네트워크 접근하는데에는 ms 가 걸린다.

대역폭도 마찬가지다.
RAM의 전송률은 GB/s 단위로 일관되게 유지되는 반면, 디스크나 네트워크 전송률은 MB/s에서 GB/s까지 다양합니다.
CPU 측면에서는 I/O가 많은 비용을 요구하지 않지만, 보내지는 요청과 작업이 완료되는 순간 사이의 지연이 발생하게 됩니다.

게다가 인간이라는 요소를 고려해봐야합니다.
실제로 사람이 하는 마우스 클릭처럼 애플리케이션의 입력이 일어나느 많은 상황에서 I/O의 속도와 빈도는 기술적인 측면에만 의존하지 않으며, 디스크나 네트워크 보다 느릴 수 있습니다.

### 블로킹 I/O
전통적인 Blocking I/O 프로그래밍에서는 I/O를 요청하는 함수의 호출은 작업이 완료될 때까지 스레드의 실행을 차단합니다.
차단 시간은 디스크 접근의 경우 몇 ms 부터 사용자가 키를 누르는 것과 같은 사용자 액션에 의해서 데이터가 생성되는 경우 몇분까지 소요되기도 합니다.

다음 의사코드는 소켓을 가지고 작업이 수행되는 일반적인 Blocking Thread를 보여줍니다.
```js
// data가 사용가능해질 때까지 스레드를 블로킹
data = socket.read();

// data 사용 가능
print(data)
```

Blocking I/O를 사용하여, 구현된 웹 서버 같층ㄴ 스레드 내에서 여러 연결 처리를 하지 못하는 것은 자명한 일입니다.
소켓의 각각의 I/O 작업이 다른 연결의 처리를 차단하기 때문입니다.

이 문제를 해결하기 위한 전통적인 접근 방법은 각각의 동시 연결을 처리하기 위해서 개별의 스레드 또는 프로세스를 사용하는 것입니다.

이 방법은 I/O 작업이 각각의 스레드에서 처리되기 때문에 I/O작업으로 인해 블로킹 된 스레드가 다른 연결들의 가용성에 영향을 미치지 않습니다.

![Pasted-image-20250131102134.jpg](/img/이미지 창고/Pasted-image-20250131102134.jpg)
위 그림은 관련 연결로부터 새로운 데이터를 받기 위해 유휴 상태에 잇는 각 스레의 처리 시간을 강조하고 있습니다.
예를 들어, 데이터베이스 File System 과 상호작용할 때와 같이 모든 유형의 I/O가 요청 처리를 차단할 수 있다는 것을 생각해보면 I/O 작업의 결과를 위해서 스레드가 꽤 많이 블로킹 되는 것을 알 수 있습니다.

안타깝게도 스레드는 시스템 리소스 측면에서 비용이 저렴하지 않습니다.
메모리는 소모하고 컨텍스트 전환을 유발하여 대부분의 시간도안 사용하지 않는 장시간 실행 스레드를 가지게 됨으로써 귀중한 메모리와 CPU 사이클을 낭비하게 됩니다.

### Non Blocking I/O
대부분의 최신 운영체제는 리소스에 접근하기 위해서 Blocking I/O 외에도 Non Blocking I/O 라고 불리는 다른 메커니즘을 지원합니다.
이 운영모드에서 시스템 호출은 데이터가 읽혀지거나 쓰여지기를 기다리지 않고, 항상 즉시 반환됩니다.

호출 순간에 사용 가능한 결과가 없는 경우, 함수는 단순히 미리 정의된 상수를 반환하여 그 순간에 사용 가능한 데이터가 없다는 것을 알립니다.
예를 들어,Unix 운영체제에서 운영 모드를 Non Blocking 으로 변경하기 위해서 기존 파일 디스크립터를 조작하는 `fcntl()` 함수가 사용됩니다.

우선 리소스가 Non Blocking모드에 있고, 리소스가 읽힐 준비가 된 데이터를 가지고 있지 않다면, 모든 읽기 작업은 실패함과 동시에, 코드 EAGAIN 을 반환합니다.

이러한 종류의 Non Blocking I/O 를 다루는 가장 기본적인 패턴은 실제 데이터가 반환될 때까지 루프 내에서 리소스를 적극적으로 polling 하는 것입니다.
이것을 바쁜 대기(busy-waiting)이라고 합니다.
아래의 의사코드는 Non Blocking 와 polling loop를 사용하여 여러 리소스로부터 읽어 들이는 것이 어떻게 가능한지 보여줍니다.

```js
resouces = [socketA, socketB, fileA]
while(!resources.isEmpty()){
	for(resource of resources){
		// 읽기를 시도
		data = resource.read()
		if(data === NO_DATA_AVAILIABLE){
			// 이 순간에는 읽을 데이터가 없음
			continue
		}
		if(data === RESOURCE_CLOSE){
			// 리소스가 닫히고 리스트에서 삭제
			resouces.remove(i)
		}else{
			// 데이터를 받고 처리
			consumData(data)
		}
	}
}
```

보시시피 간단한 기법으로 서로 다른 리소스를 같은 스레드 내에서 처리 할 수 있지만, 여전히 효율적이지 않습니다.
실제로 앞의 예제에서 루프는 사용할 수 없는 리소스를 반복하는 데에 소중한 CPU 를 사용합니다.

### 이벤트 디멀티플렉싱
Busy waiting은 Non Blocking 리소스 처리를 위한 이상적인 기법이 아닙니다.
다행히도, 대부분의 운영체제는 Non Blocking 리소스를 효츌적인 방법으로 처리하기 위한 기본적인 메커니즘을 제공합니다.

이 메커니즘을 **동기 이벤트 디멀티플렉서** 또는 **이벤트 통지 인터페이스**라고 합니다.

:::tip 멀티플렉싱?
- 전기통신 용어로서 여러신호들을 하나로 합성하여 제한된 수요범위 내에서 매개체를 통하여 쉽게 전달하는 방법을 나타냅니다.

:::

:::tip 디멀티플렉싱?
- 신호가 원래의 구성요소로 다시 분할되는 작업입니다.
- 두 용어는 비디오 처리를 포함한 여러 분야에서 서로 다른 것들을 합성과 분할하는 일반적인 작업을 설명하기 위해서 사용됩니다.

:::

우리가 말하고 있는 동기 이벤트 디멀티플렉서는 여러 리소스를 관찰하고 이 리소스들 중에 읽기 또는 쓰기 연산의 실행이 완료되었을 때 새로운 이벤트를 반환합니다.

여기서 찾을 수 있는 이점은 동기 이벤트 디멀티플렉서가 처리하기 위한 새로운 이벤트가 있을 때 까지 블로킹 된다는 것입니다.

```js
watchedList.add(socketA, FOR_READ)
watchedList.add(fileB, FOR_READ)
while(events = demultiplexer.watch(watchedList)){
	// 이벤트 루프
	for(event of events){
		// 블로킹하지 않으며 항상 데이터를 반환
		data = events.resource.read()
		if(data === RESOURCE_CLOSE){
			// 리소스가 닫히고 관찰되는 리스트에서 삭제
			demultiplexer.unwatch(event.resource)
		}else{
			// 실제 데이터를 받으면 처리
			consumeData(data)
		}
	}
}
```
1. 각 리소스가 데이터 구조(List)에 추가됩니다.
	1. 각 리소스를 특정 연산과 연결합니다.
2. 디멀티플렉서가 관찰될 리소스 그룹과 함께 설정됩니다.
	1. `demultiplexer.watch()`는 동기식으로 관찰되는 리소스들 중에서 읽을 준비가 된 리소스가 있을 때까지 블로킹 됩니다.
	2. 준비된 리소스가 생기면, 이벤트 디멀티플렉서는 처리를 위한 새로운 이벤트 세트를 반환합니다.
3. 이벤트 디멀티플렉서에서 반환된 각 이벤트가 처리됩니다.
	1. 이 시점에서 각 이벤트와 관련된 리소스는 읽을 준비 및 차단되지 않는 것이 보장됩니다.
	2. 모든 이번트가 처리되고 나면, 이 흐를은 다시 이벤트 디멀티플렉서가 처리 가능한 이벤트를 반환하기 전까지 블로킹 됩니다.
	3. 이를 이벤트 루프라고 합니다.

여기서 흥미로운점은 우리가 이 패턴을 이용하면 Busy waiting 기술을 이용하지 않고도, 여러 I/O 작업을 단일 스레드 내에서 다룰 수 있다는 것입니다.
이로서 우리가 디멀티 플렉싱에 대해 논하는 이유가 명확해졌습니다.
우리는 단일 스레드를 사용하여 여러 리소스를 다룰 수 있게 된 것입니다.

아래 사진은 동시에 다중 연결을 다루기 위해 동기 이벤트 디멀티플렉서와 단일 스레드를 사용하는 웹 서버 안에서 어떤 일이 일어나는지 시각화하여 보여줍니다.

![Pasted-image-20250131113106.jpg](/img/이미지 창고/Pasted-image-20250131113106.jpg)
그림에서 보여주듯이 오직 하나의 스레드만을 사용한 것이 동시적 다중 I/O 사용 작업에 나쁜 영향을 미치지 않습니다.
작업은 여러 스레드에 분산되는 대신에 시간에 따라 분산됩니다.

이것이 전체적인 유휴시간을 최소화시키는데 확실한 이점이 있다는 것이 위 그림을 통해서 명확히 나타납니다.
하지만 이것이 이 I/O 모델을 선택한 유일한 이유는 아닙니다.

실제로 스레드만 가지는 것은 일반적으로 프로그래머가 동시성에 접근하는 방식이 이로운 영향을 미치게 됩니다.
이책을 통해서 여러분은 경쟁 상태의 발생 문제와 다중 스레드의 동기화 문제가 없다는 것이 어떻게 우리에게 더 간단한 동시성 전략을 사용하게 해줄 수 있는지 보게 될 것입니다.

### 리액터 패턴
이제 우리는 이전 섹션에서 제시된 알고리즘에 특화된 리액터(Reactor)패턴을 알아보겠습니다.
리액터 패턴의 이면에 있는 주된 아이디어어는 각 I/O 작업에 연관된 핸들러를 갖는다는 것이다.
NodeJS 에서의 핸들러는 콜백함수에 해당합니다.

이 핸들러는 이벤트가 생성되고 이벤트 루프에 의해 처리되는 즉시 호출되게 됩니다.
리액터 패턴의 구조는 다음과 같습니다.

![Pasted-image-20250131132638.jpg](/img/이미지 창고/Pasted-image-20250131132638.jpg)
위 그림은 리액터 패턴을 사용하는 애플리케이션에서 어떤 일이 발생하는지를 보여줍니다.
1. 애플리케이션은 이벤트 디멀티플렉서에 요청을 전달함으로써 새로운 I/O 작업을 생성합니다.
	1. 또한 애플리케이션은 작업이 완료되었을 때 호출될 핸들러를 명시합니다.
	2. 이벤트 디멀티플렉서는 대응하는 이벤트 작업들을 이벤트 큐에 집어 넣습니다.
2. 일련의 I/O 작업들이 완료되면 이벤트 **디멀티플렉서**는 대응하는 이벤트 작업들을 이벤트 큐에 집어 넣었습니다.
3. 이 시점에서 이벤트 루프가 이벤트 큐의 항목들을 순환합니다.
4. 각 이벤트와 관련된 핸들러가 호출 됩니다.
5. 애플리케이션 코드의 일부인 핸들러의 실행이 완료되면 제어권을 이벤트 루프에 되돌려줍니다.
6. 이벤트 큐의 모든 항목이 처리되고 나면 이베늩 루프는 이벤트 디멀티플렉서에서 블로킹 처리 가능한 새 이벤트가 있을 경우 이 과정이 다시 트리거 됩니다.

이제 비동기적 동작이 명확해졌습니다.
애플리케이션은 특정 시점에 리소스로(블로킹 없이) 접근하고 싶다면, 요청과 동시에 작업이 완료되었을 때 호출될 핸들러를 제공합니다.

:::tip NodeJS 애플리케이션은 이벤트 디멀티플렉서에 더 이상 보류중인 작업이 없고 이벤트 큐에 더 이상 처리 중인 작업이 없을 경우 종류됩니다.

:::

우리는 이제 NodeJS 의 핵심에 있는 패턴을 정의 할 수 있습니다.

:::tip Reactor 패턴
- Reactor 패턴은 일련의 관찰 대상 리소스에서 새 이벤트를 사용할 수 있을 때까지 블로킹하여 I/O를 처리하고, 각 이벤트를 관련된 핸들러에 전달함으로써 반응합니다.


:::

---

### Libuv, Node.js의 I/O엔진

각 운영체제는 Linux의 epoll, macOS의 kqueue, Window 의 IOCP(I/O completion port) API와 같은 이벤트 디멀티플렉서를 위한 자체 인터페이스를 가지고 있습니다.
게다가 각 I/O 작업은 동일한 OS 내에서도 리소스 유형에 따라 매우 다르게 동작할 수 있습니다.
예를 들어 Unix에서 일반 파일 시스템은 Non Blocking 작업을 지원하지 않기 때문에, Non Blocking 동작을 위해서는 이벤트 루프 외부에 별도의 스레드를 사용해야 합니다.

서로 다른 운영체제 간의 불일치성은 이벤트 디멀티플렉서를 위해 보다 높은 레벨의 추상화를 필요로 하게 되었습니다.
이러한 이유로 NodeJS 코어 팀이 NodeJS를 주요 운영체제에서 호환되게 해주며, 서로 다른 리소스 유형의 Non Blocking 동작을 표준화하기 위해ㅓ `libuv`라고 불리는 C라이브러리를 만들었습니다.
`Libuv`는 NodeJS 하위 수준의 I/O엔진을 대표하며, 아마도 NodeJS의 구성 요소 중에서 가장 중요하다고 말할 수 있습니다.

Libuv는 기본 시스템 호출을 추상화 하는 것 외에도 리액터 패턴을 구현하고 있으므로, 이벤트 루프의 생성, 이벤트 큐의 관리, 비동기 I/O 작업의 실행 및 다른 유형의 작업을 큐에 담기 위한 API들을 제공합니다.

:::note libuv에 대해 더 많은 것을 알 수 있는 훌륭한 자료로 Nikhi Marathe 가 만든 무료 온라인 책이 있습니다.
- `http://nikhim.github.io/uvbook/`

:::

### NodeJS 를 위한 구성
리액터 패턴과 libuv는 NodeJS의 기분 구성 요소지만 전체 플랫폼의 구축을 위해서는 3개의 구성이 더 필요합니다.
- `libuv`와 다른 저수준 기능들을 랩핑하고 표출 시키기 위한 바인딩 세트
- **V8** 
	- 크롬 브라우저를 위해 구글이 개발한 JavaScript 엔진으로 NodeJS가 매우 빠르고 효율적인 이유 중 하나 입니다.
	- V8은 혁신적인 설계와 속도 그리고 효율적인 메모리 관리로 높은 평가를 받고 있습니다.
- 고수준 NodeJs API를 구현하고 있는 코어 JavaScript 라이브러리


이것으로 NodeJS의 내부 구조를 살피는 것을 마무리 합니다.
이제부터 NodeJS에서 JavaScript로 작업을 할 때 고려 해야 하는 중요한 측면들을 알아보겠습니다.

## NodeJs에서의 JavaScript
우리가 앞서 분석한 아키텍처에서의 한 가지 중요한 점은 NodeJS에서 사용하는 JavaScript는 브라우저에서 사용하는 JavaScript와는 다소 다르다는 것입니다.

가장 눈에 띄는 차이점은 NodeJS는 DOM을 가지고 있지 않으며, window와 document또한 없다는 것입니다.
반면에 브라우저에서는 불가능 하지만, NodeJS는 운영체제에서 기본적으로 제공하는 서비스들에 접근이 가능합니다.
사실 브라우저는 악성 웹 애플리케이션에 의해서 기본 시스템이 손상되지 않도록, 안전 조치가 적용되어 있습니다.

브라우저는 운영체제 리소스에 대해 높은 수준의 추상화를 제공하여, 브라우저 안에서 실행되는 코드를 보유하고 조작하기 쉽게 하기 때문에 불가피하게도 사용에 제한이 있습니다.
NodeJS에서는 사실상 운영체제가 표출하는 거의 모든 서비스에 접근 가능합니다.

NodeJS에서 JavaScript를 사용할 때 명심해야할 것을 살펴보겠습니다.

### 최신 JavaScript를 실행시켜라
브라우저에서 JavaScript를 사용할 때 주된 고충 중에 하나는 우리의 코드가 다양한 장치와 브라우저에서 실행되는 경향이 있다는 것입니다.
다른 브라우저를 사용한다는 것은 JavaScript 런타임이 프로그램 언어와 웹 플랫폼의 최신 특성들 중 몇 가지를 간과할 수 있다는 것을 의미합니다.
다행히도 오늘날에는 트랜스파일러와 폴리필의 사용으로 이러한 무제를 어느정도 줄어들었습니다.
그럼에도 불구하고 이러한 것들은 여러 단점들을 가지고 있으며, 모든 것들이 플러그인으로 대체 가능하지 않다.

NodeJS 에서 애플리케이션 개발 할 때에는 이러한 모든 애로사항들이 적용되지 않습니다.
실제로 NodeJS 애플리케이션이 이미 잘 알려진 시스템이나 NodeJS  런타임 위에서 동작합니다.
이것이 만들어내는 엄청난 차이점은 우리가 JavaScript나 NodeJS의 특정 버전에서 동작 하는 코드를 사용할 수 있다는 것입니다.
그리고 그것이 우리로 하여금 그것을 상용에서 실행시켰을 때 우리가 맞이할 당혹스러움이 없다는 것을 보장해줍니다.

이러한 요인과 함께 NodeJ가 가장 최신 버전의 V8을 가지고 있다는 사실은 우리가 추가적인 소스 변환 단계 없이 확신을 가지고 최신 ECMAScript 사양의 특성들 대부분을 사용 가능하다는 것입니다.

명심해야할 것이 있는데, 서드파티에서 사용되기 위한 라이브러리를 개발한다면, 우리는 여전히 우리의 코드가 다양한 NodeJS 버전에서 실행될 수 있음을 고려해야합니다.
이 경우에 일반적인 패턴은 **LTS**지원 버전 중에서 가장 오래된 것을 기준으로 삼고 package.json에 engines 섹션을 명시하는 것입니다.
패키지 매니저는 사용자가 해당 NodeJS 버전에 호환하지 않는 패키지를 설치하려고 할 때 경고하는 것입니다.

:::note NodeJs 배포에 대해서 더 많은 것을 다음 링크에서 찾을 수 있습니다.
- https://nodejs.org/en/about/releases/
또한 섹션에 대한 참조 사항을 다음의 링크에서 찾을 수 있습니다.
- https://docs.npmjs.com/files/package.json#engines
마지막으로, 각 NodejsJS 버전에서 지원하는 ES 특성은 다음의 링크에서 알 수 있습니다.
- https://node.green/


:::

### 모듈 시스템
JavaScript 가 여전히 어떠한 형식에 대한 공식적인 지원이 없었을 때 NodeJs는 모듈 시스템과 함께 시작했습니다.
본래의 NodeJS 모듈 시스템은 CommonJS로 불렸으며, 내장 모듈 또는 장치의 파일 시스템에 위치한 모듈로부터 외부에 표출된 함수와 변수 그리고 클래스임포트 하기 위해서 require 키워드를 사용합니다.

CommonJS는 JavaScript 세계 전반에 있어서 혁명이었습니다.
클라이언트 사이드 세계에서 코드 번들을 만들고 브라우저에서 쉽게 실행될 수 있게 해주는 Webpack이나 Rollup과 같은 모듈 번들러의 사용과 함께 인기를 얻으며 시작되었습니다.

CommonJS는 개발자들이 다른 SSR 플랫폼 처럼 크고 잘 구조화된 애플리케이션을 만들기 위해서 필수적인 구성요소 였습니다.
오늘날 JavaScript는 소위 ES 모듈 문법이라고 불리는 것을 가지고 있습니다.
이것은 브라우저에서와는 기본적 구현이 다른 것으로 NodeJS 에서는 문법만 상속 받습니다.
실제로 브라우저가 원격에 있는 모듈을 주로 다루는 반면, NodeJS는 현재로는 오직 로컬 파일 시스템에 있는 모듈만 다룰 수 있습니다.

### 운영체제 기능에 대한 모든 접근
이미 언급햇듯이 NodeJS JavaScript 를 사용하지만, 브라우저 영역안에서 실행되지 않습니다.
이것은 NodeJS 가 운영체제에서 기본적으로 제공하는 주된 서비스들에 바인딩 할 수 있게 해줍니다.

예를 들어 우리는 fs 모듈의 도움으로 파일 시스템에 잇는 파일에 접근 가능하며, `net`과 `dgram` 모듈로 애플리케이션이 저수준의 TCP 또는 UDP 소켓을 사용하게 할 수 있습니다.
우리는 HTTPS 서버를 만들수 있고, 표준 암호화와 OpenSSL의 (crypto 모듈을 사용하여) 해시 알고리즘을 사용할 수 있습니다.
또한 우리는 v8 내부 여러 곳에 접근이 가능하며, V8의 다른 문맥 상에서 코드를 실행시킬 수 있습니다.

우리는 (child_process 모듈을 사용하여) 다른 프로세스들을 실행시키거나 전역 변수 process를 사용하여, 우리의 애플리케이션이 돌고 있는 프로세스의 정보를 가져올 수 있습니다.
특히 process 전역 변수로 부터 (process.env를 사용하여) 프로세스에 할당된 환경 변수 목록과 애플리케이션 실행 시 할당된 커맨드라인 인자들을 (`process.argv`를 사용하여) 가져올 수 있습니다.
이 책을 통해 여기에 서술된 많은 모듈들을 사용할 수 있는 기회를 갖게 될 것입니다.
완벽한 참조를 위해서는 NodeJS 공식 문서를 확인해보면 됩니다.

### 네이티브 코드 실행
NodeJS가 제공하는 가장 강력한 능력 중 하나는 네이티브 코드에 바인드 할 수 있는 사용자 측 모듈을 만들어 내는 것이 가능하다는 것입니다.
이것이 C/C++로 이미 만들어져잇거나 새로 만들어진 컴포넌트를 사용할 수 있다는 엄청난 이점을 플랫폼에 부여하게 됩니다.
NodeJS는 N-API 인터페이스의 도움으로 네이티브 모듈을 구현하는데 있어서 강력한 지원을 하고 있습니다.

어떠한 이점이 있을까요?

그것은 바로 우리가 작은 노력으로도 이미 존재하고 있는 막대한 양의 오픈 소스를 재사용할 수 있으며, 더 중요한 점은 기업이 그것을 바꾸어 적용할 필요 없이 C/C++ 레거시들을 재사용할 수 있게 해준다는 것입니다.

또 고려해봐야 하는 중요한 점 하나는 하드웨어 드라이브나 하드웨어 포트의 저수준 특성들에 접근이 여전히 필요하다는 것입니다.
NodeJS 는 네이티브 코드와 연결될 수 있는 능력 덕분에 사물인터넷이나 홈메이드 로보틱스 세계에서 점차 인기를 얻고 있습니다.

마지막으로 V8은 JavaScript 실행에 있어서 매우 빠르게 동작하지만 네이티브 코드와 비교 했을 때, 여전히 수행 능력에 손실이 따릅니다.
일상에서 컴포너를 사용할 대에는 드문 문제일 수 있지만, 엄청난 야의 데이터를 처리하고 조작하여 네이티브 코드에 위임하는 CPU 집약적 애플리케이션의 경우에는 충분히 마주칠 수 있는 문제입니다.

또 언급해야 할 것이 있는데, 현재 NodeJS 를 포함한 대부분의 JavaScript 가상머신은 JavaScript 이외의 언어(C++ 또는 Rust) 를 JavaScript VM들이 이해 가능한 형식으로 컴파일 할 수 있게 해주는 저수준 명령 형식인 WASM를 지원합니다.

:::tip 이 프로젝트의 [공식 웹사이트](https://webassembly.org/)에서 Wasm에 대해 더 많은 것을 배울 수 있습니다.

:::

---

#NodeJS #ApplicationArcithecture 

---