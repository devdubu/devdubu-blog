---
slug: "주문-데이터-분석"
---
# 데이터 탐색
## 주문 테이블 컬럼 상세 설명
| 컬럼명            | 의미    | 수식                      |
| -------------- | ----- | ----------------------- |
| price          | 판매가격  |                         |
| unitsold       | 판매수량  |                         |
| GMV            | 거래액   | unitsold * price        |
| product_profit | 상품 이익 |                         |
| discount       | 할인액   |                         |
| total_profit   | 총 이익  | product_profit-discount |
## 상품 매출 확인
```sql
-- 상품별 매출액 집계후, 매출 액이 높은 순으로 정렬하기
select itemid, sum(gmv) as gmv
from online_order oo
group by 1

-- 상품이름을 상품 ID와 나란히 놓아서 한눈에 상품별 매출액을 확인 하 룻 있도록 하기
select item_name, sum(gmv) as gmv
from online_order oo
join item i on oo.itemid = i.id
group by 1
order by 2 desc

-- 카테고리별 매출액은 어떻게 될까?
select c.cate1, c.cate2, c.cate3, sum(gmv) as gmv
from online_order oo
join item i on oo.itemid = i.id
join category c on i.category_id = c.id
group by 1,2,3
order by 4 desc

-- 구매 고객의 성연령 분석
select from ui.gender, ui.age_band, sum(gmv) as gmv
from online_order oo
join user_info ui on oo.userid = ui.userid
group by 1,2
order by 1,2
```

:::success JOIN이 필요한 이유?
- 필요한 정보가 각기 다른 테이블에 분산 저장이 되어있을 때, 이를 하나의 테이블로 가져와 보기 좋게 데이터를 추출하기 위해

:::

- Join 의 위치 및 문법
```sql
select 컬럼명
from 테이블명 as a
join 테이블명2 as b on a.컬럼명 = b.컬럼명
```
:::warning 주의 사항
- 두 개 이상의 테이블에 동일한 컬럼 명이 있는데, select 절이나 where절에 그 컬럼 명을 사용할 경우
- "a.컬럼명"과 같이 어떤 테이블로부터 가져올 것인지 구체적으로 적어주어야 한다.

:::

```sql
-- 남성이 구매하는 아이템은 어떤 것이 있는지

select item_name, sum(gmv) as gmv
from online_order oo
join item i on oo.itemid = i.id
join user_info ui on oo.userid = ui.userid
where gender = 'M'
group by 1
order by 2 desc
```
# SQL 기본 문법 P.2
:::note 주문 테이블에는 user id가 null 인 경우가 있다.
- user 테이블에 join을 하게 된다면?
![Pasted-image-20240229135055.png](/img/이미지 창고/Pasted-image-20240229135055.png)
:::

- 기본적으로는 1번으로 가져오지면, 경우에 따라서, 2번처럼 가져오는 join도 존재 한다.
## Join의 종류

| 유형                                                     | 조인 결과                                                                    | 필요 상황                                                     |
| ------------------------------------------------------ | ------------------------------------------------------------------------ | --------------------------------------------------------- |
| **Inner Join**<br />![Pasted-image-20240229135224.png](/img/이미지 창고/Pasted-image-20240229135224.png) | 두개 테이블에 모두 존재하는 행만 남음                                                    | 두 개 테이블에 조인 키가 빠짐없이 있을 때                                  |
| **Left Join**<br />![Pasted-image-20240229135239.png](/img/이미지 창고/Pasted-image-20240229135239.png)  | 왼쪽 테이블 기준으로 오른쪽 테이블을 붙임<br />- 따라서 만약 오른쪽 테이블에 조인되는 값이 없는 경우<br />null 로 표기됨 | 한개 이상의 테이블에 조인키에 null 값이 있거나 <br />테이블 1에 있는 값이 테이블2에는 없을 때 |
| **Right Join**<br />![Pasted-image-20240229135315.png](/img/이미지 창고/Pasted-image-20240229135315.png) | Left Join과 반대                                                            | 없음                                                        |
| **Full Join**<br />![Pasted-image-20240229135334.png](/img/이미지 창고/Pasted-image-20240229135334.png)  | 모든게 합쳐짐                                                                  | 초보자 수준에서는 없음                                              |
- Left Join 자체는 워낙 무겁기 때문에, 권장하지 않는다.
- 성능 면에서는 가급적 inner join을 써야한다.

```sql
select ui.gender, ui.age_band, sum(gmv) as gmv
from online_order oo
join user_info ui on oo.userid = ui.userid
group by 1,2
order by 1,2

-- LEFT JOIN
select ui.gender, ui.age_band, sum(gmv) as gmv
from online_order oo
left join user_info ui on oo.userid = ui.userid
group by 1,2
```

## Join의 주의 사항
### 행 중복
![Pasted-image-20240304091237.png](/img/이미지 창고/Pasted-image-20240304091237.png)

### where 절 실수
```sql
select *
from online_order oo
join item i on oo.itemid = i.id
join category c on i.category_id = c.id
left join user_info ui on oo.userid = ui.userid
and cate1 = '셔츠'
```
- 해당 쿼리 문은 sql에서 아래와 같다고 인식한다.
```sql
select *
from online_order oo
join item i on oo.itemid = i.id
join category c on i.category_id = c.id
left join user_info ui on oo.userid = ui.userid and cate1 = '셔츠'
```
- 위 sql문도 틀린 요소는 아니다.
- 하지만, 추천하지 않는 이유는,, join이 되기 전에 해당 조건을 먼저 필터링 하고 난 후에 

만약 의도가 `cate1='셔츠'` 이길 바란다면, `and`가 아닌 `where`절로 바꿔야 한다.

### on 절 실수
```sql
select *
from online_order oo
left join user_info ui on oo.userid, ui.userid
```
![Pasted-image-20240304095503.png](/img/이미지 창고/Pasted-image-20240304095503.png)
- 해당 부분에는 `,` 가 아닌 <mark>비교 연산자</mark>가 와야 한다.


### Join key가 한 개 이상일 때
```sql
select oo.dt, oo.itemid, oo.ordered, oo.unitsold, dc.daily_cost
from online_order oo
join daily_cost dc on oo.dt = dc.dt and oo.itemid = dc.itemid
```

:::note join이 필요한 이유
- 필요한 정보(상품명, 유저 정보, 카테고리 정보 등) 각기 다른 테이블에 분산 저장 되어 있을 때, 이를 하나의 테이블로 가져와 보기 좋게 데이터를 추출하기 위해

:::

---

#DB #SQL 

---