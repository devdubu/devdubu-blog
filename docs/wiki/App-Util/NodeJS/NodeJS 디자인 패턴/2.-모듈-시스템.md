---
slug: "2.-모듈-시스템"
---

:::tip 좋은 모듈 시스템은 소프트웨어 엔지니어링의 몇 가지 기본적인 필요성을 마주할 때, 도움을 줍니다.

:::

:::quote code base를 나누어 여러 파일로 분할하는 방법을 제시합니다.
- 이것은 코드를 좀 더 구조적으로 관리 할 수 있게 해주고 각각으로부터 독립적인 기능의 조각들을 개발 및 테스트하는 데에 도움을 주며, 이해하기 쉽게 해줍니다.

:::

:::quote 다른 프로젝트에 코드를 재 사용 할 수 있게 해줍니다.
-  실제로 모듈은 다른 프로젝트에도 유용하고 일반적인 특성을 구현할 수 있습니다.
- 모듈로서 기능을 구조화하는 것이 그 기능들이 필요한 다른 프로젝트로 좀 더 쉽게 이동 시킬 수 있다.

:::

:::quote 은닉성을 제공합니다.
- 일반적으로 복잡한 구현을 숨긴 채 명료한 책임을 가진 간단한 인터페이스만 노출 시키는 것이 좋은 방식입니다.
- 대부분의 모듈 시스템은 함수와 클래스 또는 객체와 같이 모듈 사용자가 이용하도록 공개 인터페이스를 노출 시키는 반면, 
- 공개하지 않으려는 코드를 <mark>선택적으로 공개되지 않도록</mark> 해줍니다.

:::

:::quote 종속성을 관리합니다.
- 좋은 모듈 시스템은 서드파티를 포함하여, 
	- 모듈 개발자로 하여금 <mark>기존에 있는 모듈에 의존</mark>하여 쉽게 빌드 할 수 있게 해줍니다.
- 또한 모듈 시스템은 모듈 사용자가 주어진 <mark>모듈의 실행에 있어 필요한</mark>(일시적 종속성들) 일련의 종속성들을 쉽게 임포트 할 수 있게 해줍니다.

:::

모듈과 모듈 시스템을 구별하는 것은 매우 중요합니다.

모듈 시스템이 문법이며, 
우리의 프로젝트 안에서 모듈을 정의하고 사용할 수 있게 해주는 도구인 반면, 
모듈은 소프트웨어의 실제 유닛으로 정의할 수 있습니다.

# JavaScript와 NodeJS 에서의 모듈 시스템

모든 프로그래밍 언어가 내장 모듈 시스템을 가지고 있는 것은 아니며, 
<mark>JavaScript</mark>는 오랫동안 이 요소가 <mark>결핍</mark> 되어 왔습니다.

브라우저 관점에서 코드 베이스는 여러 파일로 분할 될 수 있으며, 
다른 `<script>` 태그를 사용하여 임포트 될 수 있습니다.

:::note 사실 몇년 간은 이러한 필요성을 못 느꼈다고 생각하면 됩니다.

:::

당연하겠지만, JavaScript로 할 수 있는 범위가 늘어나고, 복잡해지면서 이러한 필요성을 느끼게 됩니다.

Query, Backbone, Angular와 같은 프레임 워크가 생태계를 점유해가면서 JavaScript 커뮤니티에는 JavaScript 프로젝트에 <mark>효율적으로 사용될 모듈 시스템</mark>을 정의 하기 위한 여러가지 시도가 나타나기 시작했습니다 

:::success 가장 성공적인 것이 AMD(Asynchronus Module Definition) 입니다.
- AMD는 RequireJS에 의해서 대중화 되었고, 후에는 UMD(Universal Module Definition)가 나오게 됩니다.

:::

NodeJS 가 처음 만들어졌을 때, NodeJs 운영 체제의 파일 시스템에 직접적으로 접근하는 JavaScript 를 위한 서버 런타임으로 구상 되었습니다.
![Pasted-image-20250429123002.png](/img/이미지 창고/Pasted-image-20250429123002.png)

그래서 모듈 관리에 있어서 다른 방법을 도입할 수 있는 특별한 기회가 있었습니다.

:::tip 이때 도입된 방법이란, HTML `<script>`과 URL 을 통한 리소스 접근에 의존하지 않고,
- 오직 로컬 파일 시스템의 JavaScript 파일들에만 의존하는 것이었습니다.

:::

이 모듈 시스템을 도입하기 위해 NodeJS는 브라우저가 아닌 환경에서 JavaScript 모듈 시스템을 제공할 수 있도록 고안된 <mark>CommonJS</mark> 의 명세를 구현하게 되었습니다.
![Pasted-image-20250429123208.png](/img/이미지 창고/Pasted-image-20250429123208.png)

CommonJS는 그것의 시작과 함께 NodeJS 에서 <mark>주된 모듈 시스템</mark>이 되었고, 
[Browserify](https://browserify.org/)와 [WebPack](https://webpack.kr/)과 같은 모듈 번들러 덕분에 브라우저 환경에서도 유명세를 가지게 되었습니다.

![Pasted-image-20250429123425.png](/img/이미지 창고/Pasted-image-20250429123425.png)
2015년에 ECMAScript6 (ECMAScript 2015 or ES2015) 의 발표와 함께 표준 모듈 시스템(ESM) 을 위한 공식적인 제안이 나오게 됩니다.

![Pasted-image-20250429123447.png](/img/이미지 창고/Pasted-image-20250429123447.png)

ESM은 JavaScript 많은 혁신을 불러옵니다.
특히, 모듈 관리에 대한 브라우저와 서버의 차이점을 연결하기 위해 노력합니다.

ECMScript 6는 문법과 의미론 적 관점에서 ESM을 위한 공식적인 명세만 정의하고 구체적인 구현을 제공하지 않았습니다.

다른 여러 브라우저 회사들과 NodeJS 커뮤니티가 확실한 명세를 구현하는데 몇 년이 소요되었습니다.
NodeJS는 버전 13.2 부터 ESM에 대한 안정적인 지원을 합니다.

:::tip 사실상 ECMA2015가 나온 시점에서는 바로 ESM을 적용할 수 없었다는 말이긴 합니다.
- 워낙 옛날 일이라 참고로만 알아보면 될 것 같습니다.

:::

해당 책을 작성할 시점에서는 대부분의 프로젝트들이 CommonJS로 작성되었기에, 문법 자체를 설명할 때는 CommonJS의 형태가 많이 보일 것입니다.

우선 CommonJS와 ESM의 차이를 보이기 위해서 먼저 CommonJS 형태로 작성해볼 것입니다.

## 모듈 시스템과 패턴
앞서 언급 했듯이 모듈은 주요 애플리케이션의 구조화를 위한 부품인 동시에 명시적으로 노출 시키지 않은 모든 함수들과 변수들을 <mark>비공개로 유지</mark>하여 정보에 대한 <mark>은닉성을 강화</mark> 시켜주는 주된 장치입니다.

CommonJS를 구체적으로 알아보기 전에 우리가 간단한 모듈 시스템으로 만들어보기 위해 사용할 패턴이자 정보를 감추는 데에 도움을 주는 노출 식 모듈 패턴을 이야기 해보겠습니다.

### 노출식 모듈 패턴
JavaScript의 주요 문제점 중 하나는 네임스페이스가 없다는 것입니다.
모든 Script는 전역 범위에서 실행됩니다.

따라서 내부 애플리케이션 코드나 종속성 라이브러리가 그들의 기능을 노출시키는 동시에 스코프를 오염시킬 수도 있습니다.
이는 매우 위험합니다.

:::warning 전역 범위에 의존하는 것은 매우 위험한 작업입니다.

:::

애플리케이션이 확장됨에 따라 더욱 개별적인 기능 구현에 의존 해야 하는 상황이 발생합니다.
이러한 문제를 해결하기 위한 보편적인 기법(Reveraling Module pattern)이라고 하며 다음과 같은 형식을 보입니다.

```js
const myModule = (()=>{
	const privateFoo = ( ) => { }
	const privateBar = [ ]

	const exported = {
		publicFoo: () => { },
		publicBar:  () =>{ },
	}

	return exported
})() // 여기서 괄호가 파싱되면, 함수는 호출 됩니다.

console.log(myModule)
console.log(myModule.privateFoo, myModule, privateBar)
```

이 패턴은 자기 호출 함수를 사용합니다.

이러한 종류의 함수를 **즉시실행함수표현**(IIFE)라고 부르며 private 범위를 만들고 공개될 부분만 내보내게 됩니다.

JavaScript 에서는 함수 내부에 선언한 변수는 외부 범위에서 접근할 수 없다.
함수는 선택적으로 외부 범위에 정보를 전파 시키기 위해서 `return` 구문을 사용할 수 있다.

```js
{
	publicFoo: [Function: publicFoo],
	publicBar: [Function: publicBar]
}
undefined undefined
```


위에서 보여주듯이 myModule로 부터 직접 접근이 가능한 것은 
<mark>export된 객체 뿐</mark>이라는 것을 알 수 있습니다.

우리가 곧 보게 되는 것은 이 패턴을 기반으로 하는 아이디어가 CommonJS 모듈 시스템에서 사용된다는 것입니다.

# CommonJS 모듈

CommonJS는 NodeJS의 첫 번째 내장 모듈 시스템입니다.

NodeJS CommonJS 는 CommonJS 명세를 고려하여 추가적인 자체 확장 기능과 함께 구현되었습니다.

:::note CommonJS 명세의 두 가지 주요 개념을 요약하면 다음과 같습니다
- `require`는 로컬 파일 시스템으로부터 모듈을 임포트하게 해줍니다.
- `exports`와 `module.exports`는 특별한 변수로서 현재 모듈에서 공개될 기능들을 내보내기 위해서 사용됩니다.

:::

현재까지는 이 정보 만으로 충분하며, 다가오는 단락들에서 세부적인 내용과 CommonJS 명세에서의 몇 가지 미묘한 차이점을 배우게 될 것 입니다.

## 직접 만드는 모듈 로더

NodeJS에서 CommonJS가 어떻게 작동하는지 이해하기 위해서 비슷한 시스템을 만들어 보겠습니다.
다음의 코드는 NodeJS의 `require()` 함수의 원래 기능 중 일부를 모방한 함수를 만든 것입니다.

먼저 모듈의 내용을 로드하고 이를 private 범위로 감싸 평가하는 함수를 작성해보겠습니다.

```js
function loadModule(filename, module, require){
	const wrappedSrc = `
		(function (module, exports, require){
			${fs.readFileSync(filename, 'utf8')
		})(module, module.exports, require)`
		eval(wrappedSrc)
}
```
모듈의 소스코드는 노출식 모듈 패턴과 마찬가지로 기본적으로 함수로 감싸집니다.

여기서 차이점은 일련의 변수들(module, exports 그리고 require)을 모듈에 전달한다는 것입니다.
눈여겨봐야 할 점은 랩핑 함수의 `exports` 인자가 `module.exports` 의 내용으로 초기화되었다는 것입니다.







