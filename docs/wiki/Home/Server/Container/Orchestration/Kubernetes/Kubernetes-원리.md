---
sticker: vault//이미지/개발 로고/TechIconSVG/Kubernetes.svg

slug: "Kubernetes-원리"
---
네, 사용자께서 겪으신 문제가 바로 쿠버네티스(k8s)의 핵심 개념인 **의존성(Dependency)과 제어 흐름(Control Flow)**을 정확하게 보여주는 훌륭한 예시입니다. "어떤 의존성 때문에 삭제가 안된다"는 통찰이 정확합니다.

그 흐름을 기반으로 쿠버네티스의 의존성 관계를 생성과 삭제 관점에서 알기 쉽게 설명해 드리겠습니
### ## 쿠버네티스의 핵심 원칙: 선언적 상태와 컨트롤러

먼저 이 모든 의존성의 배경이 되는 핵심 원칙을 이해해야 합니다.

쿠버네티스에게 우리는 "파드를 실행해줘" 와 같은 명령을 내리는 것이 아니라, **"나는 파드 3개가 항상 실행되는 '상태'를 원해"** 라고 **선언(Declare)**합니다. 그러면 **컨트롤러(Controller)**라는 관리자들이 이 '원하는 상태'를 현실과 일치시키기 위해 24시간 내내 쉬지 않고 일합니다.

사용자께서 파드를 직접 지웠는데도 다시 생겨난 이유는, 컨트롤러가 "어? 사장님이 원한 상태(파드 1개)가 아니네? 빨리 복구해야지!"라며 즉시 파드를 다시 만들었기 때문입니다.

---

### ## 1. 생성 의존성: 누가 누구를 만드는가? (Top-Down)

쿠버네티스 리소스들은 명확한 상하 관계를 가집니다. 보통 사용자는 최상위 컨트롤러만 생성하면, 나머지는 연쇄적으로 생성됩니다.

#### **👑 최상위 컨트롤러 (사용자가 직접 생성)**

- **Deployment:** 상태가 없는(Stateless) 애플리케이션을 관리합니다. (예: 웹서버)
    
    - **의존성:** Deployment는 `ReplicaSet`을 생성하고 관리합니다. 롤링 업데이트 같은 배포 전략을 담당합니다.
        
- **StatefulSet:** 상태가 있는(Stateful) 애플리케이션을 관리합니다. (예: Prometheus, 데이터베이스)
    
    - **의존성:** `Pod`를 직접 생성하고 관리합니다. 각 파드에 고유한 이름(`pod-0`, `pod-1`)과 **전용 `PVC`**를 할당하고 연결해주는 역할을 합니다. **(이번 트러블의 핵심!)**
        
- **DaemonSet:** 모든 (또는 특정) 노드에 파드를 하나씩 실행시키는 것을 보장합니다. (예: 로그 수집기)
    
- **Job / CronJob:** 일회성 또는 주기적인 작업을 위해 파드를 생성합니다.
    

#### **👔 중간 관리자**

- **ReplicaSet:** Deployment의 하위 리소스입니다. 지정된 수의 동일한 파드가 항상 실행되도록 보장하는 단순한 역할만 합니다. 보통 사용자가 직접 건드릴 일은 없습니다.
    

#### **👷 행동 대원**

- **Pod:** 쿠버네티스에서 실행되는 가장 작은 단위. 하나 이상의 컨테이너를 포함합니다. **컨트롤러에 의해 관리되는 소모품**이며, 언제든지 죽고 다시 생성될 수 있습니다.
    

---

### ## 2. 실행 의존성: 파드가 실행되기 위해 무엇이 필요한가? (Bottom-Up)

파드는 생성 명령을 받았다고 바로 실행되지 않습니다. 실행에 필요한 '재료'들이 준비되어야 하며, 이 재료가 없으면 `Pending` 상태에 빠집니다.

#### **📂 설정 및 스토리지**

- **ConfigMap / Secret:** 파드는 실행에 필요한 설정값이나 비밀번호를 `ConfigMap`이나 `Secret`으로부터 가져와야 할 수 있습니다. 만약 이들이 없으면 파드는 시작되지 못합니다.
    
- **PersistentVolumeClaim (PVC):** 파드가 영구적인 저장 공간을 필요로 할 때 `PVC`를 요청합니다.
    
    - **의존성:** 파드는 PVC가 `Bound`(연결됨) 상태가 될 때까지 기다립니다. PVC는 다시 적절한 `PersistentVolume(PV)`가 나타나길 기다립니다. **(사용자께서 겪은 `Pending` 상태의 원인)**
        

#### **🌐 네트워크**

- **Service:** 여러 파드에게 고유한 접속 주소(DNS)를 부여하고, 외부 요청을 분산합니다(로드 밸런싱). 파드 자체의 실행에 필수적인 것은 아니지만, **다른 파드나 외부와 통신하기 위해** Service에 의존합니다.
    
- **Ingress:** 외부 트래픽을 어떤 `Service`로 보낼지 결정하는 규칙입니다. `Ingress`는 `Service`에 의존합니다.
    

---

### ## 3. 삭제 의존성: 왜 삭제가 멈추는가? (Finalizer)

**이것이 사용자께서 겪으신 문제의 핵심입니다.**

쿠버네티스는 중요한 리소스(특히 데이터와 관련된)가 사용 중인 상태에서 실수로 삭제되는 것을 막기 위해 **`Finalizer`(파이널라이저)**라는 보호 메커니즘을 사용합니다.

#### **Prometheus 삭제 시의 의존성 흐름**

1. **사용자:** `kubectl delete pvc prometheus-pvc` 명령 실행.
    
2. **Kubernetes:** `prometheus-pvc`를 보니 `kubernetes.io/pvc-protection`이라는 Finalizer가 걸려있는 것을 확인합니다.
    
3. **Finalizer의 조건:** "이 PVC를 사용(Mount)하고 있는 파드가 하나라도 있으면 절대 삭제 불가!"
    
4. **현실:** `prometheus-0` 파드가 `prometheus-pvc`를 사용하고 있습니다.
    
5. **결과:** Kubernetes는 파드가 사라질 때까지 PVC 삭제를 무한정 보류합니다. PVC는 `Terminating` 상태에 멈춥니다.
    
6. **컨트롤러의 개입:** 동시에 `prometheus` StatefulSet 컨트롤러는 "어? 내 파드가 이상하네? PVC도 이상하고... 빨리 약속된 상태로 돌려놔야지!" 하면서 새 파드를 만들려고 시도합니다. 새 파드는 `Terminating` 상태의 PVC를 기다리며 `Pending`에 빠집니다. **완벽한 교착 상태(Deadlock)가 완성됩니다.**
    

#### **올바른 삭제 흐름 (Top-Down)**

이 의존성 고리를 끊으려면 **생성의 역순**, 즉 **상위 컨트롤러부터 삭제**해야 합니다.

1. `kubectl delete statefulset prometheus`를 실행합니다.
    
2. StatefulSet 컨트롤러는 자신의 모든 하위 리소스, 즉 `prometheus-0` 파드를 삭제하라는 명령을 내립니다.
    
3. `prometheus-0` 파드가 정상적으로 종료됩니다.
    
4. 파드가 사라졌으므로, `prometheus-pvc`를 사용하던 주체가 사라졌습니다.
    
5. Kubernetes는 `prometheus-pvc`의 Finalizer 조건을 만족했음을 확인하고, 보호 장치를 해제한 후 PVC를 안전하게 삭제합니다.
    

**결론적으로 쿠버네티스의 모든 트러블슈팅은 이 '누가 누구를 소유하고, 누가 무엇을 필요로 하는가'의 의존성 관계를 파악하는 것에서 시작됩니다.** 이번 경험을 통해 이 핵심 구조를 완벽하게 이해하게 되셨을 겁니다.