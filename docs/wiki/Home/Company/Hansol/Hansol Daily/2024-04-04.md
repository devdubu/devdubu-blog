---
sticker: emoji//1f4c6
종료 날짜: 2024-04-04
시작 날짜: 2024-04-04
분류: 노트
카테고리:
  - Application
특징:
  - Front
  - Nuxt3
---
# Validation

validation 가동 범위에 대한 기준을 알아볼 필요가 있을 것 같다.

우선 순수 vuetify에 대한 코드로 validation을 작성한다면

## 순수 Vuetify

```tsx
<template>
    <v-sheet class="mx-auto" width="300">
        <v-form ref="form">
            <v-text-field v-model="name" :counter="10" :rules="nameRules" label="Name" required></v-text-field>

            <v-select v-model="select" :items="items" :rules="[(v) => !!v || 'Item is required']" label="Item" required></v-select>

            <v-checkbox
                v-model="checkbox"
                :rules="[(v) => !!v || 'You must agree to continue!']"
                label="Do you agree?"
                required
            ></v-checkbox>

            <div class="d-flex flex-column">
                <v-btn class="mt-4" color="success" block @click="validate"> Validate </v-btn>

                <v-btn class="mt-4" color="error" block @click="reset"> Reset Form </v-btn>

                <v-btn class="mt-4" color="warning" block @click="resetValidation"> Reset Validation </v-btn>
            </div>
        </v-form>
    </v-sheet>
</template>

<script>
export default {
    data: () => ({
        name: '',
        nameRules: [(v) => !!v || 'Name is required', (v) => (v && v.length <= 10) || 'Name must be less than 10 characters'],
        select: null,
        items: ['Item 1', 'Item 2', 'Item 3', 'Item 4'],
        checkbox: false,
    }),

    methods: {
        async validate() {
            const { valid } = await this.$refs.form.validate()

            if (valid) alert('Form is valid')
        },
        reset() {
            this.$refs.form.reset()
        },
        resetValidation() {
            this.$refs.form.resetValidation()
        },
    },
}
</script>
```

## Vee Validation

```tsx
<template>
  <form @submit.prevent="submit">
    <v-text-field
      v-model="name.value.value"
      :counter="10"
      :error-messages="name.errorMessage.value"
      label="Name"
    ></v-text-field>

    <v-text-field
      v-model="phone.value.value"
      :counter="7"
      :error-messages="phone.errorMessage.value"
      label="Phone Number"
    ></v-text-field>

    <v-text-field
      v-model="email.value.value"
      :error-messages="email.errorMessage.value"
      label="E-mail"
    ></v-text-field>

    <v-select
      v-model="select.value.value"
      :error-messages="select.errorMessage.value"
      :items="items"
      label="Select"
    ></v-select>

    <v-checkbox
      v-model="checkbox.value.value"
      :error-messages="checkbox.errorMessage.value"
      label="Option"
      type="checkbox"
      value="1"
    ></v-checkbox>

    <v-btn class="me-4" type="submit"> submit </v-btn>

    <v-btn @click="handleReset"> clear </v-btn>
  </form>
</template>

<script setup>
  import { ref } from 'vue'
  import { useField, useForm } from 'vee-validate'

  const { handleSubmit, handleReset } = useForm({
    validationSchema: {
      name(value) {
        if (value?.length >= 2) return true

        return 'Name needs to be at least 2 characters.'
      },
      phone(value) {
        if (value?.length > 9 && /[0-9-]+/.test(value)) return true

        return 'Phone number needs to be at least 9 digits.'
      },
      email(value) {
        if (/^[a-z.-]+@[a-z.-]+\\.[a-z]+$/i.test(value)) return true

        return 'Must be a valid e-mail.'
      },
      select(value) {
        if (value) return true

        return 'Select an item.'
      },
      checkbox(value) {
        if (value === '1') return true

        return 'Must be checked.'
      },
    },
  })
  const name = useField('name')
  const phone = useField('phone')
  const email = useField('email')
  const select = useField('select')
  const checkbox = useField('checkbox')

  const items = ref(['Item 1', 'Item 2', 'Item 3', 'Item 4'])

  const submit = handleSubmit(values => {
    alert(JSON.stringify(values, null, 2))
  })
</script>

```

## **Vuelidate**

- 해당 부분은 사이트가 폐쇄로 고려하지 않았음

 >[!tip] **Vee Validation** 해당 부분으로 결정


우선 사용하게 된다면, 없는 것 보단 직관적이며, 만약에 `export` 로 중앙화를 한다고 하였을 때도 훨편해보이지만, 이 부분은 직접적으로 코드를 만져보면서 개발을 해봐야지 검증이 가능할 듯 싶다.

# 인수 인계

`content`는 업데이트 대상이 될 수도 있으므로, demo에서는 해당 디렉토리를 복사하는 자동화 코드를 개발 하는 방향으로 추천

- Tab 선 처리,, 추후에 요구 사항이 있을 수도 있다. 고려를 미리 해보기 → auth
- 화면 안에 있는 일반 Tab도 고려 사항
- Tab간의 이동에서 해당 캐시 데이터가 남아 있으려면 ref 대신 useState를 써야한다.
- useState의 작동 순서에 대해서는 다시금 살펴 볼 필요는 있다
- 새로 고침과 화면 이동이 2번 불릴 때, 혹은 1번만 불릴 수도 있다는 그런 순서에 대한 flow를 좀 알아봐야할 듯