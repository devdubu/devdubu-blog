---
sticker: emoji//1f4c6
종료 날짜: 2024-09-10
시작 날짜: 2024-09-10
분류: 노트
카테고리:
  - Application
특징:
  - Front
  - Nuxt3
---
# Grid 개념 분리

항상 문제가 되는 이슈는 realgrid의 자체적인 변수인 `gridView` 와 `dataprovider` 를 사용할 수 있는지 없는 지에 대한 이슈이다.

우선 파일 별로 `gridView` , `dataprovider` 를 사용할 수 있는 지를 분리 한 후에,

`initGrid` 에 속하는지, 이후에 렌더를 해도 되는 것인지를 분리하여서 재 구축을 해야할 필요성이 생기고 있다.

## `gridView`, `dataprovider` 사용 불가

`gridColumnConfig.ts`

`gridEditorConfig.ts`

## `dataprovider` 사용 가능

`gridEventConfig.ts`

## `gridView` 사용 가능

`index.vue`

# 이슈 정리

## Grid BeforeSave

- 코드 정리 및 md 파일 정리

## Grid Cell Background color

- Cell Background type 정의
    - editable color 를 넣을 것인지 또는
- background class name 정의
- tooltip 정리

## Grid chained Select box

- 파일 정리

# 확인하기

- **[FE] 그리드 행 그리드 행 선택 이벤트 시 필터(정렬) 걸고 클릭 시 제대로 정보를 가져오지 못함**

## 서티 과제

- 김제민
    - 미흡
        - image path
        - middleware 미흡
            - 모든 url redirect
- 손혜연
    - 미흡
        - image path : @ 사용
        - middleware 미흡
            - 모든 url redirect
- 권순규
    - 양호
        - image path: @ 사용
        - middleware: 준수
- 길준석
    - 보류
        - image path: @사용
        - middleware: global 설정 안 함

# chained Selector

- 1단계의 경우에는 select box와 동일하게 적용하면 됨

```tsx
lookupSourceId: "type1",
	lookupKeyFields: [
	  "field1",
    "field2"
]
```

- 2단계 부터는 위와 같은 차이점이 존재
- `lookupSourceId` 는 내가 만들면 그만인 존재
- 하지만, `field1`, `field2`는 array라면 내가 설정하면 됨, 하지만, 선택권을 줘야 하는 관계라면, 필요함

```tsx
interface IGridChaninedSelect{
	chainField: string[]
	data:[
		{ key: value},
		{ key: value},
		{ key: value},
	]
	dataChain:{
		string: string[],
		string: string[],
	}	
}
```

```tsx
const chainObject = {
	"key1" : ["key12"], or "url"	
	"key2" : ["key22"], or "url"
	"key3" : ["key32"], or "url"
}
```

# Grid ChainSelect Config 구조

```tsx
interface IGridEditorSelectBox {
    textField?: string
    valueField?: string
    data?: Array<any>
    api?: {
        url: string
        params?: any
    }
}

interface IGridDataChain {
	[key:string]: string | string[]
}
inter

interface IGridChainSelect extends IGridEditorSelectBox{
	textField?: string
  valueField?: string
  data?: Array<any>
  api?:
	chainField?: string[]
}

interface IGridEditorChainSelector{
	type?: htype.GRID_EDITOR_TYPE
  name?: string
  setEditable?: string
	selectArray: IGridChainSelect []

}

```

## 예시 코드

```tsx
{
	...
	{
		text: "체인 셀렉트",
		field: "CHAIN_SELECT",
		editor:{
			type: "chain-select-box",
			selectSet:[
				{
					text: "도시"
					field: "city",
					width: 150,
					editor:{
						type:'input-select',
						textField: 'CODE_CD',
						valueField: 'CODE_NM',
						data:[], //  도시 관련 데이터 
					},
				},
				{
					text: "구"
					field: "gu",
					width: 150,
					editor:{
						type:'input-select',
						textField: 'CODE_CD',
						valueField: 'CODE_NM',
						
						dataChain:[
							{
								'서울시': ['구로구', '영등포구', '강남구'],
								'대전시' : 'DepartFunc',
							}
						]
					}
				}
			]
		}
	}
	...
}

const DepartFunc = ()=>{

}

```

ms-108

- `input-select` 했을 때 해당 행의 특정 컬럼 값을 파라미터로 넘기는 행위


# 동적 select box

chained select 는 `styleCallback` / `displayCallback` 로 가능함

현재의 구조에서는 문제는 list의 데이터가 `[]` 일 때는 가능함

하지만, `async await` 구문을 이용하게 된다면, `promise` 리턴 하게 되는데 이 부분에서 부터 문제가 발생함

현재 구조에서는 해결 할 방법이 없음

## 현 구조

```tsx
const columnStyleCallBackFunc = async (grid: any, dataCell: any) => {
    const selectNation = grid.getValue(dataCell.index.itemIndex, 'GCD')
    const ret: any = {}

    if (selectNation === 'Korea') {
        const apiInfo = {
            url: '/api/admin/code/code-grp',
        }
        const _params = {}
        const resultData = await hdata.callRemoteApi(apiInfo, _params)

        await resultData.forEach((select: any, index: any) => {
            selectLabels[index] = select['CODE_GRP_NM']
            selectValues[index] = select['CODE_GRP_CD']
        })
        // selectLabels = ['독일어', '스페인어']
        // selectValues = ['ge_GE', 'sp_SP']
    } else {
        selectLabels = ['English', '한국어']
        selectValues = ['en_US', 'ko_KR']
    }

    ret.editor = {
        type: 'dropdown',
        dropDownCount: 4,
        domainOnly: true,
        textReadOnly: true,
        values: selectValues,
        labels: selectLabels,
    }

    console.log(ret.editor)
    return ret
}

const columnDisplayCallBackFunc = async (grid: any, index: any, value: any) => {
    const selectNation = grid.getValue(index.itemIndex, 'GCD')
    let retValue = value

    if (selectNation !== 'Korea') {
        selectLabels = ['English', '한국어']
        selectValues = ['en_US', 'ko_KR']
    } else {
        const apiInfo = {
            url: '/api/admin/code/code-grp',
        }
        const _params = {}
        const resultData = await hdata.callRemoteApi(apiInfo, _params)

        await resultData.forEach((select: any, index: any) => {
            selectLabels[index] = select['CODE_GRP_NM']
            selectValues[index] = select['CODE_GRP_CD']
        })
        // selectLabels = ['독일어', '스페인어']
        // selectValues = ['ge_GE', 'sp_SP']
    }
    const idx = selectValues.indexOf(value)
    retValue = selectLabels[idx]

    console.log(index)
    return retValue
}

const column = [
	{
        name: 'LANG',
        fieldName: 'LANG',
        width: 150,
        sortable: true,
        editable: true,
        values: ['en_US', 'ko_KR'],
        labels: ['English', '한국어'],
        editor: {
            type: 'dropdown',
            dropDownCount: 4,
            domainOnly: true,
            textReadOnly: true,
        },
        header: {
            text: '공통 코드 Select',
            styleName: 'orange-column',
        },
        styleCallback: columnStyleCallBackFunc, // 객체는 await을 지원하지 않음
        displayCallback: columnDisplayCallBackFunc, // 객체는 await을 지원하지 않음
    },
	
]
```

- 즉, 위의 구조는 가능하지 않다.
- 결국은 `selectValues` 와 `selectLabels` 가 매개변수 혹은 어떤 형식 으로든 이미 생성이 되어있는 배열 이어야 한다.

결론적으로는 `columnStyleCallBackFunc` / `columnDisplayCallBackFunc` 은 return 값이 `Promise<T>` 면 안된다.

해결 방안,,,,은 아래와 같다

```tsx
export const setDynamicSelectBox = async()=>{
	// API 관련 로직들
	
	const columnStyleCallBackFunc = ()=>{ }
	const columnDisplayCallBackFunc = ()=>{ }
	
	return { columnStyleCallBackFunc, columnDisplayCallBackFunc }

}
```

그 후에, selectBox API 가 사용한 곳에서

```tsx
 const dynamicSelectBoxTest = await setDynamicSelectBox()
 
 return {
	  styleCallback: dynamicSelectBoxTest.columnStyleCallBackFunc,
    displayCallback: dynamicSelectBoxTest.columnDisplayCallBackFunc,
 }
 
```

위처럼 시전하니 성공쓰…

문제는 이를 어떻게 configuration으로 뺄 것인지에 대한 의문

### 조건 분리 해서 생각해보기

1. 우선 “특정 Field” 에서 나
2. 특정 값이 체크 된다면, api 혹은 작성한 data를 이용해서 selectbox의 데이터를 교체 해야 함

만약 아래와 같은 `func` 이 온다면?

```tsx
const dynamicSelect = async (grid:any) => {
	const value = grid.getValue(dataCell.index.itemIndex, 'Field 명')
	
	if(value === '특정 값'){
		//특정 api 데이터 return 값
		// config js 파일에서도 func={ } 함수를 이용해서 api 호출 가능
		const test = await hdata.post('/api/admin/code/code-grp', {}, { quiet: false })
	}else if(value === '특정 값1'){
		//특정 api 데이터 return 값
	}
	
}
```

조건 절 따로, url 경로 (또는 data Array)는 각각 받아야 함

func 으로 정형화는 불가능에 가까움 - 위 처럼 조건 절 + api 를 통한 데이터 리턴은 어려움

### 방법1

- func는 조건 절로 return 값을 boolean으로 만 받음
    
- api는 따로 url을 받던, 혹은 그냥 데이터를 받던 해야 함
    
- 그리고 이 둘의 관계를 mapping 시켜야 할 부분이 존재 해야 하며, 여러 개의 조건과 여러 개의 각기 다른 값들이 온다는 것을 가정 해야 함