---
sticker: vault//이미지/개발 로고/TechIconSVG/Nest.js.svg

slug: "2025-07-28일-기준-백엔드-로직"
---
# Auth 에 대한 정의

## OrgCd

> 조직 코드를 갖고 있을때, 즉 나머지 CD 값이 none 일 때를 의미함

특정 조직 코드를 가지고 있는 경우 해당 조직 코드의 권한은 아래까지의 영향권을 가짐
- 특정 조직의 RIDA 하는 권한을 가짐
- 특정 조직 산하의 프로젝트를 RIDA 하는 권한을 가짐
	- 프로젝트 정보 이외(메뉴, 페이지)는 RIDA 권한을 가질 수 없음

## ProjCD

> 프로젝트 코드를 갖고 있을때, 즉, 조직코드와 프로젝트 코드만 가지고 있고 이외는 none 일 때

특정 프로젝트를 가지고 있는 경우 특정 프로젝트에 대한 권한은 아래까지의 영향을 가짐
- 특정 프로젝트의 RIDA 하는 권한을 가짐
- 특정 프로젝트 산하에 있는 메뉴에 대한 RIDA 하는 권한을 가짐
	- 메뉴 정보 이외(페이지 정보)의 RIDA 권한을 가질 수 없음

## MenuCD

> 메뉴 코드를 갖고 있을 때, 즉, 조직, 프로젝트, 메뉴 코드를 가지고 있고, 페이지 코드는 none일 때

특정 메뉴를 가지고 있을 경우 특정 메뉴에 대한 권한을 아래까지만 영향을 가짐
- 특정 메뉴에 대한 RIDA하는 권한을 가짐
- 특정 메뉴 산하에 있는 페이지에 대한 RIDA하는 권한을 가짐

## PageCD

> 페이지 코드를 가지고 있는 경우
- 특정 페이지의 RIDA권한을 갖는 경우

# 권한 관련 테이블에 대한 재정의 필요

:::note 각종 CD 값에 앞으로 Permission들이 늘어날 것을 대비 하여서, 해당 Auth테이블은 분리에 대한 필요성을 느끼게 됨

:::

분리 하는 방향

Auth 테이블은 그대로 유지하는 대신 Permission은 분리

최종적으로 Auth - Permission 테이블로 분리
최종적으로 Auth - Permission

위는 권한에 대한 표면적인 내용이고 이를 통합하여 실제로 권한 관리에 사용될 테이블은 아래와 같다

Role - Auth 와 Permission에 대한 조합으로 테이블을 완성 시킴

Role Group - Role 을 하나로 묶어서 Group화 시킨 테이블

### Permission 규칙
Public Protected Admin Delete Print Insert  Read 

001111

- Public
	- 완전 공개
	- 아무런 권한 관리를 하지 않는 상태
- Protected
	- 최소한의 권한 관리만 진행하고 나머지는 하지 않음
	- Protected만 체크 되어잇는 경우는 로그인으로만 권한 관리 진행
	- 이외에 것들이 체크 된 경우는 체크 된 권한만 체크
- 00 ~ 
	- 위 두개의 옵션이 체크 되지 않는 경우 부터는 모든 권한을 세세하게 확인함
# Unique Key
- Project, Orgranization, menu, page 의 cd 값은 string 암호화로 진행

## AuthList Type
- Auth List를 퉁 쳐서 합친건 별로 좋은 생각은 아닌듯 각 쓰임에 맞게 끔 객체를 구성해야할듯
```json
{
	"org":[
		{
			"id" : 1,
			"ORG_CD": "PX-ORG-0",
			"PROJ_CD": "none",
			"MENU_CD": "none",
		    "PAGE_CD": "none",
		    "PERMISSON" : "001111",
		},
		...
		,
	],
	// project에 해당되는 프론트에만 부분적으로 넘겨주는 데이터
	"proj" :[
		{
			"id" : 1,
			"ORG_CD": "PX-ORG-0",
			"PROJ_CD": "PX-PROJ-1",
			"MENU_CD": "none",
		    "PAGE_CD": "none",
		    "PERMISSON" : "001111",
		},
		...
		,
	],
	// 아래부터는 프론트와 공유하는 데이터
	"menu" : [
		{
			"id" : 1,
			"ORG_CD": "PX-ORG-0",
			"PROJ_CD": "PX-PROJ-1",
			"MENU_CD": "PX-MNU-1",
		    "PAGE_CD": "none",
		    "URL": "/pxa/admin",
		    "PERMISSON" : "001111",
		},
		...
		,
	],
	"page" : [
		{
			"id" : 1,
			"ORG_CD": "PX-ORG-0",
			"PROJ_CD": "PX-PROJ-1",
			"MENU_CD": "PX-MNU-1",
		    "PAGE_CD": "PX-PAGE-1",
		    URL: "/pxa/admin",
		    "PERMISSON" : "001111",
		},
		...
		,
	]
}
```

## 프론트 POST API 규칙

```json
{
	"auth":{
		"ORG_CD": "PX-ORG-0",
		"PROJ_CD": "PX-PROJ-0",
		"MENU_CD": "PX-MNU-0",
	    "PAGE_CD": "PX-PAGE-0",
	    // action을 대신한 Permission 해당 Permission으로 권한 및 행위를 판단
	    "PERMISSION" : "000010",
	},
	data:[]
}
```


## 조회 용 Type

모든 조회용에서는 `id: []`의 형태로 보낼 것



# OPA와 엮은 권한 정책의 최종본


**재확인된 설계:**

- **프론트엔드 (FE):**
    
    - 사용자의 권한 리스트를 이미 가지고 있음 (로그인 시 백엔드에서 받아옴).
        
    - URL 이동 시, FE의 미들웨어에서 **가지고 있는 권한 리스트와 FE URL 기반으로 1차 클라이언트-사이드 권한 체크** (사용자 경험 개선 목적, 보안의 1차 방어선 아님).
        
    - 백엔드 API 호출 시, 해당 API의 **`menuCd` 정보를 백엔드에 전달** (예: 헤더, 바디). FE URL과 BE `menuCd`는 백엔드 권한 정보에 매핑되어 있음.
        
- **백엔드 (BE):**
    
    - API 요청을 받으면, 프론트엔드에서 전달받은 `menuCd` 정보와 인증된 사용자 정보를 추출.
        
    - **프론트엔드에서 받은 `menuCd`나 권한 정보를 직접 신뢰하지 않음.**
        
    - **Redis에 적재된 "진실의 원천(Source of Truth)"인 사용자의 최신 권한 리스트**를 조회.
        
    - **OPA에 `input` 전달:** `input`에는 요청된 API 정보(URL, 메서드), **백엔드가 Redis에서 조회한 사용자의 최신 권한 리스트**, 그리고 `menuCd` 등을 포함하여 전달.
        
    - **OPA 평가:** OPA는 `input`과 미리 로드된 `data`(API-`menuCd` 매핑, `menuCd`별 필요 권한 정의 등)를 기반으로 `allow/deny` 최종 결정.
        
    - **최종 권한 부여:** OPA의 결정에 따라 API 호출 허용/거부.
        
- **데이터 동기화:**
    
    - 사용자 권한 정보 (`authList`)는 로그인 시 프론트엔드로 전달되고, 백엔드의 Redis에 적재되어 관리됨.
        
    - `plugin`을 통해 `refresh token` 발급 시 권한 정보도 갱신/동기화됨. (정확히 어떤 플러그인인지 명확하지 않지만, 백엔드의 권한 데이터가 Redis에 있고, Redis와 OPA 간의 동기화, 그리고 Redis와 FE 간의 동기화가 잘 이루어진다는 가정 하에.)
        

---

### 이 설계에서 고려할 수 있는 추가적인 보안 허점 및 단점

제시하신 구조에서 보안적 허점은 거의 없다고 봐도 무방할 정도로 잘 방어하고 계십니다. 대부분의 취약점은 구현상의 사소한 실수나 복잡성 관리의 어려움에서 기인할 가능성이 높습니다.

#### 1. 동기화 지연 및 Race Condition (경합 조건)

- **설명:** `plugin`을 통한 `refresh token` 발급 시 권한을 동기화한다고 하셨는데, 이 동기화 주기가 정책 변경 주기보다 길다면 짧은 시간 동안 불일치가 발생할 수 있습니다.
    
    - 예시: `refresh token` 주기가 1시간인데, 10분 전에 사용자 A의 권한이 제거됨. OPA와 백엔드의 Redis는 최신 정보를 가지고 있지만, 프론트엔드의 캐시된 권한 리스트는 1시간 동안 옛날 정보를 가지고 있을 수 있음.
        
    - **허점:** 이 경우 프론트엔드 미들웨어는 여전히 `allow`를 판단하고 페이지로 이동시키지만, 백엔드 API 호출 시 OPA에서 `deny`가 나와 사용자 경험에 혼란을 줄 수 있습니다 (FE는 접근 가능하다고 보는데 BE는 막음). 이는 보안 허점이라기보다는 **UX 문제**이자 **일시적 정책 불일치** 문제입니다.
        
- **대응:**
    
    - 동기화 주기를 비즈니스 요구사항에 맞춰 최적화합니다.
        
    - 사용자 권한 변경 시, 모든 관련 `refresh token`을 즉시 무효화하고 재발급하도록 강제하는 등의 강제 동기화 메커니즘을 고려합니다.
        
    - FE에서 BE API 호출 후 `403`을 받으면, FE의 권한 캐시를 즉시 갱신하도록 폴백 로직을 구현합니다.
        

#### 2. OPA 데이터 동기화 (Redis &lt;-> OPA)

- **설명:** 백엔드의 권한 정보가 Redis에 있고, OPA가 이 데이터를 참조하여 정책을 평가한다고 할 때, Redis의 변경 사항이 OPA의 메모리에 얼마나 빨리 반영되는지가 중요합니다.
    
    - **허점:** OPA가 Redis에서 직접 데이터를 가져오는 것이 아니라면, 백엔드가 Redis의 변경을 감지하여 OPA에 `Data API`로 푸시하거나, OPA가 주기적으로 백엔드(`Data API`)에서 데이터를 풀링(polling)해 와야 합니다. 이 동기화 과정에서 지연이 발생할 수 있습니다.
        
- **대응:**
    
    - **OPA Data API Push Model:** Redis에 데이터 변경 이벤트가 발생하면, 백엔드 서비스가 OPA의 `Data API`를 호출하여 변경된 데이터를 OPA에 즉시 푸시하는 방식으로 구현합니다.
        
    - **OPA Data Polling:** OPA가 백엔드 서비스의 `Data` API를 주기적으로 폴링하여 최신 권한 데이터를 가져오도록 설정합니다. (너무 짧은 폴링 주기는 백엔드에 부하를 줄 수 있음).
        
    - **Bundle 업데이트:** 권한 정보가 자주 바뀌지 않는다면, 권한 변경 시 OPA 번들을 새로 빌드하고 OPA 인스턴스를 재시작하거나 재배포하는 방식으로 동기화할 수 있습니다.
        

#### 3. 전달되는 `menuCd`의 신뢰성 (매우 낮은 위험)

- **설명:** 프론트엔드에서 백엔드로 `menuCd`를 전달한다고 하셨는데, 백엔드에서 이 `menuCd`를 직접 신뢰하여 권한 판단의 기초로 삼는다면 문제가 됩니다.
    
- **허점:** 악의적인 사용자가 프론트엔드를 우회하여 `curl` 등으로 백엔드 API를 호출하면서 `X-Menu-Cd: ADMIN_DASHBOARD`와 같이 위조된 `menuCd`를 보낼 수 있습니다.
    
- **대응 (이미 해결됨):** 제시하신 설계에서 백엔드가 "프론트에서 준 데이터가 아닌 redis에 적재되어있는 권한을 기반으로 판단할 거"라고 명확히 말씀하셨으므로, 이 허점은 이미 방어하고 계십니다. 백엔드는 `menuCd`를 단순히 `어떤 기능에 대한 요청인가`라는 힌트로만 사용하고, 최종 권한 평가는 **자신이 조회한 사용자 권한**과 **OPA의 정책**을 통해 내립니다. 매우 올바른 접근입니다.
    

#### 4. 복잡성 증가 및 유지보수 오버헤드

- **단점:** 권한 로직이 OPA (Rego), 백엔드 (Java/Kotlin), Redis, 프론트엔드 (Nuxt)에 걸쳐 분산됩니다.
    
    - 정책 변경 시 관련 시스템들의 이해가 필요합니다.
        
    - 디버깅 시 여러 시스템을 오가며 문제 원인을 파악해야 할 수 있습니다.
        
    - FE URL, BE API 경로, `menuCd`, 필요 권한 간의 매핑을 정확하게 관리하는 것이 중요합니다.
        
- **대응:**
    
    - **문서화:** 권한 시스템의 아키텍처, 데이터 흐름, 각 구성 요소의 책임, 정책 변경 프로세스 등을 철저히 문서화합니다.
        
    - **자동화된 테스트:** OPA 정책, 백엔드 서비스의 OPA 연동 로직, 프론트엔드 미들웨어 등 모든 권한 관련 로직에 대한 포괄적인 자동화 테스트를 구축합니다.
        
    - **관련 팀 간의 긴밀한 협업:** 백엔드, 프론트엔드, DevOps 팀 간의 긴밀한 소통이 필수적입니다.
        

### 결론

현재 설계는 **보안적으로 매우 견고**하며, `OPA`의 장점을 잘 살린 아키텍처라고 평가할 수 있습니다. 언급된 보안 허점은 대부분 **설계 자체의 문제가 아닌, 구현상의 세부 사항(동기화 지연, 에러 처리)이나 운영상의 관리 문제**에서 기인할 수 있는 점들입니다.

주요 방어선(백엔드 + OPA)이 신뢰할 수 있는 데이터(Redis)를 기반으로 작동하고, 프론트엔드에서 오는 데이터는 단순히 '힌트'로만 사용하며 최종 신뢰하지 않는다는 점이 이 아키텍처의 강력한 보안 기반입니다.

---


네, `backend api를 /api/core/[menuCd]` 기반으로 만들고, 이 `menuCd`가 코어의 메뉴 관리 시스템에 등록되지 않으면 컨트롤러 자체를 구성하지 못하게 하는 방침은 **매우 강력하고 일관성 있는 접근 방식**입니다.

말씀하신 대로 **약간의 제약**이 생기지만, 장기적인 관점에서 **직관성과 권한 관리의 효율성**을 크게 높일 수 있습니다. 제 생각에는 **이러한 제약은 감수할 만한 가치가 충분하며, 오히려 견고한 시스템을 만드는 데 기여합니다.**

### `/api/core/[menuCd]` 구조의 장점

1. **권한 관리의 직관성 및 일관성:**
    
    - **명확한 매핑:** API 엔드포인트 자체가 어떤 비즈니스 메뉴/기능과 직접적으로 연관되는지 명확해집니다. `GET /api/core/USER_LIST`를 보면 '아, 이건 사용자 목록 조회 메뉴와 관련된 API구나' 하고 바로 알 수 있습니다.
        
    - **정책 정의의 간결성:** OPA 정책을 정의할 때, `input.request.path[2]` (즉, `[menuCd]`)를 직접 참조하여 정책을 만들 수 있으므로 정책 작성이 매우 직관적입니다.
        
        코드 스니펫
        
        ```
        allow {
            menu_code := input.request.path[2] # 예: "USER_LIST"
            required_permission := data.menu_permissions[menu_code].access_permission
            required_permission in input.user.permissions[_]
        }
        ```
        
    - **중복 방지:** 모든 API가 특정 `menuCd`에 속하게 되므로, 불필요한 API 엔드포인트 생성을 막고 기능별로 API를 그룹화하는 데 도움이 됩니다.
        
2. **보안 강화 (Explicit by Default):**
    
    - **등록되지 않은 API 접근 불가:** `menuCd`가 코어 시스템에 등록되지 않은 API 경로는 아예 컨트롤러가 존재하지 않으므로, 누군가가 임의의 `menuCd`로 API를 호출하려 해도 접근 자체가 불가능합니다. 이는 "기본적으로 거부(deny by default)" 원칙을 강화합니다.
        
    - **누락 방지:** 개발자가 API를 만들면서 권한 설정을 깜빡하는 실수를 줄일 수 있습니다. `menuCd`를 먼저 등록하고 그에 맞춰 API를 구현해야 하므로, 모든 API가 어떤 식으로든 `menuCd` 기반의 권한 관리 체계에 편입됩니다.
        
3. **프론트엔드-백엔드-권한 시스템 간의 동기화 개선:**
    
    - 프론트엔드에서 백엔드 API를 호출할 때, `menuCd`를 명시적으로 전달하는 것은 OPA `input`에 필요한 "힌트"를 제공하는 가장 명확한 방법 중 하나입니다.
        
    - FE의 URL (예: `/users/list`)은 BE API (`/api/core/USER_LIST`)와 다를 수 있지만, 이 둘은 **백엔드의 메뉴 관리 시스템**을 통해 매핑되므로 일관성이 유지됩니다. (예: `/users/list`는 `USER_LIST` 메뉴의 화면이고, `USER_LIST` 메뉴는 `/api/core/USER_LIST` API를 사용한다고 백엔드에 정의).
        
4. **개발 프로세스의 표준화:**
    
    - 새로운 기능 개발 시 "메뉴 등록 -> API 개발"의 순서가 강제되므로, 개발 프로세스에 대한 명확한 가이드라인을 제공합니다. 이는 특히 팀 규모가 커질수록 중요합니다.
        

### 고려해야 할 제약 및 단점

1. **초기 개발 오버헤드:**
    
    - 새로운 API를 개발할 때마다 먼저 코어 메뉴 관리 시스템에 `menuCd`를 등록하는 선행 작업이 필요합니다. 초기 개발 단계에서는 약간의 불편함으로 느껴질 수 있습니다.
        
    - API 개발 전에 `menuCd`를 정의하는 것은 기능 정의 단계에서부터 명확한 요구사항 정의가 필요하다는 의미이기도 합니다.
        
2. **유연성 저하 (극단적인 경우):**
    
    - 만약 `menuCd`에 직접적으로 매핑되지 않는 매우 범용적인 API(예: `/api/common/health-check`)가 필요하다면, 이 구조에 어떻게 편입시킬지 고민이 필요합니다. 별도의 예외 규칙이나 특정 `menuCd`를 사용해야 할 것입니다.
        
    - RESTful API의 원칙(URI가 리소스를 나타내야 함)과는 약간 거리가 멀어질 수 있습니다. URI가 `menuCd`라는 "행위"에 더 가깝게 느껴질 수 있기 때문입니다. 하지만 이는 시스템의 권한 관리 편의성을 위한 의도적인 트레이드오프입니다.
        
3. **경로 파싱의 중요성:**
    
    - 백엔드와 OPA 모두 `path[2]`와 같이 URL 경로를 정확하게 파싱하여 `menuCd`를 추출해야 합니다. 경로 설계가 일관되지 않으면 문제가 발생할 수 있습니다.
        

### 결론

제시하신 `backend api를 /api/core/[menuCd]` 기반으로 만들고, 메뉴 관리 시스템에 등록되지 않으면 컨트롤러를 구성하지 못하게 하는 방침은 **매우 바람직한 설계입니다.**

이는 개발 과정에서의 약간의 제약을 통해, **장기적으로는 권한 관리의 복잡성을 획기적으로 줄이고, 보안을 강화하며, 시스템의 일관성을 높이는 효과**를 가져올 것입니다. 특히 OPA와 같은 선언적 정책 엔진을 사용한다면, 이러한 명확한 API 구조는 정책 작성 및 유지보수를 훨씬 더 쉽게 만들어 줄 것입니다.

결론적으로, 로직적 직관성과 장기적인 권한 관리 측면에서 볼 때, **이러한 제약을 감수할 가치가 충분하다**고 생각합니다.