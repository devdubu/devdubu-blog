---
sticker: vault//이미지/개발 로고/TechIconSVG/open-policy-agent.svg

slug: "OPA-개념"
---
# 명령형 언어와 선언형 언어

:::tip OPA의 Rego 언어는 선언형 언어이다.
- 대표적인 선언형 언어는 YAML 이 있다.

:::

## Spring (명령형) vs. OPA Rego (선언형) 정책 구현 속도 비교

복잡한 로직이 추가될수록 속도 이슈는 중요해집니다. Spring과 OPA Rego 간의 속도 차이는 **어떻게 구현하고, 어떤 배포 모델을 사용하며, 정책의 복잡성이 어느 정도인지**에 따라 달라집니다.

### 1. Spring (Java/Kotlin)으로 정책 구현 시 속도
- **구현 방식:** Spring Security, Spring AOP, `@PreAuthorize` 등의 어노테이션이나 수동 권한 로직을 사용하여 Java/Kotlin 코드로 정책을 구현합니다. 이는 **명령형(imperative) 프로그래밍** 방식입니다.
- **장점:**
    - **낮은 초기 지연 시간 (Latency):** 정책 코드가 애플리케이션 프로세스 내부에 직접 통합되어 실행되므로, 외부 네트워크 호출 없이 인메모리에서 바로 실행됩니다.
    - **친숙함:** 기존 백엔드 개발자들에게 익숙한 언어와 프레임워크를 사용하므로 개발 속도가 빠를 수 있습니다.
- **단점:**
    - **정책 변경 시 재배포:** 정책 로직이 변경되면 애플리케이션 코드를 수정하고, 다시 빌드하여 재배포해야 합니다. 이는 배포 주기를 늘리고 운영 오버헤드를 증가시킵니다.
    - **로직의 복잡성 증가:** 비즈니스 정책이 복잡해지고, 사용자 속성, 리소스 속성, 환경 변수 등 다양한 요소를 고려해야 할 경우, `if-else` 문이나 스위치 케이스가 복잡하게 얽혀 코드가 난해해지고 유지보수가 어려워집니다.
    - **분산 환경에서의 일관성 부족:** 여러 마이크로서비스가 각자 권한 로직을 구현하면 정책의 일관성을 유지하기 어렵고, 서비스 간 권한 충돌이 발생할 수 있습니다.


### 2. OPA Rego로 정책 구현 시 속도

- **구현 방식:** Rego 언어로 정책을 작성하고, OPA 엔진이 이 정책을 평가하여 결정을 내립니다. 이는 **선언적(declarative) 프로그래밍** 방식입니다.
- **배포 모델에 따른 속도:**
    - **사이드카(Sidecar) 모드 (가장 빠름):**
        - OPA 인스턴스가 각 백엔드 서비스 옆에서 함께 실행됩니다.
        - 정책 결정을 위한 요청이 **localhost (루프백 인터페이스)**를 통해 이루어지므로, 네트워크 지연이 거의 없습니다 (일반적으로 수 밀리초 이내).
        - 정책 데이터가 OPA 인스턴스에 캐시되므로, 반복적인 질의에 매우 빠르게 응답할 수 있습니다.
        - **가장 이상적인 모델**이며, 이 경우 **Spring 인메모리 구현과 유사하거나, 복잡한 정책에서는 OPA가 더 빠를 수도 있습니다.** OPA는 정책 평가를 위해 C++로 작성된 고성능 WASM 엔진(Rego Policy Engine)을 사용하기 때문입니다.
            
    - **중앙 집중식 OPA 서버 모드:**
        - 여러 백엔드 서비스가 네트워크를 통해 원격 OPA 서버 클러스터에 정책 결정을 요청합니다.
        - 이 경우 **네트워크 왕복 시간(Round Trip Time, RTT)**이 추가됩니다. 수십 밀리초에서 수백 밀리초까지 지연이 발생할 수 있습니다. 이는 Spring의 인메모리 처리보다는 느릴 수 있습니다.
        - 하지만 OPA 서버 자체의 처리 속도는 여전히 빠릅니다.
            
- **장점:**
    - **정책 변경의 유연성:** 정책만 변경하고 OPA를 업데이트하면 되므로, 백엔드 서비스의 재배포 없이 실시간으로 정책을 적용할 수 있습니다.
    - **복잡한 정책의 표현력:** Rego는 JSON/YAML 등 복잡한 계층적 데이터에 대한 정책을 표현하고 추론하는 데 특화되어 있습니다. 복잡한 ABAC(Attribute-Based Access Control) 정책을 Spring 코드보다 훨씬 간결하고 명확하게 작성할 수 있습니다.
    - **일관성:** 모든 서비스가 동일한 OPA 인스턴스를 사용하므로 정책의 일관성이 보장됩니다.
    - **테스트 용이성:** Rego는 내장된 테스트 프레임워크를 제공하여 정책에 대한 단위 및 통합 테스트를 쉽게 작성할 수 있습니다.

### 속도 차이에 대한 결론

**복잡한 로직일수록, 그리고 올바른 OPA 배포 모델을 사용한다면, OPA가 Spring 코드에 비해 **성능상 열위가 아니거나, 오히려 더 유리할 수 있습니다.**

- **단순한 정책 (예: 단순 RBAC):** Spring 인메모리 구현이 OPA 사이드카 모드보다 미세하게 빠를 수 있지만, 실제 사용자 체감 속도에서는 차이가 거의 없을 겁니다. OPA 중앙 서버 모드는 네트워크 RTT만큼 느릴 수 있습니다.
    
- **복잡한 정책 (예: ABAC, 조건부 정책, 계층적 데이터 기반 정책):**
    
    - Spring으로 복잡한 정책을 구현하면 코드의 복잡성이 폭발적으로 증가하여 디버깅 및 유지보수가 매우 어려워질 수 있습니다. 성능 최적화가 어려워지는 지점이 올 수 있습니다.
        
    - OPA는 복잡한 정책 평가에 최적화되어 있으므로, Rego로 작성된 복잡한 정책은 OPA 사이드카 모드에서 Spring의 복잡한 명령형 코드보다 **더 효율적이고 빠르게 평가될 수 있습니다.** 특히 OPA의 정책 캐싱 기능은 반복적인 질의에 대한 응답 시간을 크게 단축시킵니다.
        
    - 이 경우 OPA 중앙 서버 모드도 네트워크 RTT를 감수하고라도 전체적인 아키텍처의 유연성과 유지보수성에서 훨씬 큰 이점을 제공합니다.
        

### 요약 및 제안

|특징|Spring (명령형)|OPA Rego (선언형)|
|---|---|---|
|**속도**|인메모리: 매우 빠름 (네트워크 없음)|사이드카: 매우 빠름 (로컬 네트워크, 캐싱)|
||복잡성 ↑: 성능 저하 가능성|중앙 서버: 네트워크 RTT만큼 지연 가능|
|||복잡성 ↑: OPA 엔진 최적화로 효율적 평가 가능|
|**정책 변경**|코드 수정, 빌드, 재배포 필요|OPA 정책만 업데이트 (재배포 불필요)|
|**로직 분리**|애플리케이션 코드 내 통합|정책 엔진으로 분리 (MSA에 적합)|
|**유지보수**|복잡성 ↑ 시 어려움|Rego 학습 필요, 하지만 정책 자체는 가독성 높음|
|**일관성**|각 서비스별 구현 시 일관성 유지 어려움|중앙 집중식 관리로 일관성 보장|
|**도입 비용**|낮음 (익숙한 스택)|Rego 학습, OPA 배포/관리 인프라 구축|

Sheets로 내보내기

만약 당신의 비즈니스 정책이 다음과 같은 특징을 가진다면, OPA의 도입을 **강력하게 고려**해볼 만합니다:

- 정책이 **자주 변경**되거나, 정책 변경 시 **애플리케이션 재배포를 피하고 싶을 때**.
    
- 정책이 **복잡하고 다양한 속성(사용자, 리소스, 환경)에 기반**하여 결정될 때.
    
- 여러 **마이크로서비스나 시스템 간에 일관된 권한 정책**을 적용해야 할 때.
    
- 정책의 **가독성, 감사 용이성, 버전 관리**가 중요할 때.
    

초기 학습 및 설정 비용을 감수할 의향이 있다면, 장기적으로는 OPA가 복잡한 권한 정책 관리에 훨씬 효율적이고 성능도 충분히 확보할 수 있는 대안이 될 것입니다.
