---
시작 날짜: 2025-05-19
종료 날짜: 2025-05-19
sticker: vault//이미지/개발 로고/TechIconSVG/Node.js.svg
분류: 공부
카테고리:
  - Front
특징:
  - Applicatoin

slug: "FrontEnd-상태-동기화"
---
# 상태 동기화의 함정을 피하는 방법

:::tip 출저 : [상태 동기화를 피하는 방법](https://medium.com/@jiwoochoics/%EB%B2%88%EC%97%AD-%EC%83%81%ED%83%9C-%EB%8F%99%EA%B8%B0%ED%99%94-%ED%95%A8%EC%A0%95%EC%9D%84-%ED%94%BC%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-42096e82d15f)

:::

상태 관리, 상태 동기화에 관한 글 입니다.

이는 대부분 상태 구조를 변경하여 해결 할 수 있습니다.
자세하게는 상태를 여러 조각으로 나눈 뒤 selector, 렌더 함수, 혹은 커스텀 훅에서 상태를 <mark style={{background: 'var(--mk-color-yellow)'}}>다시 합쳐서 활용</mark>하는 것입니다.
이 상태 중 하나가 비어있거나 `undefined`이더라도 UI 가 의도한 항목들을 잘 렌더링 할 수 있다는 점 입니다.

리덕스가 유행하던 시절에는 상태 구조에 대해 많은 논의를 했습니다.
우리는 이를 상태 정규화 라고 불렀습니다.

여전히 중요한 주제이지만, 요즘에는 거의 관심을 받지 못하고 있습니다.

## 예시
초반에는 백엔드에 데이터를 받아와서 뿌려주는 Grid UI를 개발하였습니다.
![Pasted-image-20250519110825.png](/img/이미지 창고/Pasted-image-20250519110825.png)

그러고 시간이 흘러, 고객의 요구 사항 중에서, 새로운 컬럼들이 추가 되기 시작했습니다.

![Pasted-image-20250519110850.png](/img/이미지 창고/Pasted-image-20250519110850.png)

통화(currency), 국가(country) 같은 추가 항목을 고객 측에서도 수집을 하였고, 해당 옵션들을 넣어주기 위해서 우리는 오른쪽 상단 컬럼에 톱니바퀴를 추가하여 해당 컬럼들을 옵션을 주고 추가 할 수 있게 해줍니다.

그렇게 되면 사용자는 이를 동적으로 컨트롤이 가능하며, 컬럼의 상태 또한 변경할 수 있게 해줍니다.
하지만, 이는 보여지는 컬럼들이 변할 수 있기에, 이를 상수로 정의 할 순 없고, <mark>업데이트가 가능한 상태</mark>로 저장해야 합니다.


props 드릴링도 피하기 위해서, 컬럼 상태를 상위 계층의 상태로 저장합니다.
여기서는 예시로 리액트 컨텍스트 `ColnumnCtx` 를 사용하지만 Redus, URL 상태 등 어떤 걸 써도 상관 없습니다.

다시금 시간이 흘러 고객의 비즈니스에서 주문 건수가 매우 많아졌습니다.
그래서 고객은 각 행에 잇는 값을 기준으로 필터링 할 수 있는 기능을 요청했습니다.

![Pasted-image-20250519111347.png](/img/이미지 창고/Pasted-image-20250519111347.png)
단, 사용자는 현재 보이는 컬럼 만을 기준으로 필터링 할 수 있어야 합니다.

새로 filter 컴포넌트를 추가합니다.
이전 커스텀 컬럼 케이스와 마찬가지로, 컬럼 별로 노출되는 필터 목록 항목들도 상황에 따라 바뀔 수 있습니다.

예를 들어 사용자가 고객 이름인 Ondrej를 필터로 선택한다면, `Filter` 컴포넌트에서 해당 필터 값 적용을 위한 `setter` 함수가 호출 됩니다.
이에 따라 `FiltersCtx`에 저장된 현재 필터 적용 상태 부분이 업데이트 되고, 반응형 시스템에 의해 `OrdersList` 컴포넌트가 다시 랜더링 됩니다.
이때 `useOrders` 훅은 업데이트 된 필터 상태를 참조해, 새로운 `filters` 값을 기반으로 데이터를 다시 요청합니다.

위에서 필터 영상을 확인 할 수 있습니다.

## 상태 초기화
막상 코드를 실행하면, 필터가 하나도 보이지 않는 것을 알 수 있습니다.

그 이유는 필터 컨텍스트가 비어있기 때문입니다.
필터 상태를 초기화해줄 필요가 있습니다.
`useState`는 초기 값을 설정하는 기능을 제공하므로, 이를 활용하면 됩니다.
![Pasted-image-20250519124004.png](/img/이미지 창고/Pasted-image-20250519124004.png)

이제 필터가 표시 되긴 합니다.
하지만, 노출되는 컬럼을 추가하거나 제거할 때, 노출 되어야 하는 필터 목록도 함께 업데이트 되지 않습니다.

정리해보자면 원하는 동작은 다음과 같습니다.

사용자가 새로운 컬럼 항목을 추가하면, 해당 컬럼에 대한 필터 항목도 함께 추가되어야 합니다.
다시 말해, 컬럼 상태와 필터 상태를 동기화 해야 합니다.

혹시 아래 코드로 해결할지도 모르겠네요

```js
function FiltersProvider() {
	const [columns] = useContext(ColumnsCtx)
	const [ ... ] = useState(columns)
}
```

.필터의 노출여부는 여전히 업데이트되지 않습니다. 
왜냐하면 `useState`의 초깃값은 첫 렌더링 시에만 적용되기 때문입니다. 
따라서 필터 목록 상태를 <mark>어떤 방식으로든 업데이트</mark>해 줘야 합니다.

## 상태 동기화
:::tip 결국은 따로 동작하는 저 부분의 로직들을 동기화 시켜주기 위해서 이정도의 빌드업을 진행한 것,,,

:::

### 직접 Setter 호출

:::success ➕ 👍 **간단함**

:::

:::error ➖👎 **장기적으로 유지보수에 불리함.**





:::

![Pasted-image-20250519124437.png](/img/이미지 창고/Pasted-image-20250519124437.png)

```ts
const onAddColumnClick = (attribute) => {  
	addColumn(attribute);  
	addFilter(attribute);  
};
```

이렇게 한다면, 작동은 잘 될 것입니다.
하지만, 컬럼 노출 제거 핸들러의 필터 목록 동기화는 깜빡하고 추가 안했네요;;
- 시간이 지나고, , 컬럼들을 기본 값으로 초기화하는 기능을 구현하는 중입니다. 
- 앗…! 여기서도 필터 목록 초기화를 깜빡했네요. 다시 2029년, 컬럼 목록 프리셋 설정 기능을 구현하고 있습니다. 
- 앗! 이번에도 필터 업데이트를 잊었습니다.
- 그리고 2030년, 또다시.. 오 이런…
위 상황을 보면서 알다 싶이 컬럼 목록 상태를 업데이트 하는 새로운 기능을 추가할 때마다 필터 목록 상태도 함께 업데이트 하는 것을 놓치지 말아야합니다.
이것 유지보수는 어렵고 실수가 잦을 수 밖에 없는 구조 입니다.

### 중앙 gete setter 방식

:::success ➕ 👍 **유지보수성이 향상됨**

:::

:::error ➖👎 **병합 함수가 필요함**

:::

:::error ➖👎 **의존 방향이 직관과 반대임**

:::

:::error ➖👎 **순환 참조 가능성이 있음**


:::

```ts
function ColumnsProvider() {  
	const [columns, setColumnsInner] = useState(initColumns)  
	const { setFilters } = useContext(FiltersContext)  
	const setColumns = (columns) => {  
		setColumnsInner(columns)  
			setFilters(columns)  
		}  
		// setColumnsInner 대신 setColumns를 사용하세요.  
	...  
}
```

그래서 자연스럽게 상태 업데이트 로직을 중앙 집중화 하게 되었고, setter 함수를 상태가 정의된 곳 가까이로 옮겨, 
모든 업데이트가 반드시 거쳐야 하는 일종의 gate를 만들었습니다.
`ColumnsProvider` 에서는 이를 위해 `setColumns` 라는 래퍼 함수를 구현했습니다.

처음에는 잘 작동합니다.
그런데,, 새로운 컬럼을 추가하면 기존 필터 적용 상태 부분은 초기화 돼버립니다.
따라서 변경된 필터만 수정하는 병합 함수를 작성해야 합니다.

```ts
const setColumns = (columns) =>{
	setColumnsInner(columns)
	setFilters((preFilters) => mergeFilters(prevFilters, columns))
}
```

이 방식은 분명 이전보다는 더 나은 접근이긴 하지만, 저 처럼 생각하는 사람이라면 장기적으로 여전히 취약하다고 느낄 수 있습니다.
몇년이 지나고, 새로운 동료들이 프로젝트에 합류했다면, 
이 룰을 잘 모르는 누군가가 gate 를 통한 `setColumns`가 아닌 <mark>`setColumnsInner`를 직접 호출하는 코드</mark>를 작성할 지도 모릅니다.

또한 `ColumnsProvider`가 `FiltersContext` 에 의존한다는 것이 직관적이지 않고, 혼란스럽게 느껴졋습니다.
개인적으로 오히려 반대 방향의 의존 관계를 기대했습니다.

그리고 위에서 설명한 초기화 로직을 기억한다면, `FilterProvider`는 필터 초기화를 위해 `ColumnsContext`에 의존하고 있다는 점을 떠올릴 수 있을 것입니다.

이에 따라 <mark>순환 참조 문제</mark>가 생길 수 있습니다.

따라서 필터를 초기화 할 때는 `ColumnsContext`를 참조하지 않고, 초깃값을 상수로 설정하는 방식을 택해야 합니다.
하지만, 이렇게 하면 컬럼의 초깃 값과 필터의 초깃값이 항상 일치하도록 별도로 관리 해야 하는 부담도 생깁니다.

### Effect를 사용하기

:::success ➕ 👍 **유지보수 측면에서 좋음**

:::

:::success ➕ 👍 **이상한 의존 관계가 없음**

:::

:::error ➖👎 **비동기 업데이트**

:::

:::error ➖👎 **UI 이상 현상이나 버그 발생 가능**

:::

:::error ➖👎 **중복 fetch 발생**

:::

:::error ➖👎 **필터 merge 함수 필요.**

:::

![Pasted-image-20250519131510.png](/img/이미지 창고/Pasted-image-20250519131510.png)

```ts
const [columns] = useContext(ColumnCtx)
const [setFilters] = useContext(FiltersCtx)
useEffect(()=>{
	setFilters((preFilters) => mergeFilters(prevFilters, columns))
})
```

여기서 `useEffect`를 떠올릴 수도 있습니다.
컬럼 상태가 변경될 때마다 반응 하도록 만들 수 있습니다.

그런데 마찬가지로 여기서도 다시 `mergeFilters` 함수를 사용해야 필터 적용 상태 전체가 초기화되는 일을 막을 수 있습니다.

하지만, 그보다 더 큰 문제가 있습니다.
`useEffect`는 동기적으로 동작하지 않으며, 렌더링과 동일한 사이클에서 실행되지 않습니다.
그래서 새 컬럼을 추가했을 때, 필터가 즉시 실행되지 않고, 잠간 동안 필터와 컬럼 상태가 불일치하는 시점이 생기게 됩니다.

이건 여러 버그나 UI 이상 현상의 원인이 될 수 있습니다.
UI 가 갑자기 깜빡이고, 되돌아가는 등 시각적으로 불안정하며, 애니메이션이 깨지거나 튀는 현상이 발생할 수 있습니다.

그러나 더 중요한 문제는, 두 번의 재 요청으로 인한 성능 저하, 불필요한 서버 부하, 비용 증가로 이어진다는 점 입니다.
노출 컬럼을 바꿔보면, 요청 횟수 카운터가 두 번씩 증가하는 현상을 볼 수 있습니다.

### Selector 사용하기

:::success ➕ 👍 **유지보수 용이**

:::

:::success ➕ 👍 **이상한 의존 관계없음**

:::

:::success ➕ 👍 **동기적 업데이트**

:::

:::success ➕ 👍 **UI 버그 없음.**

:::

:::success ➕ 👍 **단일 fetch로 처리됨**

:::

:::error ➖ 👎 **상태가 과도하게 유지됨 (필터가 지나치게 오래 남아 있음)**

:::

![Pasted-image-20250519132418.png](/img/이미지 창고/Pasted-image-20250519132418.png)

```ts
function useFilters() {  
	const [attributes] = useContext(AttributesCtx);  
	const [filters] = useContext(FiltersCtx);  
	return attributes.map((attribute) => {  
		const filter = filters[attribute];  
		return { attribute, ...filter };  
	});  
}
```

```ts
type Filters = {  
	[attribute: string]: {  
		operator?: '='|'>'|'<',  
		value?: string|number  
	}  
}
```

우리가 마주한 문제는 중복된 상태로 인해 발생한 상태 동기화 문제입니다.
필터와 컬럼은 서로 다른 개체이지만, 그들의 상태 중 <mark>일부가 중복</mark>되었으며, 공유 가능합니다.
그것은 바로 노출 되어야 하는 항목입니다.

그래서 두 상태에서 노출되어야 하는 항목을 별도 상태로 추출합니다.
그리고 그 상태를 기반으로 노출 되어야 하는 컬럼과 필터를 파생 상태로 만드는 것이죠.

우리가 필터 상태를 만들고 있었던 시점으로 돌아 가보면,
우리는 이제 필터 상태의 역할을 바꾸려고 합니다.

필터 상태는 어떤 필터 항목의 <mark>노출 여부를 저장</mark>하는 것이 아니라, 
단지 <mark>어떤 항목이 필터링 되고</mark> 있는지만, 저장합니다.

이를 위해 필터 상태의 구조를 딕셔너리 형태로 재구성합니다.

그러면, `useFilters` 훅에서는 노출된 항목 상태와 사용자가 수정한 필터 상태, 이 두 가지를 병합해 최종적으로 보일 필터 항목 목록을 생성합니다.
이 방식의 장점은 필터 노출 상태를 별도로 초기화 할 필요가 없다는 점입니다.
또한 컬럼 상태가 단순히 항목 정보만 담고 있기 때문에, 노출 항목 정보 만으로도 기존 컬럼 상태의 역할을 충분히 대처할 수 있습니다.

![Pasted-image-20250519141614.png](/img/이미지 창고/Pasted-image-20250519141614.png)

이 방식에서는 노출되는 필터 목록은 항상 컬럼 목록과 일치하게 됩니다.
필터 상태가 비어 있어도, 초기화할 필요가 없습니다.
변경은 동기적으로 이루어지며, UI 버그도 없고, 불필요한 재요청도 발생하지 않습니다.

변경은 동기적으로 이루어지며, UI 버그도 없고, 컬럼 목록 상태는 어떤 방식으로든 자유롭게 변경될 수 있고, 반응형 시스템이 알아서 파생되는 로직을 다시 실행해줍니다.

물론 누군가 useFilters 같은 전용 훅을 사용하지 않고, 필터 상태에 직접 접근해 버릴 수도 있지 않냐고 반론할 수 있습니다.
그 말이 맞습니다.
그렇다면 이 방식이 `setColumns` 래퍼 함수 방식에 비해 가지는 장점이 무엇일까요?
제 생각에는, 이 훅을 빼먹는 경우는 오히려 더 드물 것이라고 봅니다.

왜냐하면 이 훅을 사용하지 않으면, 즉시 상태가 비어있는 결과가 나타나기 때문에, 실수를 금방 눈치챌 수 있기 때문입니다.
그리고 이런 파생 로직은 selector 은 setter(action)보다 유지 보수가 더 쉽습니다.
왜냐하면 이 로직은 반응형으로 자동 실행되므로, 우리는 언제 이 로직을 실행할지 고민할 필요 없이 무엇을 제어할지 만에 집중하면 됩니다.
실행 시점은 반응형 시스템이 알아서 처리해 줍니다.

사실 이 방식에는 숨겨진 사용자 경험 차이가 있다고 볼 수 있습니다.
어떤 항목에 필터가 적용된 상태에서 해당 항목이 제거 되었다가 다시 추가 되면, 이전의 필터 값이 그대로 유지 됩니다.
따라서 컬럼을 다시 추가했을 때, 주문 목록은 여전히 필터링 된 상태로 표시됩니다.
위의 인터랙티브 예제에서 직접 확인해볼 수 있습니다.

사실 이 방식에는 숨겨진 사용자 경험 차이가 있다고 볼 수 있습니다.
어떤 항목에 필터가 적용된 상태에서 해당 항목이 제거 되었다가 다시 추가되면, 이전의 필터 값이 그대로 유지됩니다.
따라서 컬럼을 다시 추가했을 때, 주문 목록은 여전히 필터링 된 상태로 표시됩니다.


# 결론

결국 위 글에서 하고 싶은 말은, dependancies 를 띄어내는데 의의가 있다.
어찌보면 1,2 번까지는 쉽게 이해할 수 있지만, 3번 부터는 이해하기가 난해할 것이다.

결론만 말하자면, 다시 한번 생각해보는 기회를 준다.

## Store에 역할을 너무 과중 하게 준 것은 아닌가?

우리는 Store라는 기술, 기능을 익히 알고 있는 건 <mark>상태 관리</mark>이다.
하지만, 어찌 보면 자연스럽게, 우리는 상태 관리만 진행하는 것이 아닌, 내부에 <mark>로직을 하나하나 넣고</mark> 있는 우리 자신을 볼 수 있다.

사실 어찌보면, 역할에 대한 부분을 보면 Store는 <mark>상태만 관리</mark>하면 되는 것이다.
하지만, 우리는 여기에, 상태만 넣는 것이 아닌, 
어떻게 꺼낼 것인지, 꺼낼 때 어떤 값을 꺼낼지 라는 로직을 슬슬 넣고 있다.

과연 이 부분들이 최소 책임과 하나의 역할 이라는 개념이 그대로 적용이 되는 요소인가? 라고 다시 되짚어 볼 필요가 있어보인다.

우리가 당연하게 사용했던 Store의 역할을 다시금 재 해석해볼 필요가 있다.

그렇게 생각해보면 해당 문제는 쉽게 풀린다.

즉, 결국 Store는 상태만 관리하기에, 해당 상태에 대한 판단은 다른 로직에 이관한다.
위에서 예와 마찬가지로, 행과 열의 필터를 가졌더라면, 공통적으로 나오는 요소들이 분명히 존재합니다.

이때 Store상에서 해당 데이터를 get 할 때, Store 자체적으로 해당 데이터를 판단하기 보단,
해당 <mark>데이터를 꺼내온 후</mark>에, 판단하여 merge를 시켜주는 것이 깔끔한 해결책이라는 것이죠

즉, 판단된 데이터를 꺼낸 것이 아닌, 꺼낸 후 판단 이라는 순서만 역전 시키게 되면 깔끔하게 해결되는 문제들입니다.


