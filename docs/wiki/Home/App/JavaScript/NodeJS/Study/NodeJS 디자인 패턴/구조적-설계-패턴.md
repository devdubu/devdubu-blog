---
sticker: vault//이미지/개발 로고/TechIconSVG/Node.js.svg
시작 날짜: 2025-05-19
종료 날짜: 2025-05-30
분류: 공부
카테고리: Architecture
특징: 

slug: "구조적-설계-패턴"
---
이 장을 통해 반응형 프로그래밍(RP: Reactive Programming)과 같은 몇가지 흥미로운 개념을 살펴보고 NodeJS 생태계에서 일반적으로 채택되는 데이터베이스 기술인 LevelDB를 사용하여 시간을 보낼 것입니다.

# 프록시
프록시는 Subject 라고 하는 다른 객체에 대한 액세스를 제어하는 객체 입니다
프록시와 Subject는 동일한 인터페이를 가지며, 이를 통해 투명하게 하나를 다른 것으로 바꿀 수 있습니다.
실제로 이 패턴의 다른 이름은 서로 게이트 (surrogate) 입니다.

프록시는 Subject에 대해 실행되는 작업의 전부 또는 일부를 가초채서 해당 동작을 증강하거나 보완 합니다.
![Pasted-image-20250521231259.png](/img/이미지 창고/Pasted-image-20250521231259.png)

위 그림은 프록시와 Subject 가 동일한 인터페이스를 갖는 방법과 이 인터페이스가 클라이언트에게 얼마나 투명한지 보여줍니다.
클라이언트 둘 중 하나를 서로 바꿔 사용할 수 있습니다.
프록시는 각 작업을 Subject에 전달하여 추가 전처리 또는 후 처리를 통해 동작을 향상 시킵니다.

:::Tip 클래스 간의 프록시 역할을 말하는 것이 아닙니다.
- 프록시 패턴은 대상 Subject 의 실제 인스턴스를 감싸서 내부 상태를 보존합니다.

:::

프록시는 다음과 같은 상황에서 유용할 수 있습니다.
- **데이터 검증**
	- 프록시가 입력을 Subject에 전달하기 전에 입력의 유효성을 검사합니다.
- **보안**
	- 프록시는 클라이언트가 작업을 수행할 권ㅎ나이 있는지 확인ㅇ하고, 권한이 있는 경우에만 요청을 Subject에게 전달합니다.
- **캐싱**
	- 데이터가 아직 캐시에 없는 경우에만 프록시 작업이 Subject에서 실행되도록 프록시는 내부에 캐시를 유지합니다.
- **느린 초기화**
	- Subject을 생성하는데 많은 비용이 드는 경우, 프록시는 실제로 필요할 때까지만 이를 지연시킬 수 있습니다.
- **기록**
	- 프록시는 메서드 호출과 관련 매개 변수를 가로채서 발생시 이를 기록합니다.
- **원격 객체**
	- 프록시는 원격 개체를 가져와서 로컬로 표시할 수 있습니다.

## 프록시 구현 기술
객체를 프록시 할 때, 모든 함수들을 가로채거나 일부만 가로채고 나머지는 Subject가 직접 처리하도록 위임할 수 있습니다.
이를 가능하게 하는 몇 가지 방법이 있는데, 이 섹션에서는 그 중 일부를 소개합니다.
다음과 StackCalculator 클래스의 간단한 예제를 가지고 작업을 해보겠습니다.



이 장을 통해 반응형 프로그래밍(RP: Reactive Programming)과 같은 몇가지 흥미로운 개념을 살펵보고 NodeJS 생태계에서 일반적으로 채택되는 데이터베이스 기숭인 LevelDB를 사용하여 시간을 보낼 것입니다.

# 프록시
프록시는 Subject 라고 하는 다른 객체에 대한 액세스를 제어하는 객체 입니다
프록시와 Subject는 동일한 인터페이를 가지며, 이를 통해 투명하게 하나를 다른 것으로 바꿀 수 있습니다.
실제로 이 패턴의 다른 이름은 서로 게이트 (surrogate) 입니다.

프록시는 Subject에 대해 실행되는 작업의 전부 또는 일부를 가초채서 해당 동작을 증강하거나 보완 합니다.
![Pasted-image-20250521231259.png](/img/이미지 창고/Pasted-image-20250521231259.png)

위 그림은 프록시와 Subject 가 동일한 인터페이스를 갖는 방법과 이 인터페이스가 클라이언트에게 얼마나 투명한지 보여줍니다.
클라이언트 둘 중 하나를 서로 바꿔 사용할 수 있습니다.
프록시는 각 작업을 Subject에 전달하여 추가 전처리 또는 후 처리를 통해 동작을 향상 시킵니다.

:::Tip 클래스 간의 프록시 역할을 말하는 것이 아닙니다.
- 프록시 패턴은 대상 Subject 의 실제 인스턴스를 감싸서 내부 상태를 보존합니다.

:::

프록시는 다음과 같은 상황에서 유용할 수 있습니다.
- **데이터 검증**
	- 프록시가 입력을 Subject에 전달하기 전에 입력의 유효성을 검사합니다.
- **보안**
	- 프록시는 클라이언트가 작업을 수행할 권ㅎ나이 있는지 확인ㅇ하고, 권한이 있는 경우에만 요청을 Subject에게 전달합니다.
- **캐싱**
	- 데이터가 아직 캐시에 없는 경우에만 프록시 작업이 Subject에서 실행되도록 프록시는 내부에 캐시를 유지합니다.
- **느린 초기화**
	- Subject을 생성하는데 많은 비용이 드는 경우, 프록시는 실제로 필요할 때까지만 이를 지연시킬 수 있습니다.
- **기록**
	- 프록시는 메서드 호출과 관련 매개 변수를 가로채서 발생시 이를 기록합니다.
- **원격 객체**
	- 프록시는 원격 개체를 가져와서 로컬로 표시할 수 있습니다.

## 프록시 구현 기술
객체를 프록시 할 때, 모든 함수들을 가로채거나 일부만 가로채고 나머지는 Subject가 직접 처리하도록 위임할 수 있습니다.
이를 가능하게 하는 몇 가지 방법이 있는데, 이 섹션에서는 그 중 일부를 소개합니다.
다음과 StackCalculator 클래스의 간단한 예제를 가지고 작업을 해보겠습니다.

```ts
class StackCalculator{
	constructor(){
		this.stack = []
	}
	
	putValue(value){
		this.stack.push(value)
	}
	
	getValue() {
		return this.stack.pop()
	}

	peekValue(){
		return this.stack[this.stack.length - 1]
	}

	clear(){
		this.stack = []
	}

	divide() {
		const divisor = this.getValue()
		const dividend = this.getValue()
		const result = diviend / divisor
		this.putValue(result)
		return result
	}

	multiply(){
		const multiplicand = this.getValue()
		const multiplier = this.getValue()
		const result = multiplier * multiplier
		this.putValue(result)
		return result
	}
}
```

이 클래스는 스택 계산기를 단순화 하여 구현합니다.
이 계산기의 아이디어는 모든 피연산자(값)을 스택에 유지하는 것입니다.
예를 들어 곱셈과 같은 연산을 수행 하면  승수와 피승수 값이 스택에서 추출되고 곱셈 결과가 스택으로 다시 푸시됩니다.

이것은 휴대폰의 계산기 프로그래밍 실제로 구현되는 방식과 크게 다르지 않습니다.

다음은 `StackCalculator` 를 사용하여 곱셈과 나눗셈을 수행하는 방법의 한가지 예시입니다.

```ts
const calculator = new StackCalculator()
calculator.putValue(3)
calculator.putValue(2)
console.log(calculator.multiply()) // 3 * 2 = 6

calculator.putValue(2)
console.log(calculator.multiply()) // 6 * 2 = 12
```

클래스에는 스택의 맨 위에 값(마지막으로 삽입된 값 또는 마지막 작업의 결과)을 알아볼 수 있는 `peekValue()` 및 스택을 다시 설정할 수 있는 `clear()` 와 같은 유틸리티 함수들도 있습니다.

재미있는 사실: JavaScript에서는 0으로 나누면 Infinity라는 희한한 값이 반환됩니다.
다른 많은 프로그래밍 언어에서 0으로 나누는 것은 프로그램이 패닉을 일으키거나 런타임 에러를 던지는 결과를 발생시키는 잘못된 연산 입니다.

이후 몇 개의 섹션에서는 프록시 패턴을 활용하여 0으로 나눌 때 , Infinity를 반환하는 대신 명시적인 오류를 생성시키는 보다 보수적인 동작을 하도록 `StackCalculator` 인스턴스의 기능을 변경할 것입니다.

### 객체 컴포지션
컴포지션은 기능을 확장해서 사용하기 위해 객체를 다른 객체와 결합하는 기술입니다.
특정 프록시 패턴의 경우 Subject와 동일한 인터페이스를 가진 객체가 생성되고 Subject에 대한 참조가 인스턴스 변수나 클로저 변수의 형태로 프록시 내부에 저장됩니다.

Subject는 생성시 사용자가 주입 시키거나 프록시 자체에서 생성될 수 있습니다.
아래 예시에서는 객체 컴포지션을 사용하여 안전한 계산기를 구현하고 잇습니다.

```js
class SafeCalculator{
	constructor(calculator){
		this.calculator = calculator
	}

	// 프록시 함수
	divide(){
		const divisor = this.calculator.peekValue()
		if(divisor === 0){
			throw Error ('Division by 0')
		}

		// Subject에 대한 유효한 위임자(delegate)일 경우
		return this.calculator.divide()
	}

	// 위임된 함수들
	putValue(value){
		return this.calculator.putValue(value)
	}

	getValue(){
		return this.calculator.getValue()
	}

	peekValue(){
		return this.calculator.peekValue()
	}

	clear(){
		return this.calculator.clear()
	}

	multiply(){
		return this.calculator.multiply()
	}
}



const calculator = new StackCalculator()
const safeCalculator = new SafeCalculator(calculator)

calculator.putValue(3)
calculator.putValue(2)
console.log(calculator.multiply()) // 3*2 = 6

safeCalculator.putValue(2)
console.log(safeCalculator.multiply()) // 6*2 = 12

calculator.putValue(0)
console.log(calculator.divide()) // 12/0 = Infinity

safeCalculator.clear()
safeCalculator.putValue(4)
safeCalculator.putValue(0)
console.log(safeCalculator.divide()) // 4/0 -> 에러

```

`safeCalculator` 객체는 원래의 `calculator` 인스턴스의 프록시 입니다.
`safeCalculator`에서 `multiply()` 함수를 호출하면, `calculator`에서 동일한 함수를 호출하게 됩니다.
`divide()` 도 마찬가지지만, 이 경우 0으로 나누려고 하마녀, 이것은 Subject 에서 수행하는 혹은 프록시에서 수행하는지에 따라 다른 결과를 얻을 수 있다는 것을 알 수있습니다.

주의할 점은 `calculator(스택 내의 값들)` 상태는 여전히 `calculator` 인스턴스에 의해 유지된다는 것입니다.
`safeCalculator`는 필요에 따라 값을 읽거나 값의 변경을 위해 `calculator`의 함수를 호출합니다.

앞의 코드에서 보여준 프록시 구현의 또 다른 방법으로 객체 리터럴과 팩토리 함수를 사용할 수 있습니다.

```js
function createSafeCalculator(calculator){
	return {
		divide(){
			// 프록시 된 함수
			const divide = calculator.peekValue()
			if(divide === 0){
				throw Error('Division by 0')
			}
			// Subject 에 댛나 유요한 위임자(delegate) 일 경우
			return calculator.dividie()
		}
		// 위임된 함수들
		putValue(){
			return calculator.putValue(value)
		},
		getValue(){
			return calculator.getValue()
		},
		peekValue(){
			return calculator.peekValue()
		}.
		clear(){
			return calculator.clear()
		},
		multiply(){
			return calculator.multiply()
		}
	}
}

const calculator = new StackCalculator()
const safeCalculator = createSafeCalculator(calculator)
```

이 구현은 클래스 기반의 구현보다 더 간단하고 간결하지만 다시 한번 모든 함수들을 Subject에 명시적으로 위임하도록 합니다.

복잡한 클래스의 수 많은 함수를 위임해야하는 것은 매우 반복적일 수 잇어, 이런 방식의 구현이 더 어려워질 수 있습니다.
대부분의 함수르 위임해야하는 프록시를 만들 수 있는 한가지 방법은 [delegates](https://www.npmjs.com/package/delegates) 와 같이 모든 함수를 생성해주는 라이브러리를 사용하는 것입니다.
보다 현대적이고 근본적인 대안은 이 장의 뒷부분에서 설명할 Proxy 객체를 사용하는 것입니다.

### 객체 확장(Object augmentation)
객체 확장(또는 몽키 패치)은 아마도 객체가 가진 몇몇 함수를 프록시 하는 가장 간단하고 일반적인 방법일 것입니다.
이것은 함수를 프록시의 구현으로 대체하여 Subject를 직접 수정하는 작업들을 포함하고 있습니다.

계산기 예제에는 다음과 같이 적용할 수 있습니다.
```ts
function patchToSafeCalculator(calculator){
	const divideOrig = calculator.divide
	calculator.divide = () =>{
		// 추가적인 검증 로직
		const divisor = calculator.peekValue()
		if(divisor === 0){
			throw Error('Division by 0')
		}

		// Subject에 유효한 위임자일 경우
		return divideOrig.apply(calculator)
	}

	return calculator
}

const calculator = new StackCalculator()
const safeCalculator = patchToSafeCalculator(calculator)
```

이 기술은 한 두개의 함수를 프록시 할 때 확실히 편합니다.
여기서 `multiply()` 함수를 비롯하여 다른 모든 위임된 함수를 구현할 필요가 없다는 것을 눈치 채셨나요?
불행하게도 이 단순함은 대상 객체를 직접 변경하기 때문에, 위험할 수 있습니다.

:::tip Subject가 코드 기반으로 다른 부분과 공유되었을 경우, 이는 무조건 피해야하는 방법입니다.
- 실제로 subject를 몽키패치하면 애플리케이션의 다른 컴포넌트에 영향을 미쳐 바람직하지 않은 부작용이 발생할 수 있습니다.
- Subject가 제한된 컨텍스트나 프라이빗 범위에 있는 경우에만 이 기술을 사용하십시오
- 몽키패치가 위험한 이유를 알고 싶을 경우,
- 원래 calculator 인스턴스에서 0으로 나누기를 호출해보면 알 수 있습니다.
- 그렇게 되면 infinity가 이닌, 오류를 발생시킵니다.
- 원래의 동작이 변경되어 애플리케이션의 다른 부분에 기대치 않은 영향을 미칠 수 있습니다.

:::

다음 섹션에서는 프록시 패턴 등 구현 하기 강력한 대안으로, 기본적으로 제공하는 Proxy 객체를 살펴보겠습니다.

### 내장 프록시 객체
ES2015 사양에서 강력한 프록시 객체를 만드는 근원적인 방법을 도입했습니다.
ES2015 Proxy 객체는 생성자가 대상(target)과 핸들러를 인자로 받아들입니다.

```ts
const proxy = new Proxy(target, handler)
```

여기서 target은 프록시가 적용될 객체(우리의 정의에 따르면, Subject)를 나타내며, 핸들러는 프록시의 동작을 정의하는 특수한 객체 입니다.

핸들러 객체에는 해당 작업이 프록시 인스턴스에서 수행될 때 자동으로 호출되는 트랩 함수(예 : apply, get, set 및 has) 라는 미리 정의된 이름을 가진 일련의 부가적인 함수들이 포함됩니다.

이 API 의 동작 방식을 보다 잘 이해하기 위해 Proxy 객체를 사용하여, <mark>안전한 계산기 프록시</mark> 를 구현하는 방법을 살펴보겠습니다.

```ts
const safeCalculatorHandler = {
	get:(target, property) => {
		if(property === 'divide'){
			// 프록시 된 함수
			return function(){
				// 추가적인 검증 로직
				const divisor = target.peekValue()
				if(divisor === 0){
					throw Error('Division by 0')
				}
					// Subject에 대한 유효한 위임자일 경우
					return target.divide()
			}
		}

		// 위임된 함수들과 속성들
		return target[property]
	}

	const calculator = new StackCalculator()
	const safeCalculator = new Proxy(calculator, safeCalculatorHandler)
	
}
```

Proxy 객체는 사용한 이 안전한 계산기 프록시의 구현에서 원래 객체의 속성과 함수에 함수에 대한 접근을 가로채기 위해 get 트랩 함수를 사용하였습니다.
프록시는 `divide()` 에 대한 액세스 가로채고 0으로 나누는 것인지를 검사하는 추가적인 로직이 구현된 새로운 버전의 함수를 반환합니다.
`target[property]` 을 사용하여 다른 모든 함수와 속성을 변경하지 않고도 간단하게 반환할 수 있다는 점을 잘 살펴두십시오

결과적으로 Proxy 객체를 사용하면 다른 모든 속성과 함수를 명시적으로 위임할 필요가 없으며, 변경하려는 부분만 프록시 하기 쉬울 뿐 아니라 Subject의 코드 변경을 방지 할 수 있음을 알 수 있습니다.

## Proxy 객체의 추가적인 기능과 제약사항

Proxy 객체는 JavaScript 언어 자체에 깊이 통합된 기능으로, 개발자가 객체에서 수행할 수 있는 많은 작업을 가로채고 재지정할 수 있습니다.
이 특성은 메타 프로그래밍, 연산자 오버로딩 및 객체 가상화와 같이 이전에 쉽게 달성할 수 없었던 새롭고 흥미로운 사용 방법을 제공합니다.

```js
const evenNumbers = new Proxy([],{
	get: (target, index) => index * 2
	has: (target, number) => number % 2 === 0
})

console.log(2 in evenNumbers) // true
console.log(5 in evenNumbers) // false
console.log(evenNumbers[7])
```

이 예제에서, 우리는 모든 짝수를 포함한 가상의 배열을 생성하였습니다.
이것은  평범한 배열 처럼 사용될 수 있습니다.

즉, 평범한 배열 구문(예 : 2 in eventNumbers)를 사용하여 특정 항목이 존재하는지 검사할 수 있습니다.
배열은 데이터를 내부에 저장하지 않으므로 가상의 배열입니다.

:::tip 앞의 코드는 Proxy 객체의 고급 기능 중 일부를 보여주기 위한 재미있는 예이지만, Proxy 패턴을 구현한 것은 아닙니다.
- 이 예제를 통해 Proxy 객체는 일반적으로 프록시 패턴(명칭의 유례)를 구현하는데도 사용되지만 다른 패턴 및 사례를 구현하는 데서도 사용될 수 있음을 알 수 있습니다.
- 예를 들어, 이 장의 뒷 부분에서 Proxy 객체를 사용하여 데코레이션 패턴을 구현하는 방법을 살펴볼 것 입니다.

:::

구현을 살펴보면 프록시는 빈 배열을 대상으로 사용하며 핸들러에 get 과 has라는 트랩을 정의합니다.
- get 트랩은 배열의 요소에 대한 접근을 가로채서 주어진 인덱스에 대한 짝수를 반환합니다.
- has 는 in 연산자의 사용을 가로채서 주어진 숫자가 짝수인지 여부를 확인합니다.

Proxy 객체는 set, delete 그리고 construct 같은 또 다른 흥미로운 트랩을 지원하며, 요청 시 모든 트랩을 비활성화 하고 대상 객체의 원래 동작으로 복원할 수 있는 프록시를 생성할 수 있습니다.

이러한 모든 기능을 분석하는 것은 이 장의 범위를 벗어나며, 여기서 중요한 것은 Proxy 객체가 프록시 디자인 패턴을 구현하기 위한 강ㄱ력한 기반을 제공하고 있다는 사실을 아는 것입니다.

:::note Proxy 객체가 제공하는 모든 기능과 트랩 함수들이 궁금하다면 [Proxy 관련](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)관련 MDN 글을 참조하십시오

:::

Proxy 객체는 JavaScript 언어의 강력한 기능이지만, 매우 중요한 제약이 있습니다.
Proxy 객체는 완전히 트랜스파일(transplie) 되거나 폴리필(polyfill) 될 수 없습니다.

이는 Proxy 객체 트랩 중 일부는 런타임  수준에서만 구현할 수 있고, 일반 JavaScript로 간단히 재작성할 수 없기 때문입니다.
이는 Proxy 객체를 직접적으로 지원하지 않는 예전 브라우저 또는 NodeJS 의 이전 버전에서 작업해야 할 경우 알아야할 사항입니다.

:::note Transpliaction
- Transcompilation의 약자 입니다.
- 소스 코드를 한 소스 프로그래밍 언어에서 다른 소스 프로그래밍 언어로 변역하여 컴파일 하는 동작을 나타냅니다.
- JavaScript의 경우 이 기술은 JavaScript의 새로운 기능을 사용하는 프로그램을 지원하지 않는 이전 런타임 환경에서도 실행할 수 있는 동등한 프로그램으로 변환하는 것을 의미합니다.

:::

:::tip Polyfill
- 일반 JavaScript에서 표준 API 에 대한 구현을 제공하고 이 API를 사용할 수 없는 환경(일반적으로 이전 브라우저나 런타임)에서 가져다 쓸 수 있는 코드 입니다.
- [core-js](https://github.com/zloirock/core-js) 는 JavaScript 를 윈한 가장 완벽한 Polyfill 라이브러리 중 하나 입니다.

:::

## 여러 프록시 기술의 비교
컴포지션은 원래 동작을 변경하지 않고 대상을 그대로 두기 때문에, 프록시를 만드는 간단하고 안전한 방법으로 여길 수 있습니다.
유일한 단점은 함수 중 하나만 프록시 하려는 경우에도 모든 함수들은 수동으로 위임해야 한다는 것입니다.
또한 Subject의 속성에 대한 접근 권한을 위임해야 할 수도 있습니다.

:::note Object를 이용해서 Object의 속성을 위임할 수도 있습니다.
- 이에 대해서는 [해당 사이트](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)를 참조하십시오

:::

반면에 Subject를 수정하는 객체 확장은 항상 이상적인 것은 아니지만 위임과 관련된 여러가지 불편함을 겪지 않습니다.
이러한 이유로, 이 두가지 접근 방식 중 Subject를 수정해야하는 모든 상황엥서 객체 확장이 선호되는 기술입니다.

그러나 컴포지션이 반드시 필요한 상황이 몇 가지 있습니다.

예를 들어 필요 시에만 생성(초기화 지연 lazy initialization)하는 것과 같이 Subject의 초기화를 제어하려는 경우 입니다.

끝으로 Proxy 객체는 함수 호출을 가로채야 하거나 객체 속성(동적 속성 포함)에 대한 다른 형태의 접근이 필요한 경우 선호되는 접근 법입니다.
Proxy 객체는 다른 기술에서는 사용할 수 없는 고급 수준의 접근 제어를 제공합니다.

예를 들어 Proxy 객체를 사용하면 객체의 키의 삭제를 가로채 해당 키가 존재하는지 확인하는 동작을 수행할 수 있습니다.

Proxy 객체가 Subject를 변경하지 않으므로, 애플리케이션에서 Subject를 공유하고 있는 다른 컴포넌트들이 안전하게 사용할 수 있다는 점을 다시 한번 강조할 필요가 있을 것 같습니다.
또한 Proxy 객체를 사용하여 Subject의 변경이 필요하지 않는 모든 함수와 속성들은 그대로 위임할 수 있다는 것을 확인할 수 있습니다.

다음 섹션에서는 프록시 패턴을 활용하는 보다 현실적인 예를 제시하고, 이 패턴을 구현하기 위해 지금까지 논의한 다양한 기술을 비교하는데 사용해 보겠습니다.


### 프록시 구현 기술
객체를 프록시 할 때, 모든 함수들을 가로채거나 일부만 가로채고 나머지는 Subject가 직접 처리하도록 위임할 수 있다.
이를 가능하게 하는 몇가지 방법이 있는데, 이 섹션에서는 그 중 일부를 소개합니다.

다음과 같은 StackCalculator 클래스의 간단한 예제를 가지고 작업을 해 보겟습니다.

```ts
class StackCalculator{
	constructor(){
		this.stack = []
	}

	putValue(value){
		this.stack.push(value)
	}

	getValue() {
		return this.stack.pop()
	}

	peekValue(){
		return this.stack[this.stack.length - 1]
	}

	clear(){
		this.stack = []
	}

	divide(){
		const divisor = this.getValue()
		const dividend = this.getValue()
		const result = dividend / divisor
		this.putValue(result)
		return result
	}

	multiply(){
		const mulitplicand = this.getValue()
		
	}
}
```

이 클래스는 스택 계산기를 단순화 하여 구현합니다.
이 계산기의 아이디어는 모든 피 연산자(값)를 스택에 유지하는 것입니다.

예를 들어 곱셈과 같은 연산을 수행하면 승수와 피승수 값이 스택에서 추출되고 곱셈 결과가 스택으로 다시 푸시 됩니다.
이것은 휴대폰의 계산기 프로그램이 실제로 구현되는 방식과 크게 다르지 않습니다.

다음은 `StackCalculator`를 사용하여 곱셈과 나눗셈을 수행하는 방법의 한가지 예시 입니다.
```js
const calculator = new StackCalculator()
calculator.putValue(3)
calculator.putValue(2)
console.log(calculator.multiply()) // 3*2=6
calculator.putValue(2)
console.log(calculator.multiply()) // 6*2=12
```

클래스에는 스택의 맨 위에 있는 값(마지막으로 삽입된 값 또는 마지막 작업의 결과)을 알아볼 수 있는 `peekValue()` 및 스택을 다시 설정할 수 있는 `clear()`와 같은 유틸리티 함수들도 있습니다.

재미있는 사실 : JavaScript 에서는 0으로 나누면 Infinity 라는 희한한 값이 반환됩니다.
다른 많은 프고그래밍 언어에서 0으로 나누는 것은 프로그램이 패닉을 일으키거나 런타임 에러는 던지는 결과를 발생시키는 잘 못된 연산 입니다.

이후 몇개의 섹션에서는 프록시 패턴을 활용하여, 0으로 나눌 때, Infinity를 반환한는 대신 명시적으로 오류를 생성시키는 보다 보수적인 동작을 하도록 StackCalculator 인스턴스의 기능을 변경할 것입니다.

### 객체 컴포지션
컴포지션은 기능을 확장해서 사용하기 위해 객체를 다른 객체와 결합하는 기술입니다.
특정 프록시 패턴의 경우 Subject와 동일한 인터페이스를 가진 객체가 생성되고 Subject에 대한 참조가 인스턴스 변수나 클로저 변수의 형태로 프록시 내부에 저장됩니다.

Subject는 생성시 사용자가 주입시키거나 프록시 자체에서 생성될 수 있다.
아래 예시에서는 객체 컴포지션을 사용하여 안전한 계산기를 구현하고 있습니다.

```ts
class SafeCalculator{
	constructor(calculator){
		this.calculator = calculator
	}

	divide(){
		// 추가적인 검증 로직
		const divisor = this.calculator.peekValue()
		if(divisor === 0){
			throw Error('Division by 0')
		}

		// Subject에 대한 유효한 위임자(delegate)일 경우
		return this.calculator.divide()
	}

	// 위임된 함수들
	putValue(value){
		return this.calculator.putValue(value)
	}

	getValue(){
		return this.calculator.getValue()
	}

	peekValue(){
		return this.calculator.peekValue()
	}

	clear(){
		return this.calculator.clear()
	}

	multiply(){
		return this.calculator.multiply()
	}
}

const calculator = new StackCalculator()
const safeCalculator = new SafeCalculator(calculator)

calculator.putValue(3)
calculator.putValue(2)
console.log(calculator.multiply()) // 3*2 = 6

safeCalculator.putValue(2)
console.log(safeCalculator.multiply()) 

calculator.putValue(0)
console.log(calculator.divide()) // 12/0 = Infinity

safeCalculator.clear()
safeCalculator.putValue(4)
safeCalculator.putValue(0)
console.log(safeCalculator.divide()) // 4/0 -> 에러
```

`safeCalculator` 객체는 원래의 calculator 인스턴스의 프록시입니다.
`safeCalculator` 에서 `multiply()`함수를 호출하면, calculator 에서 동일한 함수를 호출하게 됩니다.
`divide()`도 마찬가지지만,  이 경우 0으로 나누려고 하면, 이것을 Subject에서 수행하는지 혹은 프록시에서 수행하는지에 따라 다른 결과를 얻을 수 있다는 것을 알 수 있습니다.

컴포지션을 사용하여 이 프록시를 구현하려면 기능을 변경하려는 함수(`divide()`)는 가로채고 그렇지 않은 것들은 간단히 `Subject` 에 위임(`putValue()`, `getValue()`, `peekValue()`, `clear()`) 그리고 `multiply()` 합니다.

주의할 점은 calculator(스택 내의 값들) 상태는 여전히 calculator 인스턴스에 의해 유지된다는 것입니다.
`safeCalculator`는 필요에 따라 값을 읽거나 값의 변경을 위해 `calculator`의 함수를 호출합니다.

앞의 코드에서 보여준 프록시 구현의 또 다른 방법으로 객체 리터럴과 팩토리 함수를 사용할 수 있습니다.

```js
function createSafeCalculator(calculator){
	return {
		// 프록시된 함수
		divide(){
			// 추가적인 검증 로직
			const divisor = calculator.peekValue()
			if(divisor === 0){
				throw Error('Division by 0')
			}
			return calculator.divide()
		},
		// 위임된 함수들
		putValue(value){
			return calculator.putValue(value)
		},
		getValue(){
			return calculator.peekValue()
		},
		clear(){
			return calculator.clear()
		},
		multiply(){
			return calculator.multiply()
		}
	}
}

const calculator = new StackCalculator()
const safeCalculator = createSafeCalculator(calculator)
```

이 구현은 클래스 기반의 구현보다 더 간단하고, 간결하지만, 다시 한번 모든 함수들을 Subject에 명시적으로 위임하도록 합니다.

복잡한 클래스의 수많은 함수를 위임해야 하는 것은 매우 반복적일 수 있어 이런 방식의 구현이 더 어려워질 수있습니다.
대부분의 함수를 위임해야 하는 프록시를 만들 수 있는 한가지 방법은 [`delogates`](https://www.npmjs.com/package/delegates)와 같이 모든 함수를 생성해주는 라이브러리를 사용하는 것입니다.
보다 현대적이고, 근본적인 대안은 이 장의 뒷부분에서 설명할 Proxy 객체를 사용하는 것입니다.

### 객체 확장(Object augmentation)
객체 확장(또는 몽키 패치)은 아마도 객체가 가진 몇몇 함수를 프록시하는 가장 간단하고 일반적인 방법일 것입니다.
이것은 함수를 프록시의 구현으로 대체하여 Subject를 직접 수정하는 작업들을 포함하고 있습니다.

계산기 예제에는 다음과 같이 적용할 수 있습니다.

```js
function patchToSafeCalculator(calculator){
	const divideOrig = calculator.divide
	calculator.divide = () => {
		// 추가적인 검증 로직
		const divisor = calculator.peekValue()
		if(divisor === 0){
			throw Error('Division by 0')
		}
		//Subject에 유효한 위임자일 경우
		return divideOrig.apply(calculator)
	}
	return calculator
}

const calculator = new StackCalculator()
const safeCalculator = patchToSafeCalculator(calculator)
```

이 기술은 한 두개의 함수를 프록시 할 때 확실히 편리합니다.
여기서 `multiply()` 함수를 비롯하여 다른 모든 위임된 함수를 구현할 필요가 없다는 것을 눈치채셨나요?
불행하게도 이 단순함은 대상 객체를 직접 변경하기 때문에, 위험할 수 있습니다.

:::tip Subject가 코드 기반으로 다른 부분과 공유되었을 경우, 이는 무조건 피해야 하는 방법입니다.
- 실제로 subject를 몽키 패치하면 애플리케이션의 다른 컴포넌트에 영향을 미쳐 바람직하지 않은 부작용이 발생할 수 있습니다.
- Subject가 제한된 컨텍스트나 프라이빗 범위에 있는 경우에만 이 기술을 사용하십시오
- 몽키 패치가 위험한 행위인 이유를 알고 싶을 경우, 원래의 `calculator` 인스턴스에서 0으로 나누기를 호출해보면 알 수 있습니다.
- 그렇게 하면, 원래 인스턴스가 Infinity를 반환하지 않고 오류를 발생시키는 것을 볼 수 있습니다.
- 원래의 동작이 변경되어 애플리케이션의 다른 부분에 기대치 않은 영향을 미칠 수 있습니다.

:::

다음 섹션에서는 프록시 패턴 등을 구현하기 위한 강력한 대안으로, 기본적으로 제공하는 Proxy 객체를 살펴보겠습니다.

### 내장 프록시 객체
ES2015 사양에서 강력한 프록시 객체를 만드는 근원적인 방법을 도입했습니다.
ES2015 Proxy 객체는 생성자가 대상(target)과 핸들러를 인자로 받아들입니다.

```ts
const proxy = new Proxy(target, handler)
```

여기서 target은 프록시가 적용될 객체(우리의 정의에 따르면 Subject)를 나타내며, 핸들러는 프록시의 동작을 정의하는 특수한 객체 입니다.

핸들러 객체에는 해당 작업이 프록시 인스턴스에서 수행될 때 자동으로 호출되는 트랩함수(예 : apply, get, set 및 has)라는 미리 정의된 이름을 가진 일련의 부가적인 함수들이 포함됩니다.

이 API의 동작 방식을 보다 잘 이해하기 위해 Proxy 객체를 사용하여 안전한 계산기 프록시를 구현하는 방법을 살펴보겠습니다.

```ts
const safeCalculatorHandler = {
	get:(target, property) => {
		if(property === 'divide'){
			// 프록시 된 함수
			return function(){
				// 추가적인 검증 로직
				const divisor = target.peekValue()
				if(divisor === 0){
					throw Error('Division by 0')
				}
				// Subject에 대한 유효한 위임자일 경우
				return target.divide()
			}
		}
		// 위임된 함수들과 속성
		return target[property]
	}
}

const calculator = new StackCalculator()
const safeCalculator = new Proxy(
	calculator,
	safeCalculatorHandler
)
```

Proxy 객체를 사용한 이 안전한 계산기 프록시의 구현에서, divide() 함수에 대한 호출을 포함하여 원래 객체의 속성과 함수에 대한 접근을 가로채기 위해 get 트랩 함수를 사용 하였습니다.

프록시는 divide()에 대한 액세스를 가로채고 0으로 나누는 것인지 검사하는 추가적인 로직이 구현된 새로운 버전의 함수를 반환합니다.
`target[property]`을 사용하여 다른 모든 함수와 속성을 변경하지 않고도 간단하게 반환할 수 있다는점을 살펴두십시오

결과적으로 Proxy 객체는 Subject의 프로토타입을 상속하므로, `safeCalculator instanceof StackCalculator`를 실행하면 true 가 반환된다는 점이 매우 중요합니다.

이 예제를 통해 Proxy 객체를 사용하면 다른 모든 속성과 함수를 명시적으로 위임할 필요가 없으며, 변경하려는 부분만 프록시 하기 쉬울 뿐 아니라 Subject의 코드 변경을 방지 할 수 있음을 알 수 있습니다.

### Proxy 객체의 추가적인 기능과 제약사항
Proxy객체는 JavaScript 언어 자체에 깊이 통합된 기능으로, 개발자가 객체에서 수행할 수 있는 많은 작업을 가로채고 재지정할 수 있습니다.
이 특성은 메타 프로그래밍, 연산자 오버로딩 및 객체 가상화와 같이 이전에 쉽게 달성할 수 없었던 새롭고 흥미로운 사용 방법을 제공합니다.

```js
const evenNumbers = new Proxy([],{
	get: (target, index) => indeex * 2,
	has: (target, number) => number % 2 === 0
})

console.log(2 in evenNumbers) // true
console.log(5 in evenNumbers) // false
console.log(evenNumbers[7])
```

이 예제에서, 우리는 모든 짝수를 포함한 가상의 배열을 생성하였습니다.
이것은 평범한 배열 처럼 사용될 수 있습니다.

즉, 평범함 배열 구문(예 : `evenNumbers[7]`)을 사용해서 배열의 항목에 액세스 하거나 In 연산자(예 : 2 in evenNumbers)를 사용하여 특정 항목이 존재하는지를 검사할 수 있습니다.
배열은 데이터를 내부에 저장하지 않으므로 가상의 배열 입니다.

:::tip 앞의 코드는 Proxy 객체의 고급 기능 중 일부를 보여주기 위한 재미있는 예이지만, Proxy 패턴을 구현한 것은 아닙니다.
- 이 예제를 통해 Proxy 객체는 일반적으로 프록시 패턴(명칭의 유례)를 구현하는데 사용되지만, 다른 패턴 및 사례를 구현하는 데서도 사용될 수 있음을 알 수 있습니다.
- 예를 들어, 이 장의 뒷 부분에서 Proxy 객체를 사용하여 데코레이션 패턴을 구현하는 방법을 살펴볼 것입니다.

:::

구현을 살펴보면 프록시는 빈 배열을 대상으로 사용하며 핸들러에 `get` 과 `has`라는 트랩을 정의합니다.
- `get` 트랩은 배열의 요소에 대한 접근을 가로채서 주어진 인덱스에 대한 짝수를 반환합니다.
- `has`는 in 연산자의 사용을 가로채서 주어진 숫자가 짝수인지 여부를 확인합니다.

Proxy 객체는 `set`, `delete` 그리고 `construct` 같은 또 다른 흥미로운 트랩을 지원하며 요청 시 모든 트랩을 비활성화 하고 대상 객체의 원래 동작으로 복원할 수 있는 프록시를 생성 할 수 있습니다.

이러한 모든 기능을 분석하는 것은 이 장의 범위에 벗어나며, 여기서 중요한 것은 Proxy 객체가 프록시 디자인 패턴을 구현하기 위한 강력한 기반을 제공하고 있다는 사실을 아는 것입니다.

:::note Proxy 객체가 제공하는 모든 기능과 트랩함수 들이 궁긍하다면, [Proxy관련 MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)글을 참조하십시오


:::

Proxy 객체는 JavaScript 언어의 강력한 기능이지만, 매우 중요한 제약이 있습니다.
Proxy 객체는 완전히 트랜스파일(transpile) 되거나 polyfill 될 수 없습니다.

이는 Proxy 객체 트랩 중 일부는 런타입 수준에서만 구현할 수 있고, 일반 JavaScript로 간단히 재작성 할 수 없기 때문입니다.
이는 Proxy 객체를 직접적으로 지원 하지 않는 예전 브라우저 또는 NodeJs 의 이전 버전에서 작업 해야 할 경우 알아야할 사항 입니다.

:::tip Transplation: Transcomplation 의 약자 입니다.
- 소스 코드를 한 소스 프로그래밍 언어에서 다른 소스 프로그래밍 언어로 번역하여 컴파일 하는 동작을 나타냅니다.
- JavaScript 의 경우 이 기술은 JavaScript 의 새로운 기능을 사용하는 프로그램을 지원하지 않는 이전 런타임 환경에서도 실행할 수 있는 동등한 프로그램으로 변환하는 것을 의미합니다.


:::

:::tip Polyfill: 일반 JavaScript 에서 표준 API 에 대한 구현을 제공하고 이 API 를 사용할 수 없는 환경(일반적으로 이전 브라우저나 런타임)에서 가져다 쓸 수 있는 코드 입니다.
- [core-js](https://github.com/zloirock/core-js)는 JavaScript를 위한 가장 완벽한 Polyfill 라이브러리 중 하나입니다.

:::

### 여러 프록시 기술의 비교
컴포지션은 원래 동작을 변경하지 않고 대상을 그대로 두기 때문에, 프록시를 만드는 간단하고 안전한 방법으로 여길 수 있습니다.
유일한 단점은 함수 중 하나만 프록시 하려는 경우에도 모든 함수들을 수동으로 위임해야 한다는 것입니다.
또한 Subject의 속성에 대한 접근 권한을 위임 해야할 수도 있습니다.

:::tip Object를 이용해서 Object의 속성을 위임할 수도 있습니다.
- 이에 대해서는 [해당 사이트](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)를 참조하십시오

:::

반면에 Subject를 수정하는 객체 확장은 항상 이상적인 것은 아니지만 위임과 관련된 여러가지 불편함을 겪지 않습니다.
이러한 이유로 이 두 가지 접근 방식 중 Subject를 수정해야 하는 모든 상황에서는 객체 확장이 선호되는 기술입니다.

그러나 컴포지션이 반드시 필요한 상황이 몇 가지 있습니다.
예를 들어, 필요시에만 (생성화 지연 - lazy initialization)하는 것과 같이 Subject 초기화 제어하려는 경우 입니다.

끝으로, Proxy 객체는 함수 호출을 가로채야 하거나 객체 속성(동적 속성 포함)에 대한 다른 형태의 접근이 필요한 경우 선호되는 접근법입니다.

Proxy 객체는 다른 기술에서는 사용할 수 없는 고급 수준의 접근 제어를 제공합니다.
예를 들어 Proxy 객체를 사용하면 객체에서의 키 삭제를 가로채 해당 키가 존재하는지 확인하는 동작을 수행할 수 있습니다.

Proxy 객체가 Subject를 변경하지 않으므로, 애플리케이션에서 Subject를 공유하고 있는 다른 컴포넌트들이 안전하게 사용할 수 있다는 점을 다시 한번 강조할 필요가 있을 것 같습니다.
또한 Proxy 객체를 사용하여 Subject의 변경이 필요하지 않는 모든 함수와 속성들은 그대로 위임할 수 있다는 것을 확인 할 수 있습니다.

다음 섹션에서는 프록시 패턴을 활용하는 보다 현실적인 예를 제시하고, 이 패턴을 구현하기 위해 지금까지 논의한 다양한 기술을 비교하는데 사용해보겠습니다.

### 쓰기가 가능한 로깅 스트림 만들기
실제 예제에 적용되는 프록시 패턴을 확인하기 위해 이제 `write()` 함수에 대한 모든 호출을 가로채고, 이러한 상황이 발생할 때 마다, 메시지를 기록하는 Writeable 스트림에 대해 프록시 역할을 하는 객체를 만들어 보겠습니다.

Proxy 객체를 사용하여 프록시를 구현하겠습니다.
`logging-writeable.js` 라는 파일에 코드를 작성해보겠습니다.

```ts
export function createLoggingWritable(writable){
	return new Proxy(writable, { // 1
		get(target, propKey, receiver){ // 2
			if(propKey === 'write'){ // 3
				return function(...args){ // 4
					const [chunk] = args
					console.log('Writing', chunk)
					return writable.write(...args)
				}
			}
			return target[propKey] // 5
		}
	})

}
```

앞의 코드에서 우리는 인자로 전달된 writable 객체의 프록시 버전을 반환하는 팩토리를 만들었습니다.
구현의 중요 지점에 대해 살펴보겠습니다.

1. ES2015 Proxy 생성자를 사용하여 원래 writable 객체에 대한 프록시를 만들고 반환합니다.
2. get 트랩을 사용하여 객체의 속성에 대한 접근을 가로챕니다.
3. 접근한 속성이 writable 함수인지 확인합니다.
	- 이 경우 원래 동작의 프록시 함수를 반환합니다.
4. 여기서 프록시 구현 로직은 간단합니다.
	- 원래 함수에 전달된 인자 목록에서 현재 청크를 추출하고 청크의 내용을 기록한 다음
	- 마지막으로 주어진 인자 목록으로 원래의 함수를 호출합니다.
5. 다른 모든 속성에 대해서는 변경 없이 반환합니다.

이제 새로 생성된 이 함수를 사용해서 프록시 구현을 테스트해 볼 수 있습니다.

```ts
import { createWriteStream } from 'fs'
import { createLoggingWritable } from './logging-writable.js'

const writable = createWriteStream('text.txt')
const writableProxy = createLoggingWriteable(writable)

writableProxy.write('First chunk')
writableProxy.write('Second chunk')
writableProxy.write('This is not logged')
writableProxy.end()
```

프록시는 stream 의 원래 인터페이스를 변경하지 않았지만 앞의 코드를 실행하면 `writableProxy` 스트림에 기록된 모든 청크가 콘솔에 출력되는 것을 볼 수 있습니다.

### 프록시를 사용한 변경 옵저버
변경 옵저버 패턴은 객체 Subject 가 하나 이상의 옵저버 에서 상태 변경을 알리는 디자인 패턴으로, 변경 사항이 발생하는 즉시 반응 할 수 있습니다.

:::tip 변경 옵저버 패턴은 3장의 콜백과 이벤트에서 살펴본 옵저버 패턴과 매우 유사하지만, 혼동해서는 안됩니다.
- 변경 옵저버 패턴은 속성 변경을 감지하는데 중점을 두고 있으며, 
- 옵저버 패턴은 시스템에서 발생하는 이벤트에 대한 정보를 전파하기 위해 이벤트 이미터를 사용하는 보다 일반적인 패턴 입니다.

:::

프록시는 관찰 가능한 객체를 만드는데 매우 효과적인 도구로 알려져 있습니다.
`create-observable.js` 로 구현 사례를 살펴보겠습니다.

```js
import { createObservable } from './create-observable.js'

function calcaulateTotal (invoice){
	return invoice.subtotal - invoice.discount + invoice.tax
}

const invoice = {
	subtotal: 100,
	discount: 10,
	tax: 20
}


```



TODO: 공백



![스크린샷-2025-06-16-오후-4.27.37.png](/img/이미지 창고/스크린샷-2025-06-16-오후-4.27.37.png)
그림 8.2에서 Decorator 객체는 `methodC()` 동작을 추가하여 컴포넌트 객체를 확장하고 있 습니다. 
기존 함수는 일반적으로 추가적인 처리없이 데코레이팅된 객체에 위임되지만 경우에 따라 요청을 가로채고 추가적인 동작으로 확대할 수도 있습니다.

## 데코레이터 구현 기법
프록시와 데코레이터는 개념적으로 서로 다른 의도를 가진 두 개의 다른 패턴이지만 실제로는 동일한 구현 전략을 공유합니다. 
곧 살펴볼 것입니다.

이번에는 데코레이터 패턴을 사용하여 `StackCalculator` 클래스의 인스턴스를 가져와서 데코레이트하여 `add()`라는 새로운 함수를 노출시키고 두 숫자를 더하는데 사용할 수 있습니다. 

또한 데코레이터를 사용하여 `divide()` 함수에 대한 모든 호출을 가로채고 `SafeCalculator` 예제에서 본 것과 동일하게 0으로 나누는지 검사하도록 구현합니다.

### 컴포지션
컴포지션을 사용하면 데코레이트되는 컴포넌트는 일반적으로 이를 상속한 새로운 객체로 감싸 집니다. 
이 경우 데코레이터는 기존 함수들을 원래 컴포넌트에 위임하면서 새로운 함수를 정의하기만 하면 됩니다.

```js
class EnhancedCalculator (
	constructor (calculator) {
		this. calculator = calculator
	}
	
	// 새로운 함수
	add () {
		const addend2 = this.getValue()
		const addend1 = this.getValue()
		const result = addend1 + addend2
		this. putValue(result)
		return result
	}
	// 수정된 함수
	
	divide () {
	// 추가적인 검증 로직
	const divisor = this.calculator.peekValue()
		if (divisor == 0) {
			throw Error Division by 0')
		}
		// Subject에 대한 유효한 위임자(delegates)일 경우
			return this. calculator.divide)
		}
		// 위임된 함수들
	putValue (value) {
		return this. calculator.putValue(value)
	}
	
	getValue () {
		return this. calculator.getValue()
	}

	peekValue (0) {
		return this.calculator.peekValue ()
	}
	clear(){
		return this.calculator.clear()
	}
		
	multiply(0) {
		return this.calculator.multiply()
	}
}

const calculator = new StackCalculator(

const enhancedCalculator = new EnhancedCalculator(calculator)

enhancedCalculator.putValue(4)
enhancedCalculator.putValue(3)

console. log(enhancedCalculator.add())
// 4+3= 7
enhancedCalculator.putValue(2)
console. log(enhancedCalculator.multiply)) // 7*2 = 14
```

프록시 패턴에 대한 컴포지션 구현을 기억한다면 여기 있는 코드가 매우 유사하다는 것을 알 수 있을 것입니다.
새로운 `add()` 함수를 만들고 원래 `divide()` 함수의 동작을 개선하였습니다
(이전 SafeCalculator 예제에서 본 기능을 효과적으로 복제. 끝으로 putValue(), getValue(), peekValue(), clear() 및 multiply() 함수는 원래 객체에 위임했습니다

### 객체 확장
다음과 같이 데코레이트되는 객체에 직접 새 함수를 정의해서(몽키 패치) 데코레이트를 수행 할 수도 있습니다.

```js
function patchCalculator (calculator) {
	// 새로운 함수
	calculator.add = function () {
		const addend2 = calculator.getValue()
		const addend1 = calculator.getValue()
		const result = addend1 + addend2
		calculator.putValue(result)
		return result
	}
	// 수정된 함수
	const divideOrig = calculator. divide
	calculator.divide = () => {
		// 추가적인 검증 로직
		const divisor = calculator.peekValue ()
		if (divisor === 0) {
			throw Error ('Division by 0')
		}
		// Subject에 대한 유효한 위임자(delegates)일 경우
		return divideOrig.apply(calculator)
	}
	return calculator
}
const calculator = new StackCalculator()
const enhancedCalculator = patchCalculator(calculator)

// ..
```

이 예제에서 calculator와 enhancedCalculator는 동일한 객체를 참조합니다(`calculator == enhancedCalculator`). 
이는 `patchCalculator()`가 원래의 계산기 객체를 변형한 후 반환 하기 때문 입니다. 
`calculator.divide()`를 호출하여 이를 확인할 수 있습니다

### Proxy 객체를 이용한 데코레이팅
Proxy 객체를 이용해서 객체를 데코레이트할 수도 있습니다. 일반적인 예는 다음과 같습니다.

```js
const enhancedCalculatorHandler = {
	get (target, property) {
		if (property =ss 'add') {
			// 새로운 함수
			return function add () {
				const addend2 = target.getValue()
				const addend1 = target. getValue()
				const result = addend1 + addend2
				target.putValue(result)
				return result
			}
		} else if (property === 'divide') {
			return function ()) {
				const divisor = target.peekValue()
			
				if (divisor == 0) {
					throw Error ('Division by 0')
				}
			// Subject에 대한 유효한 위임자(delegates) 일 경우
				return target.divide()
			}
		}
	}
	// 위임된 함수들과 속성들
	return target[property]
}
const calculator = new StackCalculator()
const enhancedCalculator = new Proxy(calculator, enhancedCalculatorHandler)
// ...
```

이러한 서로 다른 구현 방법을 비교하면, 프록시 패턴을 분석하면서 논의된 동일한 주의 사항 이 데코레이터에도 적용됩니다. 실제 예제로 패턴을 연습해 봅시다!

### LevelUp 데이터베이스 데코레이트
다음 예제 코딩을 시작하기 전에, 우리가 사용할 LevelUP 모듈에 대해 간략하게 살펴보겠습니다.

#### LevelUP 및 LevelDB 소개
LevelUP(nodejsdp.link/levelup)는 원래 Chrome 브라우저에서 IndexedDB를 구현하기 위해 만들어진 키-값 저장소인 Google의 LevelDB를 감싼 Node.js 래퍼지만 이것은 그 이상 의 가치가 있습니다. 
LevelDB는 최소주의와 확장성 때문에 "데이터베이스의 Node.js"라 정의되었습니다. 

Node.js와 마찬가지로 LevelDB는 놀랍도록 빠른 성능과 가장 기본적인 기능 만을 제공하여 개발자가 그 위에 모든 종류의 데이터베이스를 구축할 수 있도록 하였습니다.

이 기회를 놓치지 않고 Node.js 커뮤니티와 Rod Vagg는 LevelUP을 만들어 데이터베이스의 힘을 Node.js 세계에 적용하였습니다. 
LevelDB의 래퍼로 탄생한 이 제품은 메모리 내 저장소 에서 Riak 및 Redis와 같은 다른 NoSQL 데이터베이스, IndexedDB 및 LocalStorage와 같은 웹 저장소 엔진에 이르기까지 여러 종류의 백엔드를 지원하도록 진화하여 동일한 API로 사 용할 수 있게 되었습니다. 
서버와 클라이언트 모두에서 정말 흥미로운 시나리오를 만들어냈습니다.

오늘날 LevelUP 주변에는 작은 코어를 확장하여 복제, 보조 인덱스, 라이브 업데이트, 쿼리 엔진 등과 같은 기능을 구현한 플러그인과 모듈들로 구성된 방대한 에코 시스템이 존재합니다.

LevelUP 위에 PouchDB(nodejsdp.link/pouchdb)와 같은 CouchDB의 복제를 포함하여 LevelGraph(nodejsdp.link/levelgraph)라는 그래프 데이터베이스에 이르기까지 Node.js 와 Browser에서 모두 동작하는 완전한 데이터베이스 또한 만들었습니다!

## 프록시와 데이코레이터 사이의 경계

이쯤에서 프록시와 데코레이터 패턴의 차이점에 대한 당연한 의문이 생길 수 있습니다. 
이 두 패턴은 실제로 매우 유사하며 때때로 서로 바꿔서 사용할 수 있습니다.

고전적인 정의에서, 데코레이션 패턴은 새로운 동작을 기존의 객체에 추가할 수 있는 메커니즘 으로 정의하고 있으며, 반면 프록시 패턴은 고정적이거나 가상의 객체에 접근을 제어하는데 사 용됩니다.

두 패턴 사이에는 개념적인 차이가 있으며 대부분 런타임에 사용되는 방식에 기인합니다.

데코레이터 패턴은 래퍼로 볼 수 있습니다. 다양한 유형의 객체를 가져와 데코레이터로 감싸서 추가적인 기능을 추가할 수 있습니다. 
프록시는 대신 객체에 대한 접근을 제어하는 데 사용되 며 원래의 인터페이스를 변경하지 않습니다. 
이런 이유로 프록시 인터페이스를 만든 후에는 원 래 객체를 참조하는 다른 객체들은 안전할 수 있습니다.

구현과 관련한 이러한 차이점은 일반적으로 전달하는 객체의 유형이 컴파일 시에 결정되는 강 력한 유형의 언어에서 더욱 분명하게 드러납니다. 
Node.js 생태계에서는 JavaScript 언어의 동적 특성을 고려할 때 프록시와 데코레이터 패턴 사이의 경계가 매우 모호하며 종종 두 이름 이 서로 바뀌어서 사용되기도 합니다. 
또한 동일한 기술을 사용하여 두 패턴을 구현하는 방식도 살펴보았습니다.

JavaScript와 Node.js를 다룰때 중요한 점은 이 두 패턴의 명명법과 표준적인 정의에 얽매이지 않아야 한다는 것입니다. 
프록시와 데코레이터가 전체적으로 해결하는 문제의 종류를 살펴 보고, 이 두 패턴을 상호 보완적이며 때로는 상호 교환 가능한 도구로 다루는 것이 좋습니다.

## 어댑터

어댑터 패턴을 사용하면 다른 인터페이스로도 객체의 기능을 사용할 수 있습니다.

어댑터의 실제 예시로 USB TYpe-A 케이블을 USB Type-C 포트에 연결할 수 있는 장치를 들 수 있습니다. 
일반적인 의미에서 어댑터는 다른 인터페이스를 사용하는 컨텍스트에서 사용 할 수 있도록 객체의 인터페이스를 변환시켜 줍니다.

소프트웨어에서 어댑터 패턴은 객체의 인터페이스를 가져와서 주어진 클라이언트가 예상하는 다른 인터페이스와 호환되도록 하는데 사용됩니다. 
이 아이디어를 명확히 하기 위해 그림 8.3 을 살펴보겠습니다.


![스크린샷-2025-07-09-오전-10.01.52.png](/img/이미지 창고/스크린샷-2025-07-09-오전-10.01.52.png)

그림 8.3은 어댑터가 본질적으로 다른 객체의 래퍼가 되어 다른 인터페이스를 노출하는 방법 을 보여줍니다. 
다이어그램은 어댑터의 작업이 다른 객체에 대한 하나 이상의 함수 호출로 구 성될 수도 있다는 것을 알 수 있습니다. 
구현 관점에서 가장 일반적인 기술은 컴포지션입니다.

여기서 어댑터의 함수는 다른 객체의 함수로 연결을 제공합니다. 
이 패턴은 매우 간단하므로 바로 예를 들어보겠습니다.

### 파일시스템 API로 LevelUP 사용하기
이제 LevelUP API를 중심으로 어댑터를 만들어 기본 fs 모듈과 호환되는 인터페이스로 변화 시킬 것입니다. 
특히 `readFile()` 및 `writeFile()`에 대한 모든 호출이 `db.get()` 및 `db.put()`에 대한 호출로 변환되도록 할 것입니다. 
이렇게 하면, 간단한 파일 시스템 작업을 위한 백엔드 저장소로 LevelUP 데이터베이스를 사용할 수 있습니다.

`fs-adapter.js`라는 새로운 파일을 만들어 시작하겠습니다. 
종속성을 불러오고 어댑터를 만드는데 사용하는 `creatersAdapter()` 팩토리를 익스포트하는 것으로 시작합니다.

```js
import {resolve } from 'path'
export function createSAdapter (db) {
	return ({
		readFile (filename, options, callback) {
			// ٠٠٠
		},
		writeFile (filename, contents, options, callback) {
			// ...
		}
	})
}
```

다음으로, 팩토리에서 readrile() 함수를 구현하여 이 인터페이스가 fs 모듈의 원래 함수 중 하나와 호환되도록 만듭니다.

```js
readFile (filename, options, callback) {
	if (typeof options== 'function') {
		callback = options
		options = 0)
	} else if (typeof options === 'string') {
		options = {encoding: options }
	}
	db.get (resolve(filename), { // 1
		valueEncoding: options.encoding
	},
	(err, value) => {
		if (err) {
			if (err.type === 'NotFoundError') { // 2
			err = new Error(`'ENOENT, open "${filename)'`)
			err.code = 'ENOENT'
			err.errno = 34
			err.path = filename
	}
	return callback && callback(err)
		callback && callback(null, value) // 3
	})
}
```

앞의 코드에서 새로운 함수의 동작이 원래의 `fs.readFile()` 함수에 최대한 유사하도록 만들기 위해 몇 가지 추가적인 작업을 해야 했습니다. 
이를 위한 단계는 다음과 같습니다.

1. ﻿﻿﻿db 인스턴스에서 파일을 검색하려면 파일 이름을 키로 사용하여 항상 전체 경로를 사용하도록 (`resolve()` 사용) 해서 `db.get()` 함수를 호출합니다. 
	- 데이터베이스에서 사용하는 `valueEncoding` 옵션 의 값을 입력에서 받은 인코딩 옵션으로 설정합니다.
2. ﻿﻿﻿데이터베이스에서 키를 찾을 수 없는 경우 ENOENT를 코드로 하여 오류를 생성합니다. 
	- 이 코드는 원래 fs 모듈에서 찾을 수 없는 파일을 표시하는데 사용하는 코드입니다. 
	- 다른 모든 유형의 오류는 콜백 으로 전달됩니다(이 예제의 범위에서는 가장 일반적인 오류에 대해서만 처리합니다).
3. ﻿﻿﻿데이터베이스에서 키-값 쌍이 성공적으로 검색되면 콜백을 사용하여 호출자에게 값을 반환합니다.

우리가 만든 함수는 `fs.readFile()` 함수를 완벽하게 대체하지는 않지만, 매우 일반적인 상황에서는 확실히 의도대로 동작합니다.
이 작은 어댑터를 완성하기 위해 이제 `writeFile()` 함수를 구현하는 방법을 살펴보겠습니다.

```js
writeFile (filename, contents, options, callback) {
	if (typeof options === 'function') {
		callback = options
	options = 0)
	} else if (typeof options == 'string') {
		options = { encoding: options }
	}
	db.put (resolve(filename), contents, {
		valueEncoding: options.encoding
	}, callback)
}
```
보시다시피 이 경우도 완전한 래퍼는 아닙니다. 
파일 권한`(options,mode)`과 같이 일부 옵션 을 무시하고 데이터베이스에서 받은 오류를 있는 그대로 전달합니다.

이제 새 어댑터가 준비되었습니다. 간단한 테스트 모듈을 작성해서 사용해보도록 합시다.

```js
import fs from 'fs'

fs.writeFile(' file.txt', 'Hello!', ()={
	fs.readFile(' file.txt', { encoding: 'utf8' }, (err, res) = {
		if (err) {
			return console. error(err)
		}
		console. log(res)
	})
})

// 누락된 파일 읽기를 시도
fs.readFile('missing. txt', { encoding: 'utf8' }, (err, res) => {
	console. error (err)
})
```

앞의 코드는 원본 fs API를 사용하여 파일 시스템에서 몇 가지 읽기 쓰기 작업을 수행하고 다음과 같은 내용을 콘솔에 출력해야 합니다.

![스크린샷-2025-07-09-오전-10.10.58.png](/img/이미지 창고/스크린샷-2025-07-09-오전-10.10.58.png)

이제 다음과 같이 fs 모듈을 어댑터로 교체할 수 있습니다.
```js
import { dirname, join } from 'path' 
import {fileURLToPath} from 'url' 
import level from 'level'

import { createSAdapter } from ' /fs-adapter.js'

const __dirname = dirname(fileURLToPath(import.meta.url))

const db = level (join(_dirname, 'db'), {
	valueEncoding: 'binary'
})

// ...
const fs = createSAdapter(db)
```

프로그램을 다시 실행하면 파일 시스템 API를 사용하여 직접 지정한 파일의 일부를 읽거나 쓰 지 않는다는 점을 제외하면 동일한 출력이 생성됩니다. 
대신 어댑터를 사용하여 수행된 모든 작업은 LevelUP 데이터베이스에서 수행되는 작업으로 전환됩니다.

지금 만든 어댑터가 어리석은 것처럼 보일 수 있습니다. 
실제 파일 시스템 대신 데이터베이스를 사용하는 목적이 무엇일까요? LevelUP 자체는 데이터베이스를 브라우저에서도 실행할 수 있는 어댑터가 있다는 것을 기억해야 합니다. 
이러한 어댑터 중 하나가 [level-js](https://www.npmjs.com/package/level-js)입니다. 이제 어댑터가 완벽하게 이해되었을 것입니다. 

비슷한 방법으로 fs 모 듈을 활용하는 코드를 Node.js와 브라우저 모두에서 실행할 수 있습니다. 
브라우저와 코드를 공유할 때 어댑터가 매우 중요한 패턴이라는 것을 알게 되었을 것입니다. 

### 예시

어댑터 패턴에 대한 실제 사례가 많이 있습니다. 여기 분석하고 살펴볼 만한 몇 가지 가장 주목 할 만한 예들을 나열해 보겠습니다.

- LevelUP이 브라우저의 기본 LeveIDB에서 IndexedDB에 이르기까지 다양한 스토리지의 백엔드로 실행할 수 있다는 것을 이제 알게 되었습니다. 
	- 이것은 내부(private) LevelUP AP를 사용하기 위해 생성 된 다양한 어댑터들에 의해 가능한 것입니다. [awesome](https://github.com/Level/awesome?tab=readme-ov-file#storage)에서 몇 가지를 살펴보고 어떻게 구현되었는지 확인해 보십시오.
- JugglingDB는 다중 데이터베이스 ORM으로 여러 어댑터를 사용하여 서로 다른 데이터베이스와 호환 되도록 합니다. [adapters](https://github.com/1602/jugglingdb/tree/master/lib/adapters) 참조해 보십시오.
- [nanoSQL](https://nanosql.io/)은 다양한 데이터베이스를 지원하기 위해 어댑터 패턴을 많이 사 용하는 최신 다중 모델 데이터베이스 추상화 라이브러리입니다
- 우리가 만든 예제를 완벽하게 보완한 것이 LevelUP 위에 fs API를 완벽하게 구현한 [level-filesystem](https://www.npmjs.com/package/level-filesystem)입니다

