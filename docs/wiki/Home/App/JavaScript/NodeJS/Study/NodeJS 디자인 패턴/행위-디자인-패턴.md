---
sticker: vault//이미지/개발 로고/TechIconSVG/Node.js.svg

slug: "행위-디자인-패턴"
---
앞선 두 장을 통해 복잡한 객체 구조를 만들고 생성하는데 도움이 되는 패턴을 살펴보았습니다. 
이제 컴포넌트들의 동작과 관련된 소프트웨어의 다른 측면을 살펴볼 때가 되었습니다. 이 장에서는 확장가능하고, 모듈화되고, 재사용가능하며 적용성을 높일 수 있도록 객체를 결합하 는 방법과 상호작용할 수 있는 방법을 정의할 것입니다. "어떻게 런타임에 알고리즘의 일부를 변경할 수 있을까?", "어떻게 객체의 상태에 따라 동작을 변경할 수 있을까?", "어떻게 구현과 상관없이 컬렉션을 반복할 수 있을까?"와 같은 유형의 문제들은 전형적으로 이 장에서 살펴볼 패턴으로 해결할 수 있습니다.

이 패턴의 범주에 있는 주목할 만한 패턴을 여러분은 이미 살펴보았습니다. 바로 옵저버 (Observer) 패턴으로 3장. 콜백과 이벤트"에서 설명했습니다. 옵저버 패턴은 Node.js 플랫 폼의 기본 패턴 중 하나입니다. Node.js의 이벤트 기반 아키텍처의 핵심인 이벤트와 구독을 처리하기 위한 간단한 인터페이스를 제공하기 때문입니다.

이미 GoF의 디자인 패턴에 익숙하다면, 이 장에서 이러한 패턴의 구현이 순수한 객체 지향 접 근 방식과 비교할 때 JavaScript에서 어떻게 근본적으로 다를 수 있는지, 다시 한번 보게 될 것입니다. 이 논의의 좋은 예를 이 장의 뒷부분에서 보게 될 반복자(Iterator) 패턴에서 찾 을 수 있습니다. 반복자 패턴을 구현하기 위해 실제로 클래스를 확장하거나 복잡한 계층 구 조를 만들 필요가 없습니다. 대신 클래스에 특별한 함수를 추가하기만 하면 됩니다. 또한 이 장의 특별한 패턴인 미들웨어(Middleware)는 GoF의 유명한 패턴인 책임 사슬(Chain of Responsibility) 패턴과 매우 유사하지만 Node.js에서 구현은 Node.js 자체의 패턴으로 간주 될 수 있는 표준이 되었습니다.

이제 행위(Behavioral) 디자인 패턴을 좀더 깊이 살펴보겠습니다. 이 장에서는 다음에 대해 학습합니다.

- 특정 요구사항에 맞게 컴포넌트의 일부를 변경하는데 도움이 되는 전략(Strategy) 패턴
- ﻿﻿상태(State) 패턴: 상태에 따라 컴포넌트의 동작을 변경시킬 수 있습니다.
- ﻿﻿새로운 것을 정의하기 위해 컴포넌트의 구조를 재사용할 수 있는 템플릿(Template) 패턴
- ﻿﻿컬렉션을 반복하기 위한 공통의 인터페이스를 제공하는 반복자(Iterator) 패턴
- ﻿﻿미들웨어(Middleware) 패턴: 모듈식 처리 절차를 정의할 수 있는 패턴
- ﻿﻿커맨드 패턴(Command) 패턴: 루틴 실행에 필요한 정보를 구체화하여 이러한 정보를 쉽게 전송, 저장 및 처리할 수 있는 명령(Command) 패턴

# 전략 패턴

전략 패턴을 사용하면 컨텍스트라는 객체를 활성화시켜 변수 부분을 전략(Strategy)이라는 별도의 상호 교환 가능한 객체로 추출하여 로직의 변경을 지원합니다. 
컨텍스트는 알고리즘 제품군 의 공통적인 로직을 구현하는 반면, 전략은 가변적인 부분을 구현하여 컨텍스트가 입력값, 시스템 설정 또는 사용자 기본 설정과 같은 다양한 요소에 따라 동작을 조정할 수 있도록 합니다.

전략은 일반적으로 솔루션 제품군의 일부이며 모두 컨텍스트에서 예상하고 있는 동일한 인터 페이스를 구현합니다. 다음 그림은 방금 설명한 상황을 보여줍니다.
![스크린샷-2025-07-09-오후-1.19.58.png](/img/이미지 창고/스크린샷-2025-07-09-오후-1.19.58.png)

그림 9.1은 마치 기계의 교체 가능한 부품처럼 컨텍스트 객체가 자신의 구조에 다른 전략으로 전환하여 연결하는 방식을 보여주고 있습니다. 
자동차를 상상해 봅시다. 타이어는 다양한 도 로 조건에 적응하기 위한 전략으로 생각할 수 있습니다. 볼트, 너트 덕분에 겨울용 타이어를 눈 길에 장착할 수 있고, 고속도로를 중심으로 장거리 여행을 할 때는 고성능 타이어를 장착할 수 있습니다. 이것이 가능한 다른 방법은 자동차 전체를 바꾸거나 모든 도로를 주행할 수 있도록

8개의 바퀴가 달린 차를 만드는 것인데, 이런 것은 원하지 않을 것입니다.

여러분은 이 패턴이 얼마나 강력한지를 금방 이해할 수 있을 것입니다. 주어진 문제 내에서 우 려되는 사항을 분리하는데 도움이 될 뿐만 아니라, 더 나은 유연성을 가진 솔루션으로 동일한 문제의 다양한 변형에 적용할 수 있도록 할 수 있습니다.

전략 패턴은 컴포넌트 동작이 경우에 따라 달라지는 것을 지원하기 위해 복잡한 조건문(많은 if.else 또는 switch 문)을 사용하거나, 동일한 역할의 범위에서 다른 컴포넌트를 혼합해야 하는 상황들에서 특히 유용합니다. 
전자상거래 웹 사이트에서 온라인 주문을 나타내는 Order 라는 객체를 생각해 봅시다. 

객체에는 주문을 완료하고 사용자로부터 온라인 상점으로 자금을 이체하는 pay()라는 함수가 있습니다.

다양한 결제 시스템을 지원하기 위한 몇 가지 옵션이 존재합니다.

- ﻿﻿pay() 함수에서 i...else 문을 사용하여 선택한 지불 옵션에 따라 작업을 완료합니다.
- ﻿﻿지불의 처리를 사용자가 선택한 특정 결제 게이트웨이에 대한 로직을 구현한 천략 객체에 위임합니다.

첫 번째 해결방법에서 Order 객체의 코드를 수정하지 않는 한, 다른 결제 방법을 지원할 수 없습니다. 
또한 지불 옵션의 수가 증가하면 이것은 매우 복잡해질 수 있습니다. 
대신 전략 (Strategy) 패턴을 사용하면 Order 객체가 사실상 무제한의 결제 방법을 지원할 수 있으며, 다른 객체가 결제 작업을 위임받아 처리하고 Order 객체는 사용자, 구매 항목 및 해당 항목의 가격 같은 세부 정보만 관리하도록 범위를 제한할 수 있습니다.

이제 간단하고 현실적인 예시를 통해 이 패턴을 시연해 보겠습니다.

## 여러 형식을 지원하는 환경 설정 객체
데이터베이스 URL 서버의 수신 포트와 같이 애플리케이션에서 사용하는 일련의 설정 매개 변수들을 가진 Config라는 객체를 생각해봅시다. 
Config 객체는 이러한 매개 변수에 접근하 기 위한 간단한 인터페이스를 제공할 수 있어야 하지만, 파일과 같은 영구적인 저장소를 사용 하여 구성을 가져오고 내보내는 방법도 제공할 수 있어야 합니다. 
환경설정을 저장하기 위해 JSON, INI 또는 YAML과 같은 다양한 형식을 지원할 수 있어야 합니다.

전략 패턴에 대해 배운 내용을 적용하면 Config 객체에서 동작이 변경될 부분을 즉시 식별할 수 있는데, 이는 설정정보를 직렬화하거나 역 직렬화할 수 있는 기능입니다. 
이것은 우리의 전략에 따라 구현될 것입니다.

`config.js`라는 새로운 모듈을 만들어 환경 설정을 관리하기 위한 일반적인 부분들을 정의해 봅시다.

```js
import { promises as fs} from 'fs' 
import objectPath from 'object-path'

export class Config (
	constructor (formatStrategy) { // (1)
		this.data = 0
		this.formatStrategy = formatStrategy	
	}

	get (configPath) {
		return objectPath.get(this.data, configPath)
	}

	set (configPath, value) { // (2)
		return objectPath.set(this.data, configpath, value)
	}

	async load (filePath) {
		console.log(`Deserializing from ${filePath}`)
		this.data = this. formatStrategy.deserialize(
			await fs.readFile(filePath, 'utf-8')
		)
	}

	async save (filepath) {
		console.log( Serializing to ${filePath})
		await fs.writeFile(filepath, this.formatstrategy.serialize(this.data)) //(3)
	}
}
```
앞의 코드에서 벌어지는 작업들은 다음과 같습니다.
1. ﻿﻿﻿생성자에서 환경 설정 데이터를 보관하기 위해 data라는 인스턴스 변수를 만듭니다. 그런 다음 데이터 구문을 분석하고 직렬화하는데 사용할 컴포넌트를 나타내는 formatStrategy도 저장합니다.
2. [﻿﻿﻿object-path](https://www.npmjs.com/package/object-path)라는 라이브러리는 점 경로 표기법(예: `property.subProperty`)을 사용하여 환경 설정 속성에 접근할 수 있는 `set()`과 `get()` 두 가지 함수를 제공 합니다.
3. ﻿﻿﻿`load()` 및 `save()` 함수는 각각 데이터의 직렬화 및 역 직렬화를 전략에 위임하는 곳입니다. 즉, 생성자 에서 입력으로 전달된 `formatStrategy에` 따라 Config 클래스의 로직이 변경되는 곳입니다

보시다시피 매우 깔끔한 이 디자인을 통해 Config 객체는 데이터를 적재하고 저장할 때 다양한 파일 형식을 원활하게 지원할 수 있습니다. 
가장 좋은 점은 이러한 다양한 형식을 지원하는 로직이 어디에도 하드코딩 되지 않기 때문에 Config 클래스는 올바른 전략이 주어지면 사실상 모든 파일 형식을 수정하지 않고도 적용할 수 있다는 것입니다.

이 특성을 설명하기 위해 이제 strategies.js라는 파일에 몇 가지 형식의 전략을 생성해 보겠습니다. 
널리 사용되는 환경 설정 형식인 INI 파일 형식을 사용하여 데이터의 구문을 분석하고 직렬화하는 전략부터 시작해보겠습니다([자세한 내용](https://en.wikipedia.org/wiki/INI_file)을  참고하십시오).

작업을 위해 [ini라는 npm 패키지](https://www.npmjs.com/package/ini)를 사용하겠습니다.

```js
import ini from 'ini'

export const iniStrategy = {
	deserialize: data => ini.parse(data), 
	serialize: data => ini.stringify(data)
}
```

정말 깔끔합니다! 우리의 전략은 단순히 합의된 인터페이스를 구현하기만 하면 Config 객체에 서 사용할 수 있게 되었습니다.

마찬가지로, 우리가 만들 다음 전략을 통해 JavaScript 및 일반적으로 웹 개발 에코 시스템에 서 널리 사용되는 JSON 파일 형식을 지원하게 될 것입니다.

```js
export const jsonStrategy = {
	deserialize: data → JSON.parse(data),
	serialize: data = JSON. stringify(data, null,' ')
}
```
이제 모든 것이 어떻게 결합되는지 보여주기 위해 `index.js`라는 파일을 만들어 다른 형식을 사용해 환경 설정의 샘플을 불러오고 저장해 보겠습니다.

```js
import { Config } from ' /config.js' 
import {isonStrategy, iniStrategy } from ' /strategies. js'

async function main () {
	const inConfig = new Config(iniStrategy)
	await iniConfig.load('samples/conf.ini')
	iniConfig.set('book.nodejs', 'design patterns')
	await iniConfig.save('samples/confmod.ini')

	const isonConfig = new Config(jsonStrategy)

	await jsonConfig.load('samples/confjson')
	jsonConfig.set('book.nodejs', 'design patterns') 
	await isonConfig.save('samples/conf_mod.json')

}

main ()
```

테스트 모듈은 전략 패턴의 핵심적인 속성들을 보여주고 있습니다. 
환경 설정 관리자의 공통 부분을 구현하는 하나의 Config 클래스만을 정의하고 데이터 직렬화 및 역 직렬화를 위한 서 로 다른 전략을 사용하여 다른 형식의 파일을 지원하는 Config 클래스의 인스턴스를 만들었습 니다.

방금 본 예는 전략을 선택하는데 사용할 수 있는 가능한 대안 중 하나만 보여준 것입니다. 
다른 유효한 접근 방법은 다음과 같을 수 있습니다.

- 두 가지 다른 전략 제품군 생성: 하나는 역 직렬화를 위한 것이고 다른 하나는 직렬화를 위한 것입니다.
	- 이렇게 하면 한 형식으로 읽고 다른 형식으로 저장할 수 있습니다.
- 전략을 동적으로 선택: 제공된 파일의 확장자에 따라 Config 객체는 확장자 맵을 가지고 주어진 확장자 에 따라 알맞은 알고리즘을 선택할 수 있습니다.

이와 같이 사용할 전략을 선택할 수 있는 몇 가지 옵션이 있으며, 올바른 옵션은 요구사항과 기능, 그리고 얻고자 하는 단순성 측면에 따라 달라집니다.

또한 패턴 자체의 구현도 많이 다를 수 있습니다. 
예를 들어, 가장 간단한 형식으로 컨텍스트와 전략은 모두 간단한 함수일 수도 있습니다.

```js
function context(strategy) {...}
```

중요하지 않은 것처럼 보일 수 있지만 JavaScript와 같은 프로그래밍 언어에서는 과소평가 되어서는 안됩니다. JavaScript와 같은 프로그래밍 언어에서는 함수가 일급 객체이고 완전한 조건을 갖춘 객체보다도 많이 사용됩니다.

그러나 이러한 모든 변형 사이에서 변경되지 않는 것은 이 패턴이 가진 사상입니다. 
항상 그렇듯이 구현은 어느 정도 변경될 수 있으나 패턴을 움직이게 하는 핵심 개념은 항상 동일한 것입니다.

:::tip 전략 패턴
- 전략 패턴의 구조는 어댑터 패턴의 구조와 유사할 수 있습니다. 
- 그러나 둘 사이에는 상당한 차이가 있습니다. 
- 어댑터 객체는 어댑터에 동작을 추가하지 않습니다. 
- 단지 다른 인터페이스에서도 사용할 수 있는 호환성을 위한 인터페이스를 가지고 있기 때문에 다른 인터페이스에서도 사용할 수 있습니다. 
- 물론 하나 의 인터페이스를 다른 인터페이스로 변환하기 위한 추가적인 로직을 구현해야 할 수도 있으나 이 로직은 인터페이스만으로 제한됩니다. 
- 전략 패턴에서는 컨텍스트와 전략(Strategy) 알고리즘 이렇게 두 가지 다른 부분을 구현하므로 둘 다 어떤 종류의 로직을 구현하고 있으며. 
- 둘 다 최종적인 문제 해결을 위한 알 고리즘을 구축하는데 필수적이게 됩니다( 함께 결합해야 합니다).

:::

## 실전에서
[Passport](https://www.passportjs.org/)는 Node.js용 인증 프레임워크로, 웹 서버가 다양한 인증 체계를 지원할 수 있도록 합니다. 
Passport를 사용하면 최소한의 노력으로 Facebook 에 로그인하거나 Twitter의 기능을 사용하여 웹 애플리케이션에 로그인할 수 있습니다.

Passport는 전략 패턴을 사용하여 인증 프로세스 중에 사용되는 공통된 로직을 실제 인증단계와 같이 변경할 수 있는 부분과 분리합니다. 
예를 들어, Facebook 또는 Twitter 프로필 에 접근하기 위한 액세스 토큰을 얻기 위해 OAuth를 사용하거나 단순히 사용자 아이디/비밀번호 쌍을 확인하기 위해 로컬 데이터베이스를 사용할 수도 있습니다. 
Passport의 경우 이 는 모두 인증 프로세스를 처리하기 위한 서로 다른 전략이며, 상상해 볼 수 있듯이 라이브러 리가 사실상 제한 없이 인증 서비스를 지원할 수 있도록 합니다. [Passport-Strategy](https://github.com/jaredhanson/passport#strategies-1)지원되는 다양한 인증 공급자의 수를 살펴보고 전략 패턴이 무엇을 할 수 있는지 살펴보십시오.

# 상태(State)
상태(State) 패턴은 컨텍스트의 상태에 따라 전략이 변경되는 특별한 전략 패턴입니다.

이전 섹션에서 환경 설정의 속성 또는 입력 인자와 같은 다양한 변수에 따라 전략을 선택하는 방법을 살펴보았으며, 이 선택이 완료되면 한번 생성된 컨텍스트에서는 전략이 변경되지 않은 상태로 유지됩니다. 
대신 상태 패턴에서는 전략( 상태 패턴에서는 상태라고도 함)은 동적이며 컨텍스트의 생존 주기 동안 변경될 수 있으므로 내부 상태에 따라 동작을 조정할 수 있습니다.

다음 그림은 이 패턴을 보여줍니다.
![스크린샷-2025-07-09-오후-1.41.07.png](/img/이미지 창고/스크린샷-2025-07-09-오후-1.41.07.png)
그림 9.2는 컨텍스트 객체가 세가지 상태(A, B, C)를 통해 어떻게 전환되는지를 보여줍니다.

상태(State) 패턴을 사용하면 서로 다른 컨텍스트 상태에서 서로 다른 전략을 선택합니다. 
이는 컨텍스트 객체가 상태에 따라 다른 동작을 채택한다는 것을 뜻합니다.

더 쉽게 이해할 수 있도록 예를 들어보겠습니다. 
호텔 예약 시스템과 객실 예약을 모델링하는 Reservation이라는 객체가 있다고 가정해 보겠습니다. 
이것은 상태에 따라 객체의 동작을 조정해야 하는 일반적인 상황입니다.

다음과 같은 일련의 이벤트를 생각해 봅시다.

- 예약이 처음 생성되면 사용자가 예약을 확인할 수 있습니다(confirm()이라는 함수 사용). 
	- 물론 아직 예약이 완료되지 않았기 때문에 취소(cancel() 함수 사용)할 수 없습니다(예를 들면 호출자는 에러를 전 달받을 것입니다). 
	- 그러나 구매하기 전에 마음이 바뀌면 삭제(delete() 사용)할 수 있습니다.
- ﻿﻿예약이 완료되면 confirm() 함수를 다시 사용하는 것은 의미가 없습니다. 
	- 그러나 이제는 예약을 취소 할 수 있지만 기록을 위해 보관해야 하므로 더는 객체를 삭제할 수 없습니다.
- ﻿﻿예약일 전날에는 더 이상 예약을 취소할 수 없습니다. 
	- 취소하기에는 너무 늦었습니다.

이제 하나의 모놀리식 객체에서 방금 설명한 예약 시스템을 구현해야 한다고 상상해 보십시오.

여러분의 머릿속에 예약 상태에 따라 각 작업을 활성화/비활성화하기 위해 작성해야 하는 모든 if/else 또는 switch 문이 이미 그려졌을 것입니다
![스크린샷-2025-07-09-오후-1.42.40.png](/img/이미지 창고/스크린샷-2025-07-09-오후-1.42.40.png)
그림 9.3에서 볼 수 있듯이 상태 패턴은 이 상황에서 완벽한 해결책입니다. 
여기에는 3가지 전략(상태)이 있는데, 설명된 세가지 함수(`confirm()`, `cancel()`, `delete()`)입니다. 
이들 모두 각 자 하나의 동작만 하도록 구현합니다. 

즉, 각각의 모델링된 상태에 해당합니다. 
이 패턴을 사 용하면 Reservation 객체가 한 동작에서 다른 동작으로 쉽게 전환할 수 있습니다. 
이것은 단순히 각각의 상태 변경에 따라 다른 전략(상태 객체)의 활성화가 필요합니다.

:::tip 상태 전환
- 상태 전환은 컨텍스트 객체, 클라이언트 코드 또는 상태 객체 자체에 의해 시작되고 제어될 수 있습니다.
- 이때 마지막 옵션은 컨텍스트가 가능한 모든 상태와 이들 사이의 전환 방법에 대해 알 필요가 없기 때문 에 일반적으로 유연성과 디커플링 측면에서 최상의 결과를 제공합니다.

:::

이제 상태 패턴에 대해 배운 내용을 적용할 수 있도록 구체적인 예제를 살펴보겠습니다.

## 기본적인 안전 소캣 구현

서버와 연결이 끊어져도 실패하지 않는 TCP 클라이언트 소켓을 만들어 봅시다. 
대신 서버가 오프라인 상태인 동안 전송된 모든 데이터를 큐에 넣은 다음, 연결이 다시 설정되는 즉시 다시 전송할 것입니다.
이 소켓을 간단한 모니터링 시스템의 맥락에서 활용하고자 합니다. 
일련의 시스템이 정기적으로 리소스 사용에 대한 통계를 전송합니다. 
이러한 리소스를 수집하는 서버 가 다운되면 서버가 다시 온라인 상태가 될 때까지 소켓이 계속해서 데이터를 로컬 큐에 담습니다.

컨텍스트 객체를 정의하기 위한 `failsafeSocket`이라는 새로운 모듈을 만들어 시작하겠습 니다.

```js
import {OfflineState } from '/offlineState.js' 
import {OnlineState } from ' './onlineState.js'

export class FailsafeSocket ( 
	constructor (options) { // (1)
		this.options = options
		this. queue = []
		this. currentState =null
		this. socket = null
		this.states = {
			offLine: new OfflineState(this), 
			online: new OnlineState(this)
		}
		this changeState(' offline')
	}

	changeState (state) { // 2
		console.log(`Activating state: ${state}`)
		this. currentState = this.states[state]
		this.currentState.activate()
	}
	send (data) { // (3)
		this.currentState.send(data)
	}

}
```

FailsafeSocket 클래스는 세가지 주요 요소로 구성됩니다.

1. ﻿﻿﻿생성자는 소켓이 오프라인일 때 전송된 모든 데이터를 담을 큐를 포함하여 다양한 데이터 구조를 초기화합니다. 
	- 또한 두 가지 상태 집합을 생성합니다. 하나는 오프라인일 때 소켓 동작을 구현하기 위한 것이고 다른 하나는 소켓이 온라인일 때입니다.
2. ﻿﻿﻿`changestate()` 함수는 한 상태에서 다른 상태로 전환하는 역할을 합니다. 
	- 단순히 currentState 인스 턴스 변수를 업데이트하고 대상 상태에서 activate()를 호출합니다.
3. ﻿﻿﻿`send()` 함수에서는 `FaiisaieSocket` 클래스의 주요 기능이 포함되어 있습니다. 
	- 온라인/오프라인 상태 에 따라 다른 동작을 처리하는 곳입니다. 보시다시피 현재 활성 상태로 작업을 위임하면 됩니다.

이제 `offlineState.js`에서 시작하여 두 상태가 어떻게 표현되는지 보겠습니다.

```js
import jsonOverTcpfrom 'json-over-tcp-2' // (1)

export class OfflineState {
	constructor (failsafeSocket){
		this.failsafeSocket= failsafeSocket
	}

	send (data){ // (2)
		this.failsafeSocket.queue.push(data)
	}
	activate (){ // (3)
		const retry=()={
			setTimeout(()=> this.activate(), 1000)
		}
	
		console log('Trying toconnect...')
		this.failsafeSocket.socket=jsonOverTcp.connect(
			this. failsafeSocket.options,
			()=> {
				console. log('Connection established')
				this. failsafeSocket.socket.removeListener('error',retry)
				this.failsafeSocket.changeState(online)
			}
		)
		this.failsafeSocket.socket.once'error',retry)
	}
}
```

방금 만든 모듈은 오프라인 상태에서 소켓의 동작을 관리합니다. 작동 방식은 다음과 같습 니다.

1. ﻿﻿﻿원시 TCP 소켓을 사용하는 대신 [jsonover-tcp-2](https://www.npmjs.com/package/json-over-tcp-2)라는 작은 라이 브러리를 사용합니다. 
	- 라이브러리가 소켓을 통과하는 JSON 객체 데이터의 모든 구문 분석 및 형식화 를 처리하므로 작업이 크게 단순화됩니다.
2. ﻿﻿﻿`send()` 함수는 수신한 데이터를 큐에 넣는 작업만 담당합니다. 
	- 우리는 오프라인이라고 가정하고 나중을 위해 데이터 객체를 저장할 것입니다. 
	- 그것이 우리가 지금 할 일의 전부입니다.
3. ﻿﻿﻿`activate()` 함수는 json-over-tcp2 소켓을 사용하여 서버와의 연결을 설정하려고 합니다. 
	- 작업이 실패하면 1초 후에 다시 시도합니다. 
	- 유효한 연결이 설정될 때까지 계속 시도합니다. 
	- 연결이 될 경우 `failsafeSocket` 상태가 온라인으로 전환됩니다.
다음으로, `OnlineState` 클래스를 구현할 `onlineState.js` 모듈을 만들어 보겠습니다.

```js
export class Onlinestate (

	constructor (failsafeSocket){
		this.failsafeSocket = failsafeSocket this.hasDisconnected=false
	}
	
	send (data) { // 1
		this. failsafeSocket.queue.push(data)
		this._safelite(data)
	}
	
	_safelrite (data){ // 2
		this.failsafeSocket.socket.write(data,(err)={
			if (!this.hasDisconnected && !err){
				this. failsafeSocket.queue.shift()
			}
		})
	}

	activate (){ // 3
		this.hasDisconnected = false
		for (const data of this.failsafesocket.queue) {
			this._safeWrite(data)
			this.failsafeSocket.socket.once('error',()=>{
				this.hasDisconnected = true
				this. failsafeSocket.changeState('offline')
			})
		}
	}
}
```

`OnlineState` 클래스는 서버와의 활성화된 연결이 있을 때 `FailsafeSocket`의 동작을 모델링 합니다. 
다음은 그 작동 방식입니다.

1. ﻿﻿﻿`send()` 함수는 데이터를 큐에 넣은 다음 온라인 상태라고 가정하므로 즉시 소켓에 직접 쓰려고 합니다. 
	- 이를 위해 내부의 `_safeWrite()` 함수를 사용합니다.
2. ﻿﻿﻿safeWrite() 함수는 소켓의 쓰기 가능한 스트림(`writable stream`)에 데이터 쓰기를 시도하고 ([공식 문서](https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback)를 참조하세요) 데이터가 리소스를 통해 전송되기를 기다립니다. 
	- 오류가 반환되지 않고, 그동안 소켓의 연결 해지되지 않았다면 데이터가 성공적으로 전송되었 으므로 큐에서 제거됩니다
3. `activate()` 함수는 소켓이 오프라인일 때 대기열에 있던 모든 데이터를 비웁니다. 
	- 반면 소켓이 오프라인이면 에러 메시지가 수신되기 시작합니다. 
	- 우리는 이것을 소켓이 오프라인이 된 증상으로 인식할 것입니다(간단히 하기 위해). 
	- 이런 일이 발생하면 오프라인 상태로 전환됩니다
이것이 `Failsafesocket`을 위한 모든 것입니다. 
이제 샘플 클라이언트와 이를 시험해볼 서버 를 만들 준비가 되었습니다. 
`server.js`라는 모듈에 서버 코드를 작성합니다.

```js
import jsonOverTcp from 'json-over-tcp-2'

const server = jsonOverTcp.createServer({port: 5000})
	server.on(' connection', socket => {
	socket.on ('data', data => {
		console.log ('Client data, data')
	})
})

server.listen(5000, () => console.log('Server started'))
```

그런 다음 우리가 정말 관심을 가지고 있는 클라이언트 측 코드를 `client.js`에 작성합니다.

```js
import {FailsafeSocket } from '/failsafeSocket.js'

const failsafeSocket = new FailsafeSocket port: 5000})

setInterval(() => {
	// 현재 메모리 사용량을 전달
	failsafeSocket.send(process.memoryUsage)
}, 1000)
```

서버는 수신한 JSON 메시지를 콘솔에 간단히 출력하고, 클라이언트는 `FailsafeSocket` 객체 를 활용 하여 매초마다 메모리 사용률 측정값을 전송합니다.

우리가 만든 작은 시스템을 시험해보기 위해서는 클라이언트와 서버를 모두 실행 해야 합니다.

그런 다음 서버를 중지했다가 다시 시작하여 `failsafeSocket`의 기능을 테스트할 수 있습니다.

클라이언트의 상태가 온라인과 오프라인 사이에서 변경되고, 서버가 오프라인일 때 수집된 메 모리 측정이 대기열에 들어간 다음, 서버가 다시 온라인으로 전환 되는 즉시 다시 전송 되는지 확인 합니다.
이 샘플은 상태 패턴이 상태에 따라 동작을 조정해야 하는 컴포넌트의 모듈성과 가독성을 높이 는데 어떻게 도움이 될 수 있는지에 대한 명확한 예시가 됩니다.

:::tip 
- 이 섹션에서 만든 FailsaleSocket 클래스는 상태 패턴을 보여주기 위한 것일 뿐, TCP 소켓과 연결 문제를 처리하기 위한 완전하고 100% 신뢰할 수 있는 솔루션이 되지는 못합니다. 
- 예를 들어, 소켓 스트림에 기 록된 모든 데이터가 서버에서 수신되는지 확인하지 않습니다. 
- 이 경우 설명하려는 패턴과 엄격하게 관련 되지 않은 코드가 더 필요합니다. 
- 실제 운용일 경우 [ZeroMQ](https://zeromq.org/)가 신뢰할 만한 대안 이 될 수 있습니다. 
- 13장. 메시징 및 통합 패턴"에서 ZeroMQ를 사용하는 일부 패턴에 대해 설명할 것입 니다.

:::

# 템플릿

분석하려는 다음 패턴은 템플릿 패턴이라고 하며 전략 패턴과 공통점이 많습니다. 
템플릿 패턴 은 먼저 컴포넌트의 스켈레톤(공통부분을 나타냄)을 구현하는 추상 클래스를 정의합니다. 
그렇게 되면 일부 단계는 정의되지 않은 상태로 남아 있게 됩니다. 
그런 다음 하위 클래스는 템플 릿 함수라고 하는 누락된 함수 부분을 구현하여 컴포넌트의 빈 부분을 채울 수 있습니다. 
이 패턴의 목적은 모든 컴포넌트의 모든 변형 집합을 정의할 수 있도록 하는 것입니다. 
다음 UML 다이어그램은 방금 설명한 구조를 보여줍니다.
![스크린샷-2025-07-09-오후-2.04.54.png](/img/이미지 창고/스크린샷-2025-07-09-오후-2.04.54.png)
그림 9.4에 표현된 세가지 구체적인 클래스는 템플릿 클래스를 확장하고, C++ 용어를 사용하자면, 추상 또는 순수 가상인 `templateMethod()`에 대한 구현을 제공하게 됩니다.

JavaScript에서는 추상 클래스를 정의하는 공식적인 방법이 없으므로 함수를 정의하지 않은 상태로 두거나 항상 예외를 발생시키는 함수에 할당하여 함수를 구현해야 함을 나타냅니다. 
상속이 구현의 핵심적인 부분이기 때문에 템플릿 패턴은 지금까지 본 다른 패턴보다 더 전통적인 객체지향 패턴으로 여겨질 수 있습니다.

템플릿(`Template`)과 전략(`Strategy`)의 목적은 매우 유사하지만 두 가지 중요한 차이점은 그 구조와 구현에 있습니다. 
둘 다 공통 부분을 재사용하면서 구성 요소의 가변 부분을 변경할 수 있습니다. 
그러나 전략(`Strategy`)을 사용하면 실행 시에 동적으로 수행할 수 있지만 템플릿 (`Template`)을 사용하면 구체적인 클래스가 정의되는 그 순간, 전체 컴포넌트 동작이 결정됩 니다. 이러한 가정하에서 템플릿 패턴은 컴포넌트의 사전에 패키징된 변형을 생성하려는 상황에 더 적합할 수 있습니다. 
항상 그렇듯이 한 패턴과 다른 패턴 사이의 선택은 개발자가 각각의 사용 사례에 대해 다양한 장단점을 고려해 적용해야 합니다.

이제 예제를 살펴보겠습니다

## 환경 설정 관리 템플릿

전략(Strategy)과 템플릿(Template)의 차이점을 더 잘 이해하기 위해 전략 패턴 섹션에서 정의한 Config 객체를 다시 한번 구현해 보겠습니다. 
이번에는 템플릿 패턴을 사용합니다. 
이전 버전의 Config 객체에서와 다른 파일 형식을 사용하여 일련의 환경설정 속성들을 로드하고 저장할 수 있도록 할 것입니다.

템플릿 클래스를 정의하는 것으로 시작하겠습니다. 이를 `ConfigTemnplate`라 부를 것입니다.
```js
import { promises as fsPromises } from 'fs' 
import objectPath from 'object-path'

export class ConfigTemplate {

	async load (file) {
		console.log(`Deserializing from ${file}`)
		this.data = this._deserialize(await fsPromises. readFile(file, 'utf-8'))
	}
	
	async save (file) {
		console. log(`Serializing to ${file}`)
		await fsPromises.writeFile(file, this serialize(this.data))
	}
	get (path) {
		return objectPath.get(this.data, path)
	}
	set (path, value) {
		return objectPath.set(this.data, path, value)
	}

	_serialize (){
		throw new Error(' serialize) must be implemented')
	}
	
	_deserialize (){
		throw new Error('_deserialize() must be impLemented')
	}
}
```




